
  // Automatically generated, do not edit
  
          #include "RJSHelper_qcad.h"
        
          #include "header_qcad_cpp.h"
        
          #include "raction_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "raddobjectsoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rarc_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rtextbaseddata_wrapper.h"
        
          #include "rtextbaseddata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rtextbasedentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rtextbasedentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rblocklistener_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qtoolbar_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rwidget_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rcircle_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qcolor_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qlineedit_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "rinputevent_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rcoordinatelistener_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rclipboardoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rdeleteobjectsoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rclipboardoperation_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimlineardata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimlinearentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimangulardata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimangularentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimangulardata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimangularentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimangulardata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimangularentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimlineardata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimlinearentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rdimstyledata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qdockwidget_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rellipse_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rinputevent_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rsoliddata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rexporter_wrapper.h"
        
          #include "rexporter_wrapper.h"
        
          #include "rfileexporter_wrapper.h"
        
          #include "rfileexporterfactory_wrapper.h"
        
          #include "rimporter_wrapper.h"
        
          #include "rimporter_wrapper.h"
        
          #include "rfileimporter_wrapper.h"
        
          #include "rfileimporterfactory_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemmodel_wrapper.h"
        
          #include "qfilesystemmodel_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
          #include "qlayout_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rfocuslistener_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rexporter_wrapper.h"
        
          #include "rexporter_wrapper.h"
        
          #include "rgraphicsscene_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rgraphicsview_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rfocuslistener_wrapper.h"
        
          #include "rtransactionlistener_wrapper.h"
        
          #include "rselectionlistener_wrapper.h"
        
          #include "qaction_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rintertransactionlistener_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rkeylistener_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rlayerlistener_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpolyline_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rline_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qlistview_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qlistview_wrapper.h"
        
          #include "qlistwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qmainwindow_wrapper.h"
        
          #include "rmainwindow_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qlineedit_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qmdiarea_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rmodifiedlistener_wrapper.h"
        
          #include "qmdisubwindow_wrapper.h"
        
          #include "rstorage_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "raddobjectoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "raddobjectsoperation_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qinputevent_wrapper.h"
        
          #include "qpointerevent_wrapper.h"
        
          #include "qsinglepointevent_wrapper.h"
        
          #include "qmouseevent_wrapper.h"
        
          #include "rinputevent_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rgrid_wrapper.h"
        
          #include "qpainterpath_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpalettelistener_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rclipboardoperation_wrapper.h"
        
          #include "rpatternlist_wrapper.h"
        
          #include "rpatternlist_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpenlistener_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpoint_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rexplodable_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpolyline_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpreferenceslistener_wrapper.h"
        
          #include "rpropertylistener_wrapper.h"
        
          #include "rlayerlistener_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpropertylistener_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rxline_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rray_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rvector_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
          #include "rrestrictorthogonal_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
          #include "rrestrictorthogonal_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "rruler_wrapper.h"
        
          #include "rcoordinatelistener_wrapper.h"
        
          #include "rpalettelistener_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rselectionlistener_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qcoreapplication_wrapper.h"
        
          #include "qguiapplication_wrapper.h"
        
          #include "qapplication_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpolyline_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rspatialindex_wrapper.h"
        
          #include "rspatialindex_wrapper.h"
        
          #include "rspatialindexvisitor_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rexplodable_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rspline_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpainterpathsource_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rtextbaseddata_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qtextedit_wrapper.h"
        
          #include "qtextbrowser_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rtextbasedentity_wrapper.h"
        
          #include "rpoint_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qtoolbutton_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemdelegate_wrapper.h"
        
          #include "qitemdelegate_wrapper.h"
        
          #include "rsoliddata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rtransactionlistener_wrapper.h"
        
          #include "qtransform_wrapper.h"
        
          #include "rtransformation_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qtreeview_wrapper.h"
        
          #include "qtreewidget_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rexplodable_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rviewfocuslistener_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rviewlistener_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpoint_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qinputevent_wrapper.h"
        
          #include "qpointerevent_wrapper.h"
        
          #include "qsinglepointevent_wrapper.h"
        
          #include "qwheelevent_wrapper.h"
        
          #include "rinputevent_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rxline_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        void RJSHelper_qcad::registerDowncasters() {

          
            // downcasters from QEvent to ...
            
              // downcasters from QEvent to RCloseCurrentEvent
              RJSHelper::registerDowncaster_QEvent(new RJSDowncaster_QEvent_RCloseCurrentEvent());
            
              // downcasters from QEvent to RPropertyEvent
              RJSHelper::registerDowncaster_QEvent(new RJSDowncaster_QEvent_RPropertyEvent());
            
              // downcasters from QEvent to RTerminateEvent
              RJSHelper::registerDowncaster_QEvent(new RJSDowncaster_QEvent_RTerminateEvent());
            
            // downcasters from QObject to ...
            
              // downcasters from QObject to REventFilter
              RJSHelper::registerDowncaster_QObject(new RJSDowncaster_QObject_REventFilter());
            
              // downcasters from QObject to REventHandler
              RJSHelper::registerDowncaster_QObject(new RJSDowncaster_QObject_REventHandler());
            
            // downcasters from QToolBar to ...
            
              // downcasters from QToolBar to RCadToolBar
              RJSHelper::registerDowncaster_QToolBar(new RJSDowncaster_QToolBar_RCadToolBar());
            
            // downcasters from QWidget to ...
            
              // downcasters from QWidget to RCharacterWidget
              RJSHelper::registerDowncaster_QWidget(new RJSDowncaster_QWidget_RCharacterWidget());
            
              // downcasters from QWidget to RFontChooserWidget
              RJSHelper::registerDowncaster_QWidget(new RJSDowncaster_QWidget_RFontChooserWidget());
            
              // downcasters from QWidget to RGraphicsViewQt
              RJSHelper::registerDowncaster_QWidget(new RJSDowncaster_QWidget_RGraphicsViewQt());
            
              // downcasters from QWidget to RWidget
              RJSHelper::registerDowncaster_QWidget(new RJSDowncaster_QWidget_RWidget());
            
        }

        void RJSHelper_qcad::registerBasecasters() {
          
            // registration of base casters that cast RAction to base classes:
            
            // registration of base casters that cast RActionAdapter to base classes:
            
              // registration of base casters that casts RActionAdapter to RAction:
              RAction_Wrapper::registerBasecaster_RAction(new RJSBasecaster_RActionAdapter_RAction());
            
            // registration of base casters that cast RAddObjectOperation to base classes:
            
              // registration of base casters that casts RAddObjectOperation to ROperation:
              ROperation_Wrapper::registerBasecaster_ROperation(new RJSBasecaster_RAddObjectOperation_ROperation());
            
              // registration of base casters that casts RAddObjectOperation to RAddObjectsOperation:
              RAddObjectsOperation_Wrapper::registerBasecaster_RAddObjectsOperation(new RJSBasecaster_RAddObjectOperation_RAddObjectsOperation());
            
            // registration of base casters that cast RAddObjectsOperation to base classes:
            
              // registration of base casters that casts RAddObjectsOperation to ROperation:
              ROperation_Wrapper::registerBasecaster_ROperation(new RJSBasecaster_RAddObjectsOperation_ROperation());
            
            // registration of base casters that cast RArc to base classes:
            
              // registration of base casters that casts RArc to RShape:
              RShape_Wrapper::registerBasecaster_RShape(new RJSBasecaster_RArc_RShape());
            
            // registration of base casters that cast RArcData to base classes:
            
              // registration of base casters that casts RArcData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RArcData_REntityData());
            
              // registration of base casters that casts RArcData to RArc:
              RArc_Wrapper::registerBasecaster_RArc(new RJSBasecaster_RArcData_RArc());
            
            // registration of base casters that cast RArcEntity to base classes:
            
              // registration of base casters that casts RArcEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RArcEntity_RObject());
            
              // registration of base casters that casts RArcEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RArcEntity_REntity());
            
            // registration of base casters that cast RAttributeData to base classes:
            
              // registration of base casters that casts RAttributeData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RAttributeData_REntityData());
            
              // registration of base casters that casts RAttributeData to RTextBasedData:
              RTextBasedData_Wrapper::registerBasecaster_RTextBasedData(new RJSBasecaster_RAttributeData_RTextBasedData());
            
            // registration of base casters that cast RAttributeDefinitionData to base classes:
            
              // registration of base casters that casts RAttributeDefinitionData to RTextBasedData:
              RTextBasedData_Wrapper::registerBasecaster_RTextBasedData(new RJSBasecaster_RAttributeDefinitionData_RTextBasedData());
            
            // registration of base casters that cast RAttributeDefinitionEntity to base classes:
            
              // registration of base casters that casts RAttributeDefinitionEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RAttributeDefinitionEntity_RObject());
            
              // registration of base casters that casts RAttributeDefinitionEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RAttributeDefinitionEntity_REntity());
            
              // registration of base casters that casts RAttributeDefinitionEntity to RTextBasedEntity:
              RTextBasedEntity_Wrapper::registerBasecaster_RTextBasedEntity(new RJSBasecaster_RAttributeDefinitionEntity_RTextBasedEntity());
            
            // registration of base casters that cast RAttributeEntity to base classes:
            
              // registration of base casters that casts RAttributeEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RAttributeEntity_RObject());
            
              // registration of base casters that casts RAttributeEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RAttributeEntity_REntity());
            
              // registration of base casters that casts RAttributeEntity to RTextBasedEntity:
              RTextBasedEntity_Wrapper::registerBasecaster_RTextBasedEntity(new RJSBasecaster_RAttributeEntity_RTextBasedEntity());
            
            // registration of base casters that cast RAutoLoadJs to base classes:
            
            // registration of base casters that cast RBlock to base classes:
            
              // registration of base casters that casts RBlock to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RBlock_RObject());
            
            // registration of base casters that cast RBlockListener to base classes:
            
            // registration of base casters that cast RBlockListenerAdapter to base classes:
            
              // registration of base casters that casts RBlockListenerAdapter to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RBlockListenerAdapter_QObject());
            
              // registration of base casters that casts RBlockListenerAdapter to RBlockListener:
              RBlockListener_Wrapper::registerBasecaster_RBlockListener(new RJSBasecaster_RBlockListenerAdapter_RBlockListener());
            
            // registration of base casters that cast RBlockReferenceData to base classes:
            
              // registration of base casters that casts RBlockReferenceData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RBlockReferenceData_REntityData());
            
            // registration of base casters that cast RBlockReferenceEntity to base classes:
            
              // registration of base casters that casts RBlockReferenceEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RBlockReferenceEntity_RObject());
            
              // registration of base casters that casts RBlockReferenceEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RBlockReferenceEntity_REntity());
            
            // registration of base casters that cast RBox to base classes:
            
            // registration of base casters that cast RCadToolBar to base classes:
            
              // registration of base casters that casts RCadToolBar to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RCadToolBar_QObject());
            
              // registration of base casters that casts RCadToolBar to QWidget:
              QWidget_Wrapper::registerBasecaster_QWidget(new RJSBasecaster_RCadToolBar_QWidget());
            
              // registration of base casters that casts RCadToolBar to QToolBar:
              QToolBar_Wrapper::registerBasecaster_QToolBar(new RJSBasecaster_RCadToolBar_QToolBar());
            
            // registration of base casters that cast RCadToolBarPanel to base classes:
            
              // registration of base casters that casts RCadToolBarPanel to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RCadToolBarPanel_QObject());
            
              // registration of base casters that casts RCadToolBarPanel to QWidget:
              QWidget_Wrapper::registerBasecaster_QWidget(new RJSBasecaster_RCadToolBarPanel_QWidget());
            
              // registration of base casters that casts RCadToolBarPanel to RWidget:
              RWidget_Wrapper::registerBasecaster_RWidget(new RJSBasecaster_RCadToolBarPanel_RWidget());
            
            // registration of base casters that cast RChangePropertyOperation to base classes:
            
              // registration of base casters that casts RChangePropertyOperation to ROperation:
              ROperation_Wrapper::registerBasecaster_ROperation(new RJSBasecaster_RChangePropertyOperation_ROperation());
            
            // registration of base casters that cast RCharacterWidget to base classes:
            
              // registration of base casters that casts RCharacterWidget to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RCharacterWidget_QObject());
            
              // registration of base casters that casts RCharacterWidget to QWidget:
              QWidget_Wrapper::registerBasecaster_QWidget(new RJSBasecaster_RCharacterWidget_QWidget());
            
            // registration of base casters that cast RCircle to base classes:
            
              // registration of base casters that casts RCircle to RShape:
              RShape_Wrapper::registerBasecaster_RShape(new RJSBasecaster_RCircle_RShape());
            
            // registration of base casters that cast RCircleData to base classes:
            
              // registration of base casters that casts RCircleData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RCircleData_REntityData());
            
              // registration of base casters that casts RCircleData to RCircle:
              RCircle_Wrapper::registerBasecaster_RCircle(new RJSBasecaster_RCircleData_RCircle());
            
            // registration of base casters that cast RCircleEntity to base classes:
            
              // registration of base casters that casts RCircleEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RCircleEntity_RObject());
            
              // registration of base casters that casts RCircleEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RCircleEntity_REntity());
            
            // registration of base casters that cast RClickReferencePointOperation to base classes:
            
              // registration of base casters that casts RClickReferencePointOperation to ROperation:
              ROperation_Wrapper::registerBasecaster_ROperation(new RJSBasecaster_RClickReferencePointOperation_ROperation());
            
            // registration of base casters that cast RClipboardOperation to base classes:
            
              // registration of base casters that casts RClipboardOperation to ROperation:
              ROperation_Wrapper::registerBasecaster_ROperation(new RJSBasecaster_RClipboardOperation_ROperation());
            
            // registration of base casters that cast RCloseCurrentEvent to base classes:
            
              // registration of base casters that casts RCloseCurrentEvent to QEvent:
              QEvent_Wrapper::registerBasecaster_QEvent(new RJSBasecaster_RCloseCurrentEvent_QEvent());
            
            // registration of base casters that cast RColor to base classes:
            
              // registration of base casters that casts RColor to QColor:
              QColor_Wrapper::registerBasecaster_QColor(new RJSBasecaster_RColor_QColor());
            
            // registration of base casters that cast RColorCombo to base classes:
            
              // registration of base casters that casts RColorCombo to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RColorCombo_QObject());
            
              // registration of base casters that casts RColorCombo to QWidget:
              QWidget_Wrapper::registerBasecaster_QWidget(new RJSBasecaster_RColorCombo_QWidget());
            
              // registration of base casters that casts RColorCombo to QComboBox:
              QComboBox_Wrapper::registerBasecaster_QComboBox(new RJSBasecaster_RColorCombo_QComboBox());
            
            // registration of base casters that cast RCommandEvent to base classes:
            
            // registration of base casters that cast RCommandLine to base classes:
            
              // registration of base casters that casts RCommandLine to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RCommandLine_QObject());
            
              // registration of base casters that casts RCommandLine to QWidget:
              QWidget_Wrapper::registerBasecaster_QWidget(new RJSBasecaster_RCommandLine_QWidget());
            
              // registration of base casters that casts RCommandLine to QLineEdit:
              QLineEdit_Wrapper::registerBasecaster_QLineEdit(new RJSBasecaster_RCommandLine_QLineEdit());
            
            // registration of base casters that cast RCoordinateEvent to base classes:
            
              // registration of base casters that casts RCoordinateEvent to QEvent:
              QEvent_Wrapper::registerBasecaster_QEvent(new RJSBasecaster_RCoordinateEvent_QEvent());
            
              // registration of base casters that casts RCoordinateEvent to RInputEvent:
              RInputEvent_Wrapper::registerBasecaster_RInputEvent(new RJSBasecaster_RCoordinateEvent_RInputEvent());
            
            // registration of base casters that cast RCoordinateListener to base classes:
            
            // registration of base casters that cast RCoordinateListenerAdapter to base classes:
            
              // registration of base casters that casts RCoordinateListenerAdapter to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RCoordinateListenerAdapter_QObject());
            
              // registration of base casters that casts RCoordinateListenerAdapter to RCoordinateListener:
              RCoordinateListener_Wrapper::registerBasecaster_RCoordinateListener(new RJSBasecaster_RCoordinateListenerAdapter_RCoordinateListener());
            
            // registration of base casters that cast RCopyOperation to base classes:
            
              // registration of base casters that casts RCopyOperation to ROperation:
              ROperation_Wrapper::registerBasecaster_ROperation(new RJSBasecaster_RCopyOperation_ROperation());
            
              // registration of base casters that casts RCopyOperation to RClipboardOperation:
              RClipboardOperation_Wrapper::registerBasecaster_RClipboardOperation(new RJSBasecaster_RCopyOperation_RClipboardOperation());
            
            // registration of base casters that cast RDebug to base classes:
            
            // registration of base casters that cast RDeleteAllEntitiesOperation to base classes:
            
              // registration of base casters that casts RDeleteAllEntitiesOperation to ROperation:
              ROperation_Wrapper::registerBasecaster_ROperation(new RJSBasecaster_RDeleteAllEntitiesOperation_ROperation());
            
            // registration of base casters that cast RDeleteObjectOperation to base classes:
            
              // registration of base casters that casts RDeleteObjectOperation to ROperation:
              ROperation_Wrapper::registerBasecaster_ROperation(new RJSBasecaster_RDeleteObjectOperation_ROperation());
            
              // registration of base casters that casts RDeleteObjectOperation to RDeleteObjectsOperation:
              RDeleteObjectsOperation_Wrapper::registerBasecaster_RDeleteObjectsOperation(new RJSBasecaster_RDeleteObjectOperation_RDeleteObjectsOperation());
            
            // registration of base casters that cast RDeleteObjectsOperation to base classes:
            
              // registration of base casters that casts RDeleteObjectsOperation to ROperation:
              ROperation_Wrapper::registerBasecaster_ROperation(new RJSBasecaster_RDeleteObjectsOperation_ROperation());
            
            // registration of base casters that cast RDeleteSelectionOperation to base classes:
            
              // registration of base casters that casts RDeleteSelectionOperation to ROperation:
              ROperation_Wrapper::registerBasecaster_ROperation(new RJSBasecaster_RDeleteSelectionOperation_ROperation());
            
              // registration of base casters that casts RDeleteSelectionOperation to RClipboardOperation:
              RClipboardOperation_Wrapper::registerBasecaster_RClipboardOperation(new RJSBasecaster_RDeleteSelectionOperation_RClipboardOperation());
            
            // registration of base casters that cast RDimAlignedData to base classes:
            
              // registration of base casters that casts RDimAlignedData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RDimAlignedData_REntityData());
            
              // registration of base casters that casts RDimAlignedData to RDimensionData:
              RDimensionData_Wrapper::registerBasecaster_RDimensionData(new RJSBasecaster_RDimAlignedData_RDimensionData());
            
              // registration of base casters that casts RDimAlignedData to RDimLinearData:
              RDimLinearData_Wrapper::registerBasecaster_RDimLinearData(new RJSBasecaster_RDimAlignedData_RDimLinearData());
            
            // registration of base casters that cast RDimAlignedEntity to base classes:
            
              // registration of base casters that casts RDimAlignedEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RDimAlignedEntity_RObject());
            
              // registration of base casters that casts RDimAlignedEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RDimAlignedEntity_REntity());
            
              // registration of base casters that casts RDimAlignedEntity to RDimensionEntity:
              RDimensionEntity_Wrapper::registerBasecaster_RDimensionEntity(new RJSBasecaster_RDimAlignedEntity_RDimensionEntity());
            
              // registration of base casters that casts RDimAlignedEntity to RDimLinearEntity:
              RDimLinearEntity_Wrapper::registerBasecaster_RDimLinearEntity(new RJSBasecaster_RDimAlignedEntity_RDimLinearEntity());
            
            // registration of base casters that cast RDimAngular2LData to base classes:
            
              // registration of base casters that casts RDimAngular2LData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RDimAngular2LData_REntityData());
            
              // registration of base casters that casts RDimAngular2LData to RDimensionData:
              RDimensionData_Wrapper::registerBasecaster_RDimensionData(new RJSBasecaster_RDimAngular2LData_RDimensionData());
            
              // registration of base casters that casts RDimAngular2LData to RDimAngularData:
              RDimAngularData_Wrapper::registerBasecaster_RDimAngularData(new RJSBasecaster_RDimAngular2LData_RDimAngularData());
            
            // registration of base casters that cast RDimAngular2LEntity to base classes:
            
              // registration of base casters that casts RDimAngular2LEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RDimAngular2LEntity_RObject());
            
              // registration of base casters that casts RDimAngular2LEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RDimAngular2LEntity_REntity());
            
              // registration of base casters that casts RDimAngular2LEntity to RDimensionEntity:
              RDimensionEntity_Wrapper::registerBasecaster_RDimensionEntity(new RJSBasecaster_RDimAngular2LEntity_RDimensionEntity());
            
              // registration of base casters that casts RDimAngular2LEntity to RDimAngularEntity:
              RDimAngularEntity_Wrapper::registerBasecaster_RDimAngularEntity(new RJSBasecaster_RDimAngular2LEntity_RDimAngularEntity());
            
            // registration of base casters that cast RDimAngular3PData to base classes:
            
              // registration of base casters that casts RDimAngular3PData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RDimAngular3PData_REntityData());
            
              // registration of base casters that casts RDimAngular3PData to RDimensionData:
              RDimensionData_Wrapper::registerBasecaster_RDimensionData(new RJSBasecaster_RDimAngular3PData_RDimensionData());
            
              // registration of base casters that casts RDimAngular3PData to RDimAngularData:
              RDimAngularData_Wrapper::registerBasecaster_RDimAngularData(new RJSBasecaster_RDimAngular3PData_RDimAngularData());
            
            // registration of base casters that cast RDimAngular3PEntity to base classes:
            
              // registration of base casters that casts RDimAngular3PEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RDimAngular3PEntity_RObject());
            
              // registration of base casters that casts RDimAngular3PEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RDimAngular3PEntity_REntity());
            
              // registration of base casters that casts RDimAngular3PEntity to RDimensionEntity:
              RDimensionEntity_Wrapper::registerBasecaster_RDimensionEntity(new RJSBasecaster_RDimAngular3PEntity_RDimensionEntity());
            
              // registration of base casters that casts RDimAngular3PEntity to RDimAngularEntity:
              RDimAngularEntity_Wrapper::registerBasecaster_RDimAngularEntity(new RJSBasecaster_RDimAngular3PEntity_RDimAngularEntity());
            
            // registration of base casters that cast RDimAngularData to base classes:
            
              // registration of base casters that casts RDimAngularData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RDimAngularData_REntityData());
            
              // registration of base casters that casts RDimAngularData to RDimensionData:
              RDimensionData_Wrapper::registerBasecaster_RDimensionData(new RJSBasecaster_RDimAngularData_RDimensionData());
            
            // registration of base casters that cast RDimAngularEntity to base classes:
            
              // registration of base casters that casts RDimAngularEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RDimAngularEntity_RObject());
            
              // registration of base casters that casts RDimAngularEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RDimAngularEntity_REntity());
            
              // registration of base casters that casts RDimAngularEntity to RDimensionEntity:
              RDimensionEntity_Wrapper::registerBasecaster_RDimensionEntity(new RJSBasecaster_RDimAngularEntity_RDimensionEntity());
            
            // registration of base casters that cast RDimArcLengthData to base classes:
            
              // registration of base casters that casts RDimArcLengthData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RDimArcLengthData_REntityData());
            
              // registration of base casters that casts RDimArcLengthData to RDimensionData:
              RDimensionData_Wrapper::registerBasecaster_RDimensionData(new RJSBasecaster_RDimArcLengthData_RDimensionData());
            
              // registration of base casters that casts RDimArcLengthData to RDimAngularData:
              RDimAngularData_Wrapper::registerBasecaster_RDimAngularData(new RJSBasecaster_RDimArcLengthData_RDimAngularData());
            
            // registration of base casters that cast RDimArcLengthEntity to base classes:
            
              // registration of base casters that casts RDimArcLengthEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RDimArcLengthEntity_RObject());
            
              // registration of base casters that casts RDimArcLengthEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RDimArcLengthEntity_REntity());
            
              // registration of base casters that casts RDimArcLengthEntity to RDimensionEntity:
              RDimensionEntity_Wrapper::registerBasecaster_RDimensionEntity(new RJSBasecaster_RDimArcLengthEntity_RDimensionEntity());
            
              // registration of base casters that casts RDimArcLengthEntity to RDimAngularEntity:
              RDimAngularEntity_Wrapper::registerBasecaster_RDimAngularEntity(new RJSBasecaster_RDimArcLengthEntity_RDimAngularEntity());
            
            // registration of base casters that cast RDimDiametricData to base classes:
            
              // registration of base casters that casts RDimDiametricData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RDimDiametricData_REntityData());
            
              // registration of base casters that casts RDimDiametricData to RDimensionData:
              RDimensionData_Wrapper::registerBasecaster_RDimensionData(new RJSBasecaster_RDimDiametricData_RDimensionData());
            
            // registration of base casters that cast RDimDiametricEntity to base classes:
            
              // registration of base casters that casts RDimDiametricEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RDimDiametricEntity_RObject());
            
              // registration of base casters that casts RDimDiametricEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RDimDiametricEntity_REntity());
            
              // registration of base casters that casts RDimDiametricEntity to RDimensionEntity:
              RDimensionEntity_Wrapper::registerBasecaster_RDimensionEntity(new RJSBasecaster_RDimDiametricEntity_RDimensionEntity());
            
            // registration of base casters that cast RDimLinearData to base classes:
            
              // registration of base casters that casts RDimLinearData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RDimLinearData_REntityData());
            
              // registration of base casters that casts RDimLinearData to RDimensionData:
              RDimensionData_Wrapper::registerBasecaster_RDimensionData(new RJSBasecaster_RDimLinearData_RDimensionData());
            
            // registration of base casters that cast RDimLinearEntity to base classes:
            
              // registration of base casters that casts RDimLinearEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RDimLinearEntity_RObject());
            
              // registration of base casters that casts RDimLinearEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RDimLinearEntity_REntity());
            
              // registration of base casters that casts RDimLinearEntity to RDimensionEntity:
              RDimensionEntity_Wrapper::registerBasecaster_RDimensionEntity(new RJSBasecaster_RDimLinearEntity_RDimensionEntity());
            
            // registration of base casters that cast RDimOrdinateData to base classes:
            
              // registration of base casters that casts RDimOrdinateData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RDimOrdinateData_REntityData());
            
              // registration of base casters that casts RDimOrdinateData to RDimensionData:
              RDimensionData_Wrapper::registerBasecaster_RDimensionData(new RJSBasecaster_RDimOrdinateData_RDimensionData());
            
            // registration of base casters that cast RDimOrdinateEntity to base classes:
            
              // registration of base casters that casts RDimOrdinateEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RDimOrdinateEntity_RObject());
            
              // registration of base casters that casts RDimOrdinateEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RDimOrdinateEntity_REntity());
            
              // registration of base casters that casts RDimOrdinateEntity to RDimensionEntity:
              RDimensionEntity_Wrapper::registerBasecaster_RDimensionEntity(new RJSBasecaster_RDimOrdinateEntity_RDimensionEntity());
            
            // registration of base casters that cast RDimRadialData to base classes:
            
              // registration of base casters that casts RDimRadialData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RDimRadialData_REntityData());
            
              // registration of base casters that casts RDimRadialData to RDimensionData:
              RDimensionData_Wrapper::registerBasecaster_RDimensionData(new RJSBasecaster_RDimRadialData_RDimensionData());
            
            // registration of base casters that cast RDimRadialEntity to base classes:
            
              // registration of base casters that casts RDimRadialEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RDimRadialEntity_RObject());
            
              // registration of base casters that casts RDimRadialEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RDimRadialEntity_REntity());
            
              // registration of base casters that casts RDimRadialEntity to RDimensionEntity:
              RDimensionEntity_Wrapper::registerBasecaster_RDimensionEntity(new RJSBasecaster_RDimRadialEntity_RDimensionEntity());
            
            // registration of base casters that cast RDimRotatedData to base classes:
            
              // registration of base casters that casts RDimRotatedData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RDimRotatedData_REntityData());
            
              // registration of base casters that casts RDimRotatedData to RDimensionData:
              RDimensionData_Wrapper::registerBasecaster_RDimensionData(new RJSBasecaster_RDimRotatedData_RDimensionData());
            
              // registration of base casters that casts RDimRotatedData to RDimLinearData:
              RDimLinearData_Wrapper::registerBasecaster_RDimLinearData(new RJSBasecaster_RDimRotatedData_RDimLinearData());
            
            // registration of base casters that cast RDimRotatedEntity to base classes:
            
              // registration of base casters that casts RDimRotatedEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RDimRotatedEntity_RObject());
            
              // registration of base casters that casts RDimRotatedEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RDimRotatedEntity_REntity());
            
              // registration of base casters that casts RDimRotatedEntity to RDimensionEntity:
              RDimensionEntity_Wrapper::registerBasecaster_RDimensionEntity(new RJSBasecaster_RDimRotatedEntity_RDimensionEntity());
            
              // registration of base casters that casts RDimRotatedEntity to RDimLinearEntity:
              RDimLinearEntity_Wrapper::registerBasecaster_RDimLinearEntity(new RJSBasecaster_RDimRotatedEntity_RDimLinearEntity());
            
            // registration of base casters that cast RDimStyle to base classes:
            
              // registration of base casters that casts RDimStyle to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RDimStyle_RObject());
            
              // registration of base casters that casts RDimStyle to RDimStyleData:
              RDimStyleData_Wrapper::registerBasecaster_RDimStyleData(new RJSBasecaster_RDimStyle_RDimStyleData());
            
            // registration of base casters that cast RDimStyleData to base classes:
            
            // registration of base casters that cast RDimensionData to base classes:
            
              // registration of base casters that casts RDimensionData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RDimensionData_REntityData());
            
            // registration of base casters that cast RDimensionEntity to base classes:
            
              // registration of base casters that casts RDimensionEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RDimensionEntity_RObject());
            
              // registration of base casters that casts RDimensionEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RDimensionEntity_REntity());
            
            // registration of base casters that cast RDirected to base classes:
            
            // registration of base casters that cast RDockWidget to base classes:
            
              // registration of base casters that casts RDockWidget to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RDockWidget_QObject());
            
              // registration of base casters that casts RDockWidget to QWidget:
              QWidget_Wrapper::registerBasecaster_QWidget(new RJSBasecaster_RDockWidget_QWidget());
            
              // registration of base casters that casts RDockWidget to QDockWidget:
              QDockWidget_Wrapper::registerBasecaster_QDockWidget(new RJSBasecaster_RDockWidget_QDockWidget());
            
            // registration of base casters that cast RDocument to base classes:
            
            // registration of base casters that cast RDocumentInterface to base classes:
            
            // registration of base casters that cast RDocumentVariables to base classes:
            
              // registration of base casters that casts RDocumentVariables to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RDocumentVariables_RObject());
            
            // registration of base casters that cast RDxfServices to base classes:
            
            // registration of base casters that cast REllipse to base classes:
            
              // registration of base casters that casts REllipse to RShape:
              RShape_Wrapper::registerBasecaster_RShape(new RJSBasecaster_REllipse_RShape());
            
            // registration of base casters that cast REllipseData to base classes:
            
              // registration of base casters that casts REllipseData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_REllipseData_REntityData());
            
              // registration of base casters that casts REllipseData to REllipse:
              REllipse_Wrapper::registerBasecaster_REllipse(new RJSBasecaster_REllipseData_REllipse());
            
            // registration of base casters that cast REllipseEntity to base classes:
            
              // registration of base casters that casts REllipseEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_REllipseEntity_RObject());
            
              // registration of base casters that casts REllipseEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_REllipseEntity_REntity());
            
            // registration of base casters that cast REntity to base classes:
            
              // registration of base casters that casts REntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_REntity_RObject());
            
            // registration of base casters that cast REntityData to base classes:
            
            // registration of base casters that cast REntityExportListener to base classes:
            
            // registration of base casters that cast REntityPickEvent to base classes:
            
              // registration of base casters that casts REntityPickEvent to RInputEvent:
              RInputEvent_Wrapper::registerBasecaster_RInputEvent(new RJSBasecaster_REntityPickEvent_RInputEvent());
            
            // registration of base casters that cast REventFilter to base classes:
            
              // registration of base casters that casts REventFilter to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_REventFilter_QObject());
            
            // registration of base casters that cast REventHandler to base classes:
            
              // registration of base casters that casts REventHandler to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_REventHandler_QObject());
            
            // registration of base casters that cast RExplodable to base classes:
            
            // registration of base casters that cast RExportListener to base classes:
            
            // registration of base casters that cast RExporter to base classes:
            
            // registration of base casters that cast RFaceData to base classes:
            
              // registration of base casters that casts RFaceData to RSolidData:
              RSolidData_Wrapper::registerBasecaster_RSolidData(new RJSBasecaster_RFaceData_RSolidData());
            
            // registration of base casters that cast RFaceEntity to base classes:
            
              // registration of base casters that casts RFaceEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RFaceEntity_RObject());
            
              // registration of base casters that casts RFaceEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RFaceEntity_REntity());
            
            // registration of base casters that cast RFileCache to base classes:
            
            // registration of base casters that cast RFileExporter to base classes:
            
              // registration of base casters that casts RFileExporter to RExporter:
              RExporter_Wrapper::registerBasecaster_RExporter(new RJSBasecaster_RFileExporter_RExporter());
            
            // registration of base casters that cast RFileExporterAdapter to base classes:
            
              // registration of base casters that casts RFileExporterAdapter to RExporter:
              RExporter_Wrapper::registerBasecaster_RExporter(new RJSBasecaster_RFileExporterAdapter_RExporter());
            
              // registration of base casters that casts RFileExporterAdapter to RFileExporter:
              RFileExporter_Wrapper::registerBasecaster_RFileExporter(new RJSBasecaster_RFileExporterAdapter_RFileExporter());
            
            // registration of base casters that cast RFileExporterFactory to base classes:
            
            // registration of base casters that cast RFileExporterFactoryAdapter to base classes:
            
              // registration of base casters that casts RFileExporterFactoryAdapter to RFileExporterFactory:
              RFileExporterFactory_Wrapper::registerBasecaster_RFileExporterFactory(new RJSBasecaster_RFileExporterFactoryAdapter_RFileExporterFactory());
            
            // registration of base casters that cast RFileExporterRegistry to base classes:
            
            // registration of base casters that cast RFileImporter to base classes:
            
              // registration of base casters that casts RFileImporter to RImporter:
              RImporter_Wrapper::registerBasecaster_RImporter(new RJSBasecaster_RFileImporter_RImporter());
            
            // registration of base casters that cast RFileImporterAdapter to base classes:
            
              // registration of base casters that casts RFileImporterAdapter to RImporter:
              RImporter_Wrapper::registerBasecaster_RImporter(new RJSBasecaster_RFileImporterAdapter_RImporter());
            
              // registration of base casters that casts RFileImporterAdapter to RFileImporter:
              RFileImporter_Wrapper::registerBasecaster_RFileImporter(new RJSBasecaster_RFileImporterAdapter_RFileImporter());
            
            // registration of base casters that cast RFileImporterFactory to base classes:
            
            // registration of base casters that cast RFileImporterFactoryAdapter to base classes:
            
              // registration of base casters that casts RFileImporterFactoryAdapter to RFileImporterFactory:
              RFileImporterFactory_Wrapper::registerBasecaster_RFileImporterFactory(new RJSBasecaster_RFileImporterFactoryAdapter_RFileImporterFactory());
            
            // registration of base casters that cast RFileImporterRegistry to base classes:
            
            // registration of base casters that cast RFileSystemModel to base classes:
            
              // registration of base casters that casts RFileSystemModel to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RFileSystemModel_QObject());
            
              // registration of base casters that casts RFileSystemModel to QAbstractItemModel:
              QAbstractItemModel_Wrapper::registerBasecaster_QAbstractItemModel(new RJSBasecaster_RFileSystemModel_QAbstractItemModel());
            
              // registration of base casters that casts RFileSystemModel to QFileSystemModel:
              QFileSystemModel_Wrapper::registerBasecaster_QFileSystemModel(new RJSBasecaster_RFileSystemModel_QFileSystemModel());
            
            // registration of base casters that cast RFlowLayout to base classes:
            
              // registration of base casters that casts RFlowLayout to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RFlowLayout_QObject());
            
              // registration of base casters that casts RFlowLayout to QLayoutItem:
              QLayoutItem_Wrapper::registerBasecaster_QLayoutItem(new RJSBasecaster_RFlowLayout_QLayoutItem());
            
              // registration of base casters that casts RFlowLayout to QLayout:
              QLayout_Wrapper::registerBasecaster_QLayout(new RJSBasecaster_RFlowLayout_QLayout());
            
            // registration of base casters that cast RFocusListener to base classes:
            
            // registration of base casters that cast RFocusListenerAdapter to base classes:
            
              // registration of base casters that casts RFocusListenerAdapter to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RFocusListenerAdapter_QObject());
            
              // registration of base casters that casts RFocusListenerAdapter to RFocusListener:
              RFocusListener_Wrapper::registerBasecaster_RFocusListener(new RJSBasecaster_RFocusListenerAdapter_RFocusListener());
            
            // registration of base casters that cast RFont to base classes:
            
            // registration of base casters that cast RFontChooserWidget to base classes:
            
              // registration of base casters that casts RFontChooserWidget to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RFontChooserWidget_QObject());
            
              // registration of base casters that casts RFontChooserWidget to QWidget:
              QWidget_Wrapper::registerBasecaster_QWidget(new RJSBasecaster_RFontChooserWidget_QWidget());
            
            // registration of base casters that cast RFontList to base classes:
            
            // registration of base casters that cast RGraphicsScene to base classes:
            
              // registration of base casters that casts RGraphicsScene to RExporter:
              RExporter_Wrapper::registerBasecaster_RExporter(new RJSBasecaster_RGraphicsScene_RExporter());
            
            // registration of base casters that cast RGraphicsSceneDrawable to base classes:
            
            // registration of base casters that cast RGraphicsSceneQt to base classes:
            
              // registration of base casters that casts RGraphicsSceneQt to RExporter:
              RExporter_Wrapper::registerBasecaster_RExporter(new RJSBasecaster_RGraphicsSceneQt_RExporter());
            
              // registration of base casters that casts RGraphicsSceneQt to RGraphicsScene:
              RGraphicsScene_Wrapper::registerBasecaster_RGraphicsScene(new RJSBasecaster_RGraphicsSceneQt_RGraphicsScene());
            
            // registration of base casters that cast RGraphicsView to base classes:
            
            // registration of base casters that cast RGraphicsViewImage to base classes:
            
              // registration of base casters that casts RGraphicsViewImage to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RGraphicsViewImage_QObject());
            
              // registration of base casters that casts RGraphicsViewImage to RGraphicsView:
              RGraphicsView_Wrapper::registerBasecaster_RGraphicsView(new RJSBasecaster_RGraphicsViewImage_RGraphicsView());
            
            // registration of base casters that cast RGraphicsViewQt to base classes:
            
              // registration of base casters that casts RGraphicsViewQt to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RGraphicsViewQt_QObject());
            
              // registration of base casters that casts RGraphicsViewQt to QWidget:
              QWidget_Wrapper::registerBasecaster_QWidget(new RJSBasecaster_RGraphicsViewQt_QWidget());
            
            // registration of base casters that cast RGrid to base classes:
            
            // registration of base casters that cast RGuiAction to base classes:
            
              // registration of base casters that casts RGuiAction to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RGuiAction_QObject());
            
              // registration of base casters that casts RGuiAction to RFocusListener:
              RFocusListener_Wrapper::registerBasecaster_RFocusListener(new RJSBasecaster_RGuiAction_RFocusListener());
            
              // registration of base casters that casts RGuiAction to RTransactionListener:
              RTransactionListener_Wrapper::registerBasecaster_RTransactionListener(new RJSBasecaster_RGuiAction_RTransactionListener());
            
              // registration of base casters that casts RGuiAction to RSelectionListener:
              RSelectionListener_Wrapper::registerBasecaster_RSelectionListener(new RJSBasecaster_RGuiAction_RSelectionListener());
            
              // registration of base casters that casts RGuiAction to QAction:
              QAction_Wrapper::registerBasecaster_QAction(new RJSBasecaster_RGuiAction_QAction());
            
            // registration of base casters that cast RHatchData to base classes:
            
              // registration of base casters that casts RHatchData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RHatchData_REntityData());
            
            // registration of base casters that cast RHatchEntity to base classes:
            
              // registration of base casters that casts RHatchEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RHatchEntity_RObject());
            
              // registration of base casters that casts RHatchEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RHatchEntity_REntity());
            
            // registration of base casters that cast RImageData to base classes:
            
              // registration of base casters that casts RImageData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RImageData_REntityData());
            
            // registration of base casters that cast RImageEntity to base classes:
            
              // registration of base casters that casts RImageEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RImageEntity_RObject());
            
              // registration of base casters that casts RImageEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RImageEntity_REntity());
            
            // registration of base casters that cast RImportListener to base classes:
            
            // registration of base casters that cast RImporter to base classes:
            
            // registration of base casters that cast RInputEvent to base classes:
            
            // registration of base casters that cast RInterTransactionListener to base classes:
            
            // registration of base casters that cast RInterTransactionListenerAdapter to base classes:
            
              // registration of base casters that casts RInterTransactionListenerAdapter to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RInterTransactionListenerAdapter_QObject());
            
              // registration of base casters that casts RInterTransactionListenerAdapter to RInterTransactionListener:
              RInterTransactionListener_Wrapper::registerBasecaster_RInterTransactionListener(new RJSBasecaster_RInterTransactionListenerAdapter_RInterTransactionListener());
            
            // registration of base casters that cast RKeyListener to base classes:
            
            // registration of base casters that cast RKeyListenerAdapter to base classes:
            
              // registration of base casters that casts RKeyListenerAdapter to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RKeyListenerAdapter_QObject());
            
              // registration of base casters that casts RKeyListenerAdapter to RKeyListener:
              RKeyListener_Wrapper::registerBasecaster_RKeyListener(new RJSBasecaster_RKeyListenerAdapter_RKeyListener());
            
            // registration of base casters that cast RLayer to base classes:
            
              // registration of base casters that casts RLayer to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RLayer_RObject());
            
            // registration of base casters that cast RLayerListener to base classes:
            
            // registration of base casters that cast RLayerListenerAdapter to base classes:
            
              // registration of base casters that casts RLayerListenerAdapter to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RLayerListenerAdapter_QObject());
            
              // registration of base casters that casts RLayerListenerAdapter to RLayerListener:
              RLayerListener_Wrapper::registerBasecaster_RLayerListener(new RJSBasecaster_RLayerListenerAdapter_RLayerListener());
            
            // registration of base casters that cast RLayerState to base classes:
            
              // registration of base casters that casts RLayerState to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RLayerState_RObject());
            
            // registration of base casters that cast RLayout to base classes:
            
              // registration of base casters that casts RLayout to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RLayout_RObject());
            
            // registration of base casters that cast RLeaderData to base classes:
            
              // registration of base casters that casts RLeaderData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RLeaderData_REntityData());
            
              // registration of base casters that casts RLeaderData to RPolyline:
              RPolyline_Wrapper::registerBasecaster_RPolyline(new RJSBasecaster_RLeaderData_RPolyline());
            
            // registration of base casters that cast RLeaderEntity to base classes:
            
              // registration of base casters that casts RLeaderEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RLeaderEntity_RObject());
            
              // registration of base casters that casts RLeaderEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RLeaderEntity_REntity());
            
            // registration of base casters that cast RLine to base classes:
            
              // registration of base casters that casts RLine to RShape:
              RShape_Wrapper::registerBasecaster_RShape(new RJSBasecaster_RLine_RShape());
            
            // registration of base casters that cast RLineData to base classes:
            
              // registration of base casters that casts RLineData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RLineData_REntityData());
            
              // registration of base casters that casts RLineData to RLine:
              RLine_Wrapper::registerBasecaster_RLine(new RJSBasecaster_RLineData_RLine());
            
            // registration of base casters that cast RLineEntity to base classes:
            
              // registration of base casters that casts RLineEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RLineEntity_RObject());
            
              // registration of base casters that casts RLineEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RLineEntity_REntity());
            
            // registration of base casters that cast RLinetype to base classes:
            
              // registration of base casters that casts RLinetype to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RLinetype_RObject());
            
            // registration of base casters that cast RLinetypeCombo to base classes:
            
              // registration of base casters that casts RLinetypeCombo to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RLinetypeCombo_QObject());
            
              // registration of base casters that casts RLinetypeCombo to QWidget:
              QWidget_Wrapper::registerBasecaster_QWidget(new RJSBasecaster_RLinetypeCombo_QWidget());
            
              // registration of base casters that casts RLinetypeCombo to QComboBox:
              QComboBox_Wrapper::registerBasecaster_QComboBox(new RJSBasecaster_RLinetypeCombo_QComboBox());
            
            // registration of base casters that cast RLinetypePattern to base classes:
            
            // registration of base casters that cast RLineweight to base classes:
            
            // registration of base casters that cast RLineweightCombo to base classes:
            
              // registration of base casters that casts RLineweightCombo to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RLineweightCombo_QObject());
            
              // registration of base casters that casts RLineweightCombo to QWidget:
              QWidget_Wrapper::registerBasecaster_QWidget(new RJSBasecaster_RLineweightCombo_QWidget());
            
              // registration of base casters that casts RLineweightCombo to QComboBox:
              QComboBox_Wrapper::registerBasecaster_QComboBox(new RJSBasecaster_RLineweightCombo_QComboBox());
            
            // registration of base casters that cast RListView to base classes:
            
              // registration of base casters that casts RListView to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RListView_QObject());
            
              // registration of base casters that casts RListView to QWidget:
              QWidget_Wrapper::registerBasecaster_QWidget(new RJSBasecaster_RListView_QWidget());
            
              // registration of base casters that casts RListView to QFrame:
              QFrame_Wrapper::registerBasecaster_QFrame(new RJSBasecaster_RListView_QFrame());
            
              // registration of base casters that casts RListView to QAbstractScrollArea:
              QAbstractScrollArea_Wrapper::registerBasecaster_QAbstractScrollArea(new RJSBasecaster_RListView_QAbstractScrollArea());
            
              // registration of base casters that casts RListView to QAbstractItemView:
              QAbstractItemView_Wrapper::registerBasecaster_QAbstractItemView(new RJSBasecaster_RListView_QAbstractItemView());
            
              // registration of base casters that casts RListView to QListView:
              QListView_Wrapper::registerBasecaster_QListView(new RJSBasecaster_RListView_QListView());
            
            // registration of base casters that cast RListWidget to base classes:
            
              // registration of base casters that casts RListWidget to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RListWidget_QObject());
            
              // registration of base casters that casts RListWidget to QWidget:
              QWidget_Wrapper::registerBasecaster_QWidget(new RJSBasecaster_RListWidget_QWidget());
            
              // registration of base casters that casts RListWidget to QFrame:
              QFrame_Wrapper::registerBasecaster_QFrame(new RJSBasecaster_RListWidget_QFrame());
            
              // registration of base casters that casts RListWidget to QAbstractScrollArea:
              QAbstractScrollArea_Wrapper::registerBasecaster_QAbstractScrollArea(new RJSBasecaster_RListWidget_QAbstractScrollArea());
            
              // registration of base casters that casts RListWidget to QAbstractItemView:
              QAbstractItemView_Wrapper::registerBasecaster_QAbstractItemView(new RJSBasecaster_RListWidget_QAbstractItemView());
            
              // registration of base casters that casts RListWidget to QListView:
              QListView_Wrapper::registerBasecaster_QListView(new RJSBasecaster_RListWidget_QListView());
            
              // registration of base casters that casts RListWidget to QListWidget:
              QListWidget_Wrapper::registerBasecaster_QListWidget(new RJSBasecaster_RListWidget_QListWidget());
            
            // registration of base casters that cast RMainWindow to base classes:
            
            // registration of base casters that cast RMainWindowQt to base classes:
            
              // registration of base casters that casts RMainWindowQt to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RMainWindowQt_QObject());
            
              // registration of base casters that casts RMainWindowQt to QWidget:
              QWidget_Wrapper::registerBasecaster_QWidget(new RJSBasecaster_RMainWindowQt_QWidget());
            
              // registration of base casters that casts RMainWindowQt to QMainWindow:
              QMainWindow_Wrapper::registerBasecaster_QMainWindow(new RJSBasecaster_RMainWindowQt_QMainWindow());
            
              // registration of base casters that casts RMainWindowQt to RMainWindow:
              RMainWindow_Wrapper::registerBasecaster_RMainWindow(new RJSBasecaster_RMainWindowQt_RMainWindow());
            
            // registration of base casters that cast RMath to base classes:
            
            // registration of base casters that cast RMathComboBox to base classes:
            
              // registration of base casters that casts RMathComboBox to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RMathComboBox_QObject());
            
              // registration of base casters that casts RMathComboBox to QWidget:
              QWidget_Wrapper::registerBasecaster_QWidget(new RJSBasecaster_RMathComboBox_QWidget());
            
              // registration of base casters that casts RMathComboBox to QComboBox:
              QComboBox_Wrapper::registerBasecaster_QComboBox(new RJSBasecaster_RMathComboBox_QComboBox());
            
            // registration of base casters that cast RMathLineEdit to base classes:
            
              // registration of base casters that casts RMathLineEdit to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RMathLineEdit_QObject());
            
              // registration of base casters that casts RMathLineEdit to QWidget:
              QWidget_Wrapper::registerBasecaster_QWidget(new RJSBasecaster_RMathLineEdit_QWidget());
            
              // registration of base casters that casts RMathLineEdit to QLineEdit:
              QLineEdit_Wrapper::registerBasecaster_QLineEdit(new RJSBasecaster_RMathLineEdit_QLineEdit());
            
            // registration of base casters that cast RMatrix to base classes:
            
            // registration of base casters that cast RMdiArea to base classes:
            
              // registration of base casters that casts RMdiArea to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RMdiArea_QObject());
            
              // registration of base casters that casts RMdiArea to QWidget:
              QWidget_Wrapper::registerBasecaster_QWidget(new RJSBasecaster_RMdiArea_QWidget());
            
              // registration of base casters that casts RMdiArea to QMdiArea:
              QMdiArea_Wrapper::registerBasecaster_QMdiArea(new RJSBasecaster_RMdiArea_QMdiArea());
            
            // registration of base casters that cast RMdiChildQt to base classes:
            
              // registration of base casters that casts RMdiChildQt to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RMdiChildQt_QObject());
            
              // registration of base casters that casts RMdiChildQt to QWidget:
              QWidget_Wrapper::registerBasecaster_QWidget(new RJSBasecaster_RMdiChildQt_QWidget());
            
              // registration of base casters that casts RMdiChildQt to RModifiedListener:
              RModifiedListener_Wrapper::registerBasecaster_RModifiedListener(new RJSBasecaster_RMdiChildQt_RModifiedListener());
            
              // registration of base casters that casts RMdiChildQt to QMdiSubWindow:
              QMdiSubWindow_Wrapper::registerBasecaster_QMdiSubWindow(new RJSBasecaster_RMdiChildQt_QMdiSubWindow());
            
            // registration of base casters that cast RMemoryStorage to base classes:
            
              // registration of base casters that casts RMemoryStorage to RStorage:
              RStorage_Wrapper::registerBasecaster_RStorage(new RJSBasecaster_RMemoryStorage_RStorage());
            
            // registration of base casters that cast RMessageHandler to base classes:
            
            // registration of base casters that cast RMixedOperation to base classes:
            
              // registration of base casters that casts RMixedOperation to ROperation:
              ROperation_Wrapper::registerBasecaster_ROperation(new RJSBasecaster_RMixedOperation_ROperation());
            
            // registration of base casters that cast RModifiedListener to base classes:
            
            // registration of base casters that cast RModifyObjectOperation to base classes:
            
              // registration of base casters that casts RModifyObjectOperation to ROperation:
              ROperation_Wrapper::registerBasecaster_ROperation(new RJSBasecaster_RModifyObjectOperation_ROperation());
            
              // registration of base casters that casts RModifyObjectOperation to RAddObjectOperation:
              RAddObjectOperation_Wrapper::registerBasecaster_RAddObjectOperation(new RJSBasecaster_RModifyObjectOperation_RAddObjectOperation());
            
            // registration of base casters that cast RModifyObjectsOperation to base classes:
            
              // registration of base casters that casts RModifyObjectsOperation to ROperation:
              ROperation_Wrapper::registerBasecaster_ROperation(new RJSBasecaster_RModifyObjectsOperation_ROperation());
            
              // registration of base casters that casts RModifyObjectsOperation to RAddObjectsOperation:
              RAddObjectsOperation_Wrapper::registerBasecaster_RAddObjectsOperation(new RJSBasecaster_RModifyObjectsOperation_RAddObjectsOperation());
            
            // registration of base casters that cast RMouseCoordinateListener to base classes:
            
            // registration of base casters that cast RMouseEvent to base classes:
            
              // registration of base casters that casts RMouseEvent to QEvent:
              QEvent_Wrapper::registerBasecaster_QEvent(new RJSBasecaster_RMouseEvent_QEvent());
            
              // registration of base casters that casts RMouseEvent to QInputEvent:
              QInputEvent_Wrapper::registerBasecaster_QInputEvent(new RJSBasecaster_RMouseEvent_QInputEvent());
            
              // registration of base casters that casts RMouseEvent to QPointerEvent:
              QPointerEvent_Wrapper::registerBasecaster_QPointerEvent(new RJSBasecaster_RMouseEvent_QPointerEvent());
            
              // registration of base casters that casts RMouseEvent to QSinglePointEvent:
              QSinglePointEvent_Wrapper::registerBasecaster_QSinglePointEvent(new RJSBasecaster_RMouseEvent_QSinglePointEvent());
            
              // registration of base casters that casts RMouseEvent to QMouseEvent:
              QMouseEvent_Wrapper::registerBasecaster_QMouseEvent(new RJSBasecaster_RMouseEvent_QMouseEvent());
            
              // registration of base casters that casts RMouseEvent to RInputEvent:
              RInputEvent_Wrapper::registerBasecaster_RInputEvent(new RJSBasecaster_RMouseEvent_RInputEvent());
            
            // registration of base casters that cast RMoveReferencePointOperation to base classes:
            
              // registration of base casters that casts RMoveReferencePointOperation to ROperation:
              ROperation_Wrapper::registerBasecaster_ROperation(new RJSBasecaster_RMoveReferencePointOperation_ROperation());
            
            // registration of base casters that cast RMoveSelectionOperation to base classes:
            
              // registration of base casters that casts RMoveSelectionOperation to ROperation:
              ROperation_Wrapper::registerBasecaster_ROperation(new RJSBasecaster_RMoveSelectionOperation_ROperation());
            
            // registration of base casters that cast RNewDocumentListener to base classes:
            
            // registration of base casters that cast RObject to base classes:
            
            // registration of base casters that cast ROperation to base classes:
            
            // registration of base casters that cast ROperationUtils to base classes:
            
            // registration of base casters that cast ROrthoGrid to base classes:
            
              // registration of base casters that casts ROrthoGrid to RGrid:
              RGrid_Wrapper::registerBasecaster_RGrid(new RJSBasecaster_ROrthoGrid_RGrid());
            
            // registration of base casters that cast RPainterPath to base classes:
            
              // registration of base casters that casts RPainterPath to QPainterPath:
              QPainterPath_Wrapper::registerBasecaster_QPainterPath(new RJSBasecaster_RPainterPath_QPainterPath());
            
            // registration of base casters that cast RPainterPathSource to base classes:
            
            // registration of base casters that cast RPaletteListener to base classes:
            
            // registration of base casters that cast RPaletteListenerAdapter to base classes:
            
              // registration of base casters that casts RPaletteListenerAdapter to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RPaletteListenerAdapter_QObject());
            
              // registration of base casters that casts RPaletteListenerAdapter to RPaletteListener:
              RPaletteListener_Wrapper::registerBasecaster_RPaletteListener(new RJSBasecaster_RPaletteListenerAdapter_RPaletteListener());
            
            // registration of base casters that cast RPasteOperation to base classes:
            
              // registration of base casters that casts RPasteOperation to ROperation:
              ROperation_Wrapper::registerBasecaster_ROperation(new RJSBasecaster_RPasteOperation_ROperation());
            
              // registration of base casters that casts RPasteOperation to RClipboardOperation:
              RClipboardOperation_Wrapper::registerBasecaster_RClipboardOperation(new RJSBasecaster_RPasteOperation_RClipboardOperation());
            
            // registration of base casters that cast RPattern to base classes:
            
            // registration of base casters that cast RPatternLine to base classes:
            
            // registration of base casters that cast RPatternList to base classes:
            
            // registration of base casters that cast RPatternListImperial to base classes:
            
              // registration of base casters that casts RPatternListImperial to RPatternList:
              RPatternList_Wrapper::registerBasecaster_RPatternList(new RJSBasecaster_RPatternListImperial_RPatternList());
            
            // registration of base casters that cast RPatternListMetric to base classes:
            
              // registration of base casters that casts RPatternListMetric to RPatternList:
              RPatternList_Wrapper::registerBasecaster_RPatternList(new RJSBasecaster_RPatternListMetric_RPatternList());
            
            // registration of base casters that cast RPenListener to base classes:
            
            // registration of base casters that cast RPenListenerAdapter to base classes:
            
              // registration of base casters that casts RPenListenerAdapter to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RPenListenerAdapter_QObject());
            
              // registration of base casters that casts RPenListenerAdapter to RPenListener:
              RPenListener_Wrapper::registerBasecaster_RPenListener(new RJSBasecaster_RPenListenerAdapter_RPenListener());
            
            // registration of base casters that cast RPluginInfo to base classes:
            
            // registration of base casters that cast RPluginInterface to base classes:
            
            // registration of base casters that cast RPluginLoader to base classes:
            
            // registration of base casters that cast RPoint to base classes:
            
              // registration of base casters that casts RPoint to RShape:
              RShape_Wrapper::registerBasecaster_RShape(new RJSBasecaster_RPoint_RShape());
            
            // registration of base casters that cast RPointData to base classes:
            
              // registration of base casters that casts RPointData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RPointData_REntityData());
            
              // registration of base casters that casts RPointData to RPoint:
              RPoint_Wrapper::registerBasecaster_RPoint(new RJSBasecaster_RPointData_RPoint());
            
            // registration of base casters that cast RPointEntity to base classes:
            
              // registration of base casters that casts RPointEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RPointEntity_RObject());
            
              // registration of base casters that casts RPointEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RPointEntity_REntity());
            
            // registration of base casters that cast RPolyline to base classes:
            
              // registration of base casters that casts RPolyline to RShape:
              RShape_Wrapper::registerBasecaster_RShape(new RJSBasecaster_RPolyline_RShape());
            
              // registration of base casters that casts RPolyline to RExplodable:
              RExplodable_Wrapper::registerBasecaster_RExplodable(new RJSBasecaster_RPolyline_RExplodable());
            
            // registration of base casters that cast RPolylineData to base classes:
            
              // registration of base casters that casts RPolylineData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RPolylineData_REntityData());
            
              // registration of base casters that casts RPolylineData to RPolyline:
              RPolyline_Wrapper::registerBasecaster_RPolyline(new RJSBasecaster_RPolylineData_RPolyline());
            
            // registration of base casters that cast RPolylineEntity to base classes:
            
              // registration of base casters that casts RPolylineEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RPolylineEntity_RObject());
            
              // registration of base casters that casts RPolylineEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RPolylineEntity_REntity());
            
            // registration of base casters that cast RPreferencesListener to base classes:
            
            // registration of base casters that cast RPreferencesListenerAdapter to base classes:
            
              // registration of base casters that casts RPreferencesListenerAdapter to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RPreferencesListenerAdapter_QObject());
            
              // registration of base casters that casts RPreferencesListenerAdapter to RPreferencesListener:
              RPreferencesListener_Wrapper::registerBasecaster_RPreferencesListener(new RJSBasecaster_RPreferencesListenerAdapter_RPreferencesListener());
            
            // registration of base casters that cast RProgressHandler to base classes:
            
            // registration of base casters that cast RPropertyAttributes to base classes:
            
            // registration of base casters that cast RPropertyChange to base classes:
            
            // registration of base casters that cast RPropertyEditor to base classes:
            
              // registration of base casters that casts RPropertyEditor to RPropertyListener:
              RPropertyListener_Wrapper::registerBasecaster_RPropertyListener(new RJSBasecaster_RPropertyEditor_RPropertyListener());
            
              // registration of base casters that casts RPropertyEditor to RLayerListener:
              RLayerListener_Wrapper::registerBasecaster_RLayerListener(new RJSBasecaster_RPropertyEditor_RLayerListener());
            
            // registration of base casters that cast RPropertyEvent to base classes:
            
              // registration of base casters that casts RPropertyEvent to QEvent:
              QEvent_Wrapper::registerBasecaster_QEvent(new RJSBasecaster_RPropertyEvent_QEvent());
            
            // registration of base casters that cast RPropertyListener to base classes:
            
            // registration of base casters that cast RPropertyListenerAdapter to base classes:
            
              // registration of base casters that casts RPropertyListenerAdapter to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RPropertyListenerAdapter_QObject());
            
              // registration of base casters that casts RPropertyListenerAdapter to RPropertyListener:
              RPropertyListener_Wrapper::registerBasecaster_RPropertyListener(new RJSBasecaster_RPropertyListenerAdapter_RPropertyListener());
            
            // registration of base casters that cast RPropertyTypeId to base classes:
            
            // registration of base casters that cast RRay to base classes:
            
              // registration of base casters that casts RRay to RShape:
              RShape_Wrapper::registerBasecaster_RShape(new RJSBasecaster_RRay_RShape());
            
              // registration of base casters that casts RRay to RXLine:
              RXLine_Wrapper::registerBasecaster_RXLine(new RJSBasecaster_RRay_RXLine());
            
            // registration of base casters that cast RRayData to base classes:
            
              // registration of base casters that casts RRayData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RRayData_REntityData());
            
              // registration of base casters that casts RRayData to RRay:
              RRay_Wrapper::registerBasecaster_RRay(new RJSBasecaster_RRayData_RRay());
            
            // registration of base casters that cast RRayEntity to base classes:
            
              // registration of base casters that casts RRayEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RRayEntity_RObject());
            
              // registration of base casters that casts RRayEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RRayEntity_REntity());
            
            // registration of base casters that cast RRefPoint to base classes:
            
              // registration of base casters that casts RRefPoint to RVector:
              RVector_Wrapper::registerBasecaster_RVector(new RJSBasecaster_RRefPoint_RVector());
            
            // registration of base casters that cast RRestrictAngleLength to base classes:
            
              // registration of base casters that casts RRestrictAngleLength to RSnapRestriction:
              RSnapRestriction_Wrapper::registerBasecaster_RSnapRestriction(new RJSBasecaster_RRestrictAngleLength_RSnapRestriction());
            
            // registration of base casters that cast RRestrictHorizontal to base classes:
            
              // registration of base casters that casts RRestrictHorizontal to RSnapRestriction:
              RSnapRestriction_Wrapper::registerBasecaster_RSnapRestriction(new RJSBasecaster_RRestrictHorizontal_RSnapRestriction());
            
              // registration of base casters that casts RRestrictHorizontal to RRestrictOrthogonal:
              RRestrictOrthogonal_Wrapper::registerBasecaster_RRestrictOrthogonal(new RJSBasecaster_RRestrictHorizontal_RRestrictOrthogonal());
            
            // registration of base casters that cast RRestrictOff to base classes:
            
              // registration of base casters that casts RRestrictOff to RSnapRestriction:
              RSnapRestriction_Wrapper::registerBasecaster_RSnapRestriction(new RJSBasecaster_RRestrictOff_RSnapRestriction());
            
            // registration of base casters that cast RRestrictOrthogonal to base classes:
            
              // registration of base casters that casts RRestrictOrthogonal to RSnapRestriction:
              RSnapRestriction_Wrapper::registerBasecaster_RSnapRestriction(new RJSBasecaster_RRestrictOrthogonal_RSnapRestriction());
            
            // registration of base casters that cast RRestrictVertical to base classes:
            
              // registration of base casters that casts RRestrictVertical to RSnapRestriction:
              RSnapRestriction_Wrapper::registerBasecaster_RSnapRestriction(new RJSBasecaster_RRestrictVertical_RSnapRestriction());
            
              // registration of base casters that casts RRestrictVertical to RRestrictOrthogonal:
              RRestrictOrthogonal_Wrapper::registerBasecaster_RRestrictOrthogonal(new RJSBasecaster_RRestrictVertical_RRestrictOrthogonal());
            
            // registration of base casters that cast RRuler to base classes:
            
            // registration of base casters that cast RRulerQt to base classes:
            
              // registration of base casters that casts RRulerQt to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RRulerQt_QObject());
            
              // registration of base casters that casts RRulerQt to QWidget:
              QWidget_Wrapper::registerBasecaster_QWidget(new RJSBasecaster_RRulerQt_QWidget());
            
              // registration of base casters that casts RRulerQt to QFrame:
              QFrame_Wrapper::registerBasecaster_QFrame(new RJSBasecaster_RRulerQt_QFrame());
            
              // registration of base casters that casts RRulerQt to RRuler:
              RRuler_Wrapper::registerBasecaster_RRuler(new RJSBasecaster_RRulerQt_RRuler());
            
              // registration of base casters that casts RRulerQt to RCoordinateListener:
              RCoordinateListener_Wrapper::registerBasecaster_RCoordinateListener(new RJSBasecaster_RRulerQt_RCoordinateListener());
            
              // registration of base casters that casts RRulerQt to RPaletteListener:
              RPaletteListener_Wrapper::registerBasecaster_RPaletteListener(new RJSBasecaster_RRulerQt_RPaletteListener());
            
            // registration of base casters that cast RS to base classes:
            
            // registration of base casters that cast RScaleSelectionOperation to base classes:
            
              // registration of base casters that casts RScaleSelectionOperation to ROperation:
              ROperation_Wrapper::registerBasecaster_ROperation(new RJSBasecaster_RScaleSelectionOperation_ROperation());
            
            // registration of base casters that cast RSelectionListener to base classes:
            
            // registration of base casters that cast RSelectionListenerAdapter to base classes:
            
              // registration of base casters that casts RSelectionListenerAdapter to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RSelectionListenerAdapter_QObject());
            
              // registration of base casters that casts RSelectionListenerAdapter to RSelectionListener:
              RSelectionListener_Wrapper::registerBasecaster_RSelectionListener(new RJSBasecaster_RSelectionListenerAdapter_RSelectionListener());
            
            // registration of base casters that cast RSettings to base classes:
            
            // registration of base casters that cast RShape to base classes:
            
            // registration of base casters that cast RSingleApplication to base classes:
            
              // registration of base casters that casts RSingleApplication to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RSingleApplication_QObject());
            
              // registration of base casters that casts RSingleApplication to QCoreApplication:
              QCoreApplication_Wrapper::registerBasecaster_QCoreApplication(new RJSBasecaster_RSingleApplication_QCoreApplication());
            
              // registration of base casters that casts RSingleApplication to QGuiApplication:
              QGuiApplication_Wrapper::registerBasecaster_QGuiApplication(new RJSBasecaster_RSingleApplication_QGuiApplication());
            
              // registration of base casters that casts RSingleApplication to QApplication:
              QApplication_Wrapper::registerBasecaster_QApplication(new RJSBasecaster_RSingleApplication_QApplication());
            
            // registration of base casters that cast RSnap to base classes:
            
            // registration of base casters that cast RSnapAuto to base classes:
            
              // registration of base casters that casts RSnapAuto to RSnap:
              RSnap_Wrapper::registerBasecaster_RSnap(new RJSBasecaster_RSnapAuto_RSnap());
            
            // registration of base casters that cast RSnapCenter to base classes:
            
              // registration of base casters that casts RSnapCenter to RSnap:
              RSnap_Wrapper::registerBasecaster_RSnap(new RJSBasecaster_RSnapCenter_RSnap());
            
              // registration of base casters that casts RSnapCenter to RSnapEntityBase:
              RSnapEntityBase_Wrapper::registerBasecaster_RSnapEntityBase(new RJSBasecaster_RSnapCenter_RSnapEntityBase());
            
            // registration of base casters that cast RSnapDistance to base classes:
            
              // registration of base casters that casts RSnapDistance to RSnap:
              RSnap_Wrapper::registerBasecaster_RSnap(new RJSBasecaster_RSnapDistance_RSnap());
            
              // registration of base casters that casts RSnapDistance to RSnapEntityBase:
              RSnapEntityBase_Wrapper::registerBasecaster_RSnapEntityBase(new RJSBasecaster_RSnapDistance_RSnapEntityBase());
            
            // registration of base casters that cast RSnapEnd to base classes:
            
              // registration of base casters that casts RSnapEnd to RSnap:
              RSnap_Wrapper::registerBasecaster_RSnap(new RJSBasecaster_RSnapEnd_RSnap());
            
              // registration of base casters that casts RSnapEnd to RSnapEntityBase:
              RSnapEntityBase_Wrapper::registerBasecaster_RSnapEntityBase(new RJSBasecaster_RSnapEnd_RSnapEntityBase());
            
            // registration of base casters that cast RSnapEntityBase to base classes:
            
              // registration of base casters that casts RSnapEntityBase to RSnap:
              RSnap_Wrapper::registerBasecaster_RSnap(new RJSBasecaster_RSnapEntityBase_RSnap());
            
            // registration of base casters that cast RSnapFree to base classes:
            
              // registration of base casters that casts RSnapFree to RSnap:
              RSnap_Wrapper::registerBasecaster_RSnap(new RJSBasecaster_RSnapFree_RSnap());
            
            // registration of base casters that cast RSnapGrid to base classes:
            
              // registration of base casters that casts RSnapGrid to RSnap:
              RSnap_Wrapper::registerBasecaster_RSnap(new RJSBasecaster_RSnapGrid_RSnap());
            
            // registration of base casters that cast RSnapIntersection to base classes:
            
              // registration of base casters that casts RSnapIntersection to RSnap:
              RSnap_Wrapper::registerBasecaster_RSnap(new RJSBasecaster_RSnapIntersection_RSnap());
            
            // registration of base casters that cast RSnapListener to base classes:
            
            // registration of base casters that cast RSnapMiddle to base classes:
            
              // registration of base casters that casts RSnapMiddle to RSnap:
              RSnap_Wrapper::registerBasecaster_RSnap(new RJSBasecaster_RSnapMiddle_RSnap());
            
              // registration of base casters that casts RSnapMiddle to RSnapEntityBase:
              RSnapEntityBase_Wrapper::registerBasecaster_RSnapEntityBase(new RJSBasecaster_RSnapMiddle_RSnapEntityBase());
            
            // registration of base casters that cast RSnapOnEntity to base classes:
            
              // registration of base casters that casts RSnapOnEntity to RSnap:
              RSnap_Wrapper::registerBasecaster_RSnap(new RJSBasecaster_RSnapOnEntity_RSnap());
            
              // registration of base casters that casts RSnapOnEntity to RSnapEntityBase:
              RSnapEntityBase_Wrapper::registerBasecaster_RSnapEntityBase(new RJSBasecaster_RSnapOnEntity_RSnapEntityBase());
            
            // registration of base casters that cast RSnapPerpendicular to base classes:
            
              // registration of base casters that casts RSnapPerpendicular to RSnap:
              RSnap_Wrapper::registerBasecaster_RSnap(new RJSBasecaster_RSnapPerpendicular_RSnap());
            
              // registration of base casters that casts RSnapPerpendicular to RSnapEntityBase:
              RSnapEntityBase_Wrapper::registerBasecaster_RSnapEntityBase(new RJSBasecaster_RSnapPerpendicular_RSnapEntityBase());
            
            // registration of base casters that cast RSnapReference to base classes:
            
              // registration of base casters that casts RSnapReference to RSnap:
              RSnap_Wrapper::registerBasecaster_RSnap(new RJSBasecaster_RSnapReference_RSnap());
            
              // registration of base casters that casts RSnapReference to RSnapEntityBase:
              RSnapEntityBase_Wrapper::registerBasecaster_RSnapEntityBase(new RJSBasecaster_RSnapReference_RSnapEntityBase());
            
            // registration of base casters that cast RSnapRestriction to base classes:
            
            // registration of base casters that cast RSnapTangential to base classes:
            
              // registration of base casters that casts RSnapTangential to RSnap:
              RSnap_Wrapper::registerBasecaster_RSnap(new RJSBasecaster_RSnapTangential_RSnap());
            
              // registration of base casters that casts RSnapTangential to RSnapEntityBase:
              RSnapEntityBase_Wrapper::registerBasecaster_RSnapEntityBase(new RJSBasecaster_RSnapTangential_RSnapEntityBase());
            
            // registration of base casters that cast RSolidData to base classes:
            
              // registration of base casters that casts RSolidData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RSolidData_REntityData());
            
              // registration of base casters that casts RSolidData to RPolyline:
              RPolyline_Wrapper::registerBasecaster_RPolyline(new RJSBasecaster_RSolidData_RPolyline());
            
            // registration of base casters that cast RSolidEntity to base classes:
            
              // registration of base casters that casts RSolidEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RSolidEntity_RObject());
            
              // registration of base casters that casts RSolidEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RSolidEntity_REntity());
            
            // registration of base casters that cast RSpatialIndex to base classes:
            
            // registration of base casters that cast RSpatialIndexNavel to base classes:
            
              // registration of base casters that casts RSpatialIndexNavel to RSpatialIndex:
              RSpatialIndex_Wrapper::registerBasecaster_RSpatialIndex(new RJSBasecaster_RSpatialIndexNavel_RSpatialIndex());
            
            // registration of base casters that cast RSpatialIndexSimple to base classes:
            
              // registration of base casters that casts RSpatialIndexSimple to RSpatialIndex:
              RSpatialIndex_Wrapper::registerBasecaster_RSpatialIndex(new RJSBasecaster_RSpatialIndexSimple_RSpatialIndex());
            
            // registration of base casters that cast RSpatialIndexVisitor to base classes:
            
            // registration of base casters that cast RSpatialIndexVisitorAdapter to base classes:
            
              // registration of base casters that casts RSpatialIndexVisitorAdapter to RSpatialIndexVisitor:
              RSpatialIndexVisitor_Wrapper::registerBasecaster_RSpatialIndexVisitor(new RJSBasecaster_RSpatialIndexVisitorAdapter_RSpatialIndexVisitor());
            
            // registration of base casters that cast RSpline to base classes:
            
              // registration of base casters that casts RSpline to RShape:
              RShape_Wrapper::registerBasecaster_RShape(new RJSBasecaster_RSpline_RShape());
            
              // registration of base casters that casts RSpline to RExplodable:
              RExplodable_Wrapper::registerBasecaster_RExplodable(new RJSBasecaster_RSpline_RExplodable());
            
            // registration of base casters that cast RSplineData to base classes:
            
              // registration of base casters that casts RSplineData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RSplineData_REntityData());
            
              // registration of base casters that casts RSplineData to RSpline:
              RSpline_Wrapper::registerBasecaster_RSpline(new RJSBasecaster_RSplineData_RSpline());
            
            // registration of base casters that cast RSplineEntity to base classes:
            
              // registration of base casters that casts RSplineEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RSplineEntity_RObject());
            
              // registration of base casters that casts RSplineEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RSplineEntity_REntity());
            
            // registration of base casters that cast RStorage to base classes:
            
            // registration of base casters that cast RTabletEvent to base classes:
            
            // registration of base casters that cast RTerminateEvent to base classes:
            
              // registration of base casters that casts RTerminateEvent to QEvent:
              QEvent_Wrapper::registerBasecaster_QEvent(new RJSBasecaster_RTerminateEvent_QEvent());
            
            // registration of base casters that cast RTextBasedData to base classes:
            
              // registration of base casters that casts RTextBasedData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RTextBasedData_REntityData());
            
              // registration of base casters that casts RTextBasedData to RPainterPathSource:
              RPainterPathSource_Wrapper::registerBasecaster_RPainterPathSource(new RJSBasecaster_RTextBasedData_RPainterPathSource());
            
            // registration of base casters that cast RTextBasedEntity to base classes:
            
              // registration of base casters that casts RTextBasedEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RTextBasedEntity_RObject());
            
              // registration of base casters that casts RTextBasedEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RTextBasedEntity_REntity());
            
            // registration of base casters that cast RTextData to base classes:
            
              // registration of base casters that casts RTextData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RTextData_REntityData());
            
              // registration of base casters that casts RTextData to RTextBasedData:
              RTextBasedData_Wrapper::registerBasecaster_RTextBasedData(new RJSBasecaster_RTextData_RTextBasedData());
            
            // registration of base casters that cast RTextEdit to base classes:
            
              // registration of base casters that casts RTextEdit to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RTextEdit_QObject());
            
              // registration of base casters that casts RTextEdit to QWidget:
              QWidget_Wrapper::registerBasecaster_QWidget(new RJSBasecaster_RTextEdit_QWidget());
            
              // registration of base casters that casts RTextEdit to QFrame:
              QFrame_Wrapper::registerBasecaster_QFrame(new RJSBasecaster_RTextEdit_QFrame());
            
              // registration of base casters that casts RTextEdit to QAbstractScrollArea:
              QAbstractScrollArea_Wrapper::registerBasecaster_QAbstractScrollArea(new RJSBasecaster_RTextEdit_QAbstractScrollArea());
            
              // registration of base casters that casts RTextEdit to QTextEdit:
              QTextEdit_Wrapper::registerBasecaster_QTextEdit(new RJSBasecaster_RTextEdit_QTextEdit());
            
              // registration of base casters that casts RTextEdit to QTextBrowser:
              QTextBrowser_Wrapper::registerBasecaster_QTextBrowser(new RJSBasecaster_RTextEdit_QTextBrowser());
            
            // registration of base casters that cast RTextEntity to base classes:
            
              // registration of base casters that casts RTextEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RTextEntity_RObject());
            
              // registration of base casters that casts RTextEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RTextEntity_REntity());
            
              // registration of base casters that casts RTextEntity to RTextBasedEntity:
              RTextBasedEntity_Wrapper::registerBasecaster_RTextBasedEntity(new RJSBasecaster_RTextEntity_RTextBasedEntity());
            
            // registration of base casters that cast RTextLabel to base classes:
            
              // registration of base casters that casts RTextLabel to RPoint:
              RPoint_Wrapper::registerBasecaster_RPoint(new RJSBasecaster_RTextLabel_RPoint());
            
            // registration of base casters that cast RTextLayout to base classes:
            
            // registration of base casters that cast RTextRenderer to base classes:
            
            // registration of base casters that cast RToleranceData to base classes:
            
              // registration of base casters that casts RToleranceData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RToleranceData_REntityData());
            
            // registration of base casters that cast RToleranceEntity to base classes:
            
              // registration of base casters that casts RToleranceEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RToleranceEntity_RObject());
            
              // registration of base casters that casts RToleranceEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RToleranceEntity_REntity());
            
            // registration of base casters that cast RToolButton to base classes:
            
              // registration of base casters that casts RToolButton to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RToolButton_QObject());
            
              // registration of base casters that casts RToolButton to QWidget:
              QWidget_Wrapper::registerBasecaster_QWidget(new RJSBasecaster_RToolButton_QWidget());
            
              // registration of base casters that casts RToolButton to QToolButton:
              QToolButton_Wrapper::registerBasecaster_QToolButton(new RJSBasecaster_RToolButton_QToolButton());
            
            // registration of base casters that cast RToolMatrixItemDelegate to base classes:
            
              // registration of base casters that casts RToolMatrixItemDelegate to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RToolMatrixItemDelegate_QObject());
            
              // registration of base casters that casts RToolMatrixItemDelegate to QAbstractItemDelegate:
              QAbstractItemDelegate_Wrapper::registerBasecaster_QAbstractItemDelegate(new RJSBasecaster_RToolMatrixItemDelegate_QAbstractItemDelegate());
            
              // registration of base casters that casts RToolMatrixItemDelegate to QItemDelegate:
              QItemDelegate_Wrapper::registerBasecaster_QItemDelegate(new RJSBasecaster_RToolMatrixItemDelegate_QItemDelegate());
            
            // registration of base casters that cast RTraceData to base classes:
            
              // registration of base casters that casts RTraceData to RSolidData:
              RSolidData_Wrapper::registerBasecaster_RSolidData(new RJSBasecaster_RTraceData_RSolidData());
            
            // registration of base casters that cast RTraceEntity to base classes:
            
              // registration of base casters that casts RTraceEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RTraceEntity_RObject());
            
              // registration of base casters that casts RTraceEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RTraceEntity_REntity());
            
            // registration of base casters that cast RTransaction to base classes:
            
            // registration of base casters that cast RTransactionListener to base classes:
            
            // registration of base casters that cast RTransactionListenerAdapter to base classes:
            
              // registration of base casters that casts RTransactionListenerAdapter to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RTransactionListenerAdapter_QObject());
            
              // registration of base casters that casts RTransactionListenerAdapter to RTransactionListener:
              RTransactionListener_Wrapper::registerBasecaster_RTransactionListener(new RJSBasecaster_RTransactionListenerAdapter_RTransactionListener());
            
            // registration of base casters that cast RTransactionStack to base classes:
            
            // registration of base casters that cast RTransform to base classes:
            
              // registration of base casters that casts RTransform to QTransform:
              QTransform_Wrapper::registerBasecaster_QTransform(new RJSBasecaster_RTransform_QTransform());
            
            // registration of base casters that cast RTransformOp to base classes:
            
            // registration of base casters that cast RTransformation to base classes:
            
            // registration of base casters that cast RTranslation to base classes:
            
              // registration of base casters that casts RTranslation to RTransformation:
              RTransformation_Wrapper::registerBasecaster_RTransformation(new RJSBasecaster_RTranslation_RTransformation());
            
            // registration of base casters that cast RTreeWidget to base classes:
            
              // registration of base casters that casts RTreeWidget to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RTreeWidget_QObject());
            
              // registration of base casters that casts RTreeWidget to QPaintDevice:
              QPaintDevice_Wrapper::registerBasecaster_QPaintDevice(new RJSBasecaster_RTreeWidget_QPaintDevice());
            
              // registration of base casters that casts RTreeWidget to QWidget:
              QWidget_Wrapper::registerBasecaster_QWidget(new RJSBasecaster_RTreeWidget_QWidget());
            
              // registration of base casters that casts RTreeWidget to QFrame:
              QFrame_Wrapper::registerBasecaster_QFrame(new RJSBasecaster_RTreeWidget_QFrame());
            
              // registration of base casters that casts RTreeWidget to QAbstractScrollArea:
              QAbstractScrollArea_Wrapper::registerBasecaster_QAbstractScrollArea(new RJSBasecaster_RTreeWidget_QAbstractScrollArea());
            
              // registration of base casters that casts RTreeWidget to QAbstractItemView:
              QAbstractItemView_Wrapper::registerBasecaster_QAbstractItemView(new RJSBasecaster_RTreeWidget_QAbstractItemView());
            
              // registration of base casters that casts RTreeWidget to QTreeView:
              QTreeView_Wrapper::registerBasecaster_QTreeView(new RJSBasecaster_RTreeWidget_QTreeView());
            
              // registration of base casters that casts RTreeWidget to QTreeWidget:
              QTreeWidget_Wrapper::registerBasecaster_QTreeWidget(new RJSBasecaster_RTreeWidget_QTreeWidget());
            
            // registration of base casters that cast RTriangle to base classes:
            
              // registration of base casters that casts RTriangle to RShape:
              RShape_Wrapper::registerBasecaster_RShape(new RJSBasecaster_RTriangle_RShape());
            
              // registration of base casters that casts RTriangle to RExplodable:
              RExplodable_Wrapper::registerBasecaster_RExplodable(new RJSBasecaster_RTriangle_RExplodable());
            
            // registration of base casters that cast RUcs to base classes:
            
              // registration of base casters that casts RUcs to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RUcs_RObject());
            
            // registration of base casters that cast RUcsListener to base classes:
            
            // registration of base casters that cast RUnit to base classes:
            
            // registration of base casters that cast RVector to base classes:
            
            // registration of base casters that cast RView to base classes:
            
              // registration of base casters that casts RView to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RView_RObject());
            
            // registration of base casters that cast RViewFocusListener to base classes:
            
            // registration of base casters that cast RViewFocusListenerAdapter to base classes:
            
              // registration of base casters that casts RViewFocusListenerAdapter to RViewFocusListener:
              RViewFocusListener_Wrapper::registerBasecaster_RViewFocusListener(new RJSBasecaster_RViewFocusListenerAdapter_RViewFocusListener());
            
            // registration of base casters that cast RViewListener to base classes:
            
            // registration of base casters that cast RViewListenerAdapter to base classes:
            
              // registration of base casters that casts RViewListenerAdapter to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RViewListenerAdapter_QObject());
            
              // registration of base casters that casts RViewListenerAdapter to RViewListener:
              RViewListener_Wrapper::registerBasecaster_RViewListener(new RJSBasecaster_RViewListenerAdapter_RViewListener());
            
            // registration of base casters that cast RViewportData to base classes:
            
              // registration of base casters that casts RViewportData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RViewportData_REntityData());
            
              // registration of base casters that casts RViewportData to RPoint:
              RPoint_Wrapper::registerBasecaster_RPoint(new RJSBasecaster_RViewportData_RPoint());
            
            // registration of base casters that cast RViewportEntity to base classes:
            
              // registration of base casters that casts RViewportEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RViewportEntity_RObject());
            
              // registration of base casters that casts RViewportEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RViewportEntity_REntity());
            
            // registration of base casters that cast RWheelEvent to base classes:
            
              // registration of base casters that casts RWheelEvent to QEvent:
              QEvent_Wrapper::registerBasecaster_QEvent(new RJSBasecaster_RWheelEvent_QEvent());
            
              // registration of base casters that casts RWheelEvent to QInputEvent:
              QInputEvent_Wrapper::registerBasecaster_QInputEvent(new RJSBasecaster_RWheelEvent_QInputEvent());
            
              // registration of base casters that casts RWheelEvent to QPointerEvent:
              QPointerEvent_Wrapper::registerBasecaster_QPointerEvent(new RJSBasecaster_RWheelEvent_QPointerEvent());
            
              // registration of base casters that casts RWheelEvent to QSinglePointEvent:
              QSinglePointEvent_Wrapper::registerBasecaster_QSinglePointEvent(new RJSBasecaster_RWheelEvent_QSinglePointEvent());
            
              // registration of base casters that casts RWheelEvent to QWheelEvent:
              QWheelEvent_Wrapper::registerBasecaster_QWheelEvent(new RJSBasecaster_RWheelEvent_QWheelEvent());
            
              // registration of base casters that casts RWheelEvent to RInputEvent:
              RInputEvent_Wrapper::registerBasecaster_RInputEvent(new RJSBasecaster_RWheelEvent_RInputEvent());
            
            // registration of base casters that cast RWidget to base classes:
            
              // registration of base casters that casts RWidget to QObject:
              QObject_Wrapper::registerBasecaster_QObject(new RJSBasecaster_RWidget_QObject());
            
              // registration of base casters that casts RWidget to QWidget:
              QWidget_Wrapper::registerBasecaster_QWidget(new RJSBasecaster_RWidget_QWidget());
            
            // registration of base casters that cast RXLine to base classes:
            
              // registration of base casters that casts RXLine to RShape:
              RShape_Wrapper::registerBasecaster_RShape(new RJSBasecaster_RXLine_RShape());
            
            // registration of base casters that cast RXLineData to base classes:
            
              // registration of base casters that casts RXLineData to REntityData:
              REntityData_Wrapper::registerBasecaster_REntityData(new RJSBasecaster_RXLineData_REntityData());
            
              // registration of base casters that casts RXLineData to RXLine:
              RXLine_Wrapper::registerBasecaster_RXLine(new RJSBasecaster_RXLineData_RXLine());
            
            // registration of base casters that cast RXLineEntity to base classes:
            
              // registration of base casters that casts RXLineEntity to RObject:
              RObject_Wrapper::registerBasecaster_RObject(new RJSBasecaster_RXLineEntity_RObject());
            
              // registration of base casters that casts RXLineEntity to REntity:
              REntity_Wrapper::registerBasecaster_REntity(new RJSBasecaster_RXLineEntity_REntity());
            
        }
      
  // ----------------
  // primitive types:
  // ----------------
  
      QJSValue RJSHelper_qcad::cpp2js_RAddObjectsOperation_Flags(RJSApi& handler, RAddObjectsOperation::Flags v) {
        return QJSValue(v);
      }

      RAddObjectsOperation::Flags RJSHelper_qcad::js2cpp_RAddObjectsOperation_Flags(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return RAddObjectsOperation::Flags()
          ;
        }
        return 
        (RAddObjectsOperation::Flags)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RAddObjectsOperation_Flags(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RRefPoint_Flags(RJSApi& handler, RRefPoint::Flags v) {
        return QJSValue(v);
      }

      RRefPoint::Flags RJSHelper_qcad::js2cpp_RRefPoint_Flags(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return RRefPoint::Flags()
          ;
        }
        return 
        (RRefPoint::Flags)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RRefPoint_Flags(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapAuto_Modes(RJSApi& handler, RSnapAuto::Modes v) {
        return QJSValue(v);
      }

      RSnapAuto::Modes RJSHelper_qcad::js2cpp_RSnapAuto_Modes(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return RSnapAuto::Modes()
          ;
        }
        return 
        (RSnapAuto::Modes)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RSnapAuto_Modes(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RAction_ClickMode(RJSApi& handler, RAction::ClickMode v) {
        return QJSValue(v);
      }

      RAction::ClickMode RJSHelper_qcad::js2cpp_RAction_ClickMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RAction::ClickMode)0
          ;
        }
        return 
        (RAction::ClickMode)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RAction_ClickMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RAddObjectsOperation_Flag(RJSApi& handler, RAddObjectsOperation::Flag v) {
        return QJSValue(v);
      }

      RAddObjectsOperation::Flag RJSHelper_qcad::js2cpp_RAddObjectsOperation_Flag(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RAddObjectsOperation::Flag)0
          ;
        }
        return 
        (RAddObjectsOperation::Flag)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RAddObjectsOperation_Flag(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RArcEntity_Id(RJSApi& handler, RArcEntity::Id v) {
        return QJSValue(v);
      }

      RArcEntity::Id RJSHelper_qcad::js2cpp_RArcEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RArcEntity::Id)0
          ;
        }
        return 
        (RArcEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RArcEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RAttributeDefinitionEntity_Id(RJSApi& handler, RAttributeDefinitionEntity::Id v) {
        return QJSValue(v);
      }

      RAttributeDefinitionEntity::Id RJSHelper_qcad::js2cpp_RAttributeDefinitionEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RAttributeDefinitionEntity::Id)0
          ;
        }
        return 
        (RAttributeDefinitionEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RAttributeDefinitionEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RAttributeEntity_Id(RJSApi& handler, RAttributeEntity::Id v) {
        return QJSValue(v);
      }

      RAttributeEntity::Id RJSHelper_qcad::js2cpp_RAttributeEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RAttributeEntity::Id)0
          ;
        }
        return 
        (RAttributeEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RAttributeEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RBlock_Handle(RJSApi& handler, RBlock::Handle v) {
        return QJSValue(v);
      }

      RBlock::Handle RJSHelper_qcad::js2cpp_RBlock_Handle(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RBlock::Handle)0
          ;
        }
        return 
        (RBlock::Handle)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RBlock_Handle(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RBlock_Id(RJSApi& handler, RBlock::Id v) {
        return QJSValue(v);
      }

      RBlock::Id RJSHelper_qcad::js2cpp_RBlock_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RBlock::Id)0
          ;
        }
        return 
        (RBlock::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RBlock_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RBlockReferenceEntity_Id(RJSApi& handler, RBlockReferenceEntity::Id v) {
        return QJSValue(v);
      }

      RBlockReferenceEntity::Id RJSHelper_qcad::js2cpp_RBlockReferenceEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RBlockReferenceEntity::Id)0
          ;
        }
        return 
        (RBlockReferenceEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RBlockReferenceEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RCircleEntity_Id(RJSApi& handler, RCircleEntity::Id v) {
        return QJSValue(v);
      }

      RCircleEntity::Id RJSHelper_qcad::js2cpp_RCircleEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RCircleEntity::Id)0
          ;
        }
        return 
        (RCircleEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RCircleEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RColor_Mode(RJSApi& handler, RColor::Mode v) {
        return QJSValue(v);
      }

      RColor::Mode RJSHelper_qcad::js2cpp_RColor_Mode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RColor::Mode)0
          ;
        }
        return 
        (RColor::Mode)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RColor_Mode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimAlignedEntity_Id(RJSApi& handler, RDimAlignedEntity::Id v) {
        return QJSValue(v);
      }

      RDimAlignedEntity::Id RJSHelper_qcad::js2cpp_RDimAlignedEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RDimAlignedEntity::Id)0
          ;
        }
        return 
        (RDimAlignedEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RDimAlignedEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimAngular2LEntity_Id(RJSApi& handler, RDimAngular2LEntity::Id v) {
        return QJSValue(v);
      }

      RDimAngular2LEntity::Id RJSHelper_qcad::js2cpp_RDimAngular2LEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RDimAngular2LEntity::Id)0
          ;
        }
        return 
        (RDimAngular2LEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RDimAngular2LEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimAngular3PEntity_Id(RJSApi& handler, RDimAngular3PEntity::Id v) {
        return QJSValue(v);
      }

      RDimAngular3PEntity::Id RJSHelper_qcad::js2cpp_RDimAngular3PEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RDimAngular3PEntity::Id)0
          ;
        }
        return 
        (RDimAngular3PEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RDimAngular3PEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimAngularEntity_Id(RJSApi& handler, RDimAngularEntity::Id v) {
        return QJSValue(v);
      }

      RDimAngularEntity::Id RJSHelper_qcad::js2cpp_RDimAngularEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RDimAngularEntity::Id)0
          ;
        }
        return 
        (RDimAngularEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RDimAngularEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimArcLengthEntity_Id(RJSApi& handler, RDimArcLengthEntity::Id v) {
        return QJSValue(v);
      }

      RDimArcLengthEntity::Id RJSHelper_qcad::js2cpp_RDimArcLengthEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RDimArcLengthEntity::Id)0
          ;
        }
        return 
        (RDimArcLengthEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RDimArcLengthEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimDiametricEntity_Id(RJSApi& handler, RDimDiametricEntity::Id v) {
        return QJSValue(v);
      }

      RDimDiametricEntity::Id RJSHelper_qcad::js2cpp_RDimDiametricEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RDimDiametricEntity::Id)0
          ;
        }
        return 
        (RDimDiametricEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RDimDiametricEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimLinearEntity_Id(RJSApi& handler, RDimLinearEntity::Id v) {
        return QJSValue(v);
      }

      RDimLinearEntity::Id RJSHelper_qcad::js2cpp_RDimLinearEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RDimLinearEntity::Id)0
          ;
        }
        return 
        (RDimLinearEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RDimLinearEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimOrdinateEntity_Id(RJSApi& handler, RDimOrdinateEntity::Id v) {
        return QJSValue(v);
      }

      RDimOrdinateEntity::Id RJSHelper_qcad::js2cpp_RDimOrdinateEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RDimOrdinateEntity::Id)0
          ;
        }
        return 
        (RDimOrdinateEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RDimOrdinateEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimRadialEntity_Id(RJSApi& handler, RDimRadialEntity::Id v) {
        return QJSValue(v);
      }

      RDimRadialEntity::Id RJSHelper_qcad::js2cpp_RDimRadialEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RDimRadialEntity::Id)0
          ;
        }
        return 
        (RDimRadialEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RDimRadialEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimRotatedEntity_Id(RJSApi& handler, RDimRotatedEntity::Id v) {
        return QJSValue(v);
      }

      RDimRotatedEntity::Id RJSHelper_qcad::js2cpp_RDimRotatedEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RDimRotatedEntity::Id)0
          ;
        }
        return 
        (RDimRotatedEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RDimRotatedEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimensionEntity_Id(RJSApi& handler, RDimensionEntity::Id v) {
        return QJSValue(v);
      }

      RDimensionEntity::Id RJSHelper_qcad::js2cpp_RDimensionEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RDimensionEntity::Id)0
          ;
        }
        return 
        (RDimensionEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RDimensionEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDocumentInterface_IoErrorCode(RJSApi& handler, RDocumentInterface::IoErrorCode v) {
        return QJSValue(v);
      }

      RDocumentInterface::IoErrorCode RJSHelper_qcad::js2cpp_RDocumentInterface_IoErrorCode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RDocumentInterface::IoErrorCode)0
          ;
        }
        return 
        (RDocumentInterface::IoErrorCode)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RDocumentInterface_IoErrorCode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDxfServices_Type(RJSApi& handler, RDxfServices::Type v) {
        return QJSValue(v);
      }

      RDxfServices::Type RJSHelper_qcad::js2cpp_RDxfServices_Type(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RDxfServices::Type)0
          ;
        }
        return 
        (RDxfServices::Type)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RDxfServices_Type(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_REllipseEntity_Id(RJSApi& handler, REllipseEntity::Id v) {
        return QJSValue(v);
      }

      REllipseEntity::Id RJSHelper_qcad::js2cpp_REllipseEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (REllipseEntity::Id)0
          ;
        }
        return 
        (REllipseEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_REllipseEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_REntity_Id(RJSApi& handler, REntity::Id v) {
        return QJSValue(v);
      }

      REntity::Id RJSHelper_qcad::js2cpp_REntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (REntity::Id)0
          ;
        }
        return 
        (REntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_REntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFaceEntity_Id(RJSApi& handler, RFaceEntity::Id v) {
        return QJSValue(v);
      }

      RFaceEntity::Id RJSHelper_qcad::js2cpp_RFaceEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RFaceEntity::Id)0
          ;
        }
        return 
        (RFaceEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RFaceEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RGraphicsSceneDrawable_Mode(RJSApi& handler, RGraphicsSceneDrawable::Mode v) {
        return QJSValue(v);
      }

      RGraphicsSceneDrawable::Mode RJSHelper_qcad::js2cpp_RGraphicsSceneDrawable_Mode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RGraphicsSceneDrawable::Mode)0
          ;
        }
        return 
        (RGraphicsSceneDrawable::Mode)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RGraphicsSceneDrawable_Mode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RGraphicsSceneDrawable_Type(RJSApi& handler, RGraphicsSceneDrawable::Type v) {
        return QJSValue(v);
      }

      RGraphicsSceneDrawable::Type RJSHelper_qcad::js2cpp_RGraphicsSceneDrawable_Type(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RGraphicsSceneDrawable::Type)0
          ;
        }
        return 
        (RGraphicsSceneDrawable::Type)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RGraphicsSceneDrawable_Type(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RGraphicsView_ColorMode(RJSApi& handler, RGraphicsView::ColorMode v) {
        return QJSValue(v);
      }

      RGraphicsView::ColorMode RJSHelper_qcad::js2cpp_RGraphicsView_ColorMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RGraphicsView::ColorMode)0
          ;
        }
        return 
        (RGraphicsView::ColorMode)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RGraphicsView_ColorMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RHatchEntity_Id(RJSApi& handler, RHatchEntity::Id v) {
        return QJSValue(v);
      }

      RHatchEntity::Id RJSHelper_qcad::js2cpp_RHatchEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RHatchEntity::Id)0
          ;
        }
        return 
        (RHatchEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RHatchEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RImageEntity_Id(RJSApi& handler, RImageEntity::Id v) {
        return QJSValue(v);
      }

      RImageEntity::Id RJSHelper_qcad::js2cpp_RImageEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RImageEntity::Id)0
          ;
        }
        return 
        (RImageEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RImageEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLayer_Id(RJSApi& handler, RLayer::Id v) {
        return QJSValue(v);
      }

      RLayer::Id RJSHelper_qcad::js2cpp_RLayer_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RLayer::Id)0
          ;
        }
        return 
        (RLayer::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RLayer_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLayerState_Id(RJSApi& handler, RLayerState::Id v) {
        return QJSValue(v);
      }

      RLayerState::Id RJSHelper_qcad::js2cpp_RLayerState_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RLayerState::Id)0
          ;
        }
        return 
        (RLayerState::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RLayerState_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLayout_Id(RJSApi& handler, RLayout::Id v) {
        return QJSValue(v);
      }

      RLayout::Id RJSHelper_qcad::js2cpp_RLayout_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RLayout::Id)0
          ;
        }
        return 
        (RLayout::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RLayout_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLayout_PlotPaperUnits(RJSApi& handler, RLayout::PlotPaperUnits v) {
        return QJSValue(v);
      }

      RLayout::PlotPaperUnits RJSHelper_qcad::js2cpp_RLayout_PlotPaperUnits(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RLayout::PlotPaperUnits)0
          ;
        }
        return 
        (RLayout::PlotPaperUnits)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RLayout_PlotPaperUnits(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLayout_PlotRotation(RJSApi& handler, RLayout::PlotRotation v) {
        return QJSValue(v);
      }

      RLayout::PlotRotation RJSHelper_qcad::js2cpp_RLayout_PlotRotation(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RLayout::PlotRotation)0
          ;
        }
        return 
        (RLayout::PlotRotation)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RLayout_PlotRotation(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLayout_PlotType(RJSApi& handler, RLayout::PlotType v) {
        return QJSValue(v);
      }

      RLayout::PlotType RJSHelper_qcad::js2cpp_RLayout_PlotType(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RLayout::PlotType)0
          ;
        }
        return 
        (RLayout::PlotType)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RLayout_PlotType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLayout_StandardScaleType(RJSApi& handler, RLayout::StandardScaleType v) {
        return QJSValue(v);
      }

      RLayout::StandardScaleType RJSHelper_qcad::js2cpp_RLayout_StandardScaleType(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RLayout::StandardScaleType)0
          ;
        }
        return 
        (RLayout::StandardScaleType)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RLayout_StandardScaleType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLeaderEntity_Id(RJSApi& handler, RLeaderEntity::Id v) {
        return QJSValue(v);
      }

      RLeaderEntity::Id RJSHelper_qcad::js2cpp_RLeaderEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RLeaderEntity::Id)0
          ;
        }
        return 
        (RLeaderEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RLeaderEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLineEntity_Id(RJSApi& handler, RLineEntity::Id v) {
        return QJSValue(v);
      }

      RLineEntity::Id RJSHelper_qcad::js2cpp_RLineEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RLineEntity::Id)0
          ;
        }
        return 
        (RLineEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RLineEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLinetype_Id(RJSApi& handler, RLinetype::Id v) {
        return QJSValue(v);
      }

      RLinetype::Id RJSHelper_qcad::js2cpp_RLinetype_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RLinetype::Id)0
          ;
        }
        return 
        (RLinetype::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RLinetype_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLineweight_Lineweight(RJSApi& handler, RLineweight::Lineweight v) {
        return QJSValue(v);
      }

      RLineweight::Lineweight RJSHelper_qcad::js2cpp_RLineweight_Lineweight(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RLineweight::Lineweight)0
          ;
        }
        return 
        (RLineweight::Lineweight)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RLineweight_Lineweight(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RObject_Handle(RJSApi& handler, RObject::Handle v) {
        return QJSValue(v);
      }

      RObject::Handle RJSHelper_qcad::js2cpp_RObject_Handle(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RObject::Handle)0
          ;
        }
        return 
        (RObject::Handle)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RObject_Handle(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RObject_Id(RJSApi& handler, RObject::Id v) {
        return QJSValue(v);
      }

      RObject::Id RJSHelper_qcad::js2cpp_RObject_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RObject::Id)0
          ;
        }
        return 
        (RObject::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RObject_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RObject_XYZ(RJSApi& handler, RObject::XYZ v) {
        return QJSValue(v);
      }

      RObject::XYZ RJSHelper_qcad::js2cpp_RObject_XYZ(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RObject::XYZ)0
          ;
        }
        return 
        (RObject::XYZ)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RObject_XYZ(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPainterPath_Mode(RJSApi& handler, RPainterPath::Mode v) {
        return QJSValue(v);
      }

      RPainterPath::Mode RJSHelper_qcad::js2cpp_RPainterPath_Mode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RPainterPath::Mode)0
          ;
        }
        return 
        (RPainterPath::Mode)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RPainterPath_Mode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPluginInterface_InitStatus(RJSApi& handler, RPluginInterface::InitStatus v) {
        return QJSValue(v);
      }

      RPluginInterface::InitStatus RJSHelper_qcad::js2cpp_RPluginInterface_InitStatus(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RPluginInterface::InitStatus)0
          ;
        }
        return 
        (RPluginInterface::InitStatus)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RPluginInterface_InitStatus(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPointEntity_Id(RJSApi& handler, RPointEntity::Id v) {
        return QJSValue(v);
      }

      RPointEntity::Id RJSHelper_qcad::js2cpp_RPointEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RPointEntity::Id)0
          ;
        }
        return 
        (RPointEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RPointEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPolylineEntity_Id(RJSApi& handler, RPolylineEntity::Id v) {
        return QJSValue(v);
      }

      RPolylineEntity::Id RJSHelper_qcad::js2cpp_RPolylineEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RPolylineEntity::Id)0
          ;
        }
        return 
        (RPolylineEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RPolylineEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPropertyAttributes_Option(RJSApi& handler, RPropertyAttributes::Option v) {
        return QJSValue(v);
      }

      RPropertyAttributes::Option RJSHelper_qcad::js2cpp_RPropertyAttributes_Option(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RPropertyAttributes::Option)0
          ;
        }
        return 
        (RPropertyAttributes::Option)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RPropertyAttributes_Option(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPropertyAttributes_Options(RJSApi& handler, RPropertyAttributes::Options v) {
        return QJSValue(v);
      }

      RPropertyAttributes::Options RJSHelper_qcad::js2cpp_RPropertyAttributes_Options(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RPropertyAttributes::Options)0
          ;
        }
        return 
        (RPropertyAttributes::Options)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RPropertyAttributes_Options(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RRayEntity_Id(RJSApi& handler, RRayEntity::Id v) {
        return QJSValue(v);
      }

      RRayEntity::Id RJSHelper_qcad::js2cpp_RRayEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RRayEntity::Id)0
          ;
        }
        return 
        (RRayEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RRayEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RRefPoint_Flag(RJSApi& handler, RRefPoint::Flag v) {
        return QJSValue(v);
      }

      RRefPoint::Flag RJSHelper_qcad::js2cpp_RRefPoint_Flag(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RRefPoint::Flag)0
          ;
        }
        return 
        (RRefPoint::Flag)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RRefPoint_Flag(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RS_AngleFormat(RJSApi& handler, RS::AngleFormat v) {
        return QJSValue(v);
      }

      RS::AngleFormat RJSHelper_qcad::js2cpp_RS_AngleFormat(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RS::AngleFormat)0
          ;
        }
        return 
        (RS::AngleFormat)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RS_AngleFormat(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RS_Easing(RJSApi& handler, RS::Easing v) {
        return QJSValue(v);
      }

      RS::Easing RJSHelper_qcad::js2cpp_RS_Easing(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RS::Easing)0
          ;
        }
        return 
        (RS::Easing)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RS_Easing(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RS_Ending(RJSApi& handler, RS::Ending v) {
        return QJSValue(v);
      }

      RS::Ending RJSHelper_qcad::js2cpp_RS_Ending(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RS::Ending)0
          ;
        }
        return 
        (RS::Ending)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RS_Ending(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RS_EntityType(RJSApi& handler, RS::EntityType v) {
        return QJSValue(v);
      }

      RS::EntityType RJSHelper_qcad::js2cpp_RS_EntityType(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RS::EntityType)0
          ;
        }
        return 
        (RS::EntityType)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RS_EntityType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RS_From(RJSApi& handler, RS::From v) {
        return QJSValue(v);
      }

      RS::From RJSHelper_qcad::js2cpp_RS_From(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RS::From)0
          ;
        }
        return 
        (RS::From)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RS_From(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RS_HAlign(RJSApi& handler, RS::HAlign v) {
        return QJSValue(v);
      }

      RS::HAlign RJSHelper_qcad::js2cpp_RS_HAlign(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RS::HAlign)0
          ;
        }
        return 
        (RS::HAlign)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RS_HAlign(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RS_IsoProjectionType(RJSApi& handler, RS::IsoProjectionType v) {
        return QJSValue(v);
      }

      RS::IsoProjectionType RJSHelper_qcad::js2cpp_RS_IsoProjectionType(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RS::IsoProjectionType)0
          ;
        }
        return 
        (RS::IsoProjectionType)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RS_IsoProjectionType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RS_JoinType(RJSApi& handler, RS::JoinType v) {
        return QJSValue(v);
      }

      RS::JoinType RJSHelper_qcad::js2cpp_RS_JoinType(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RS::JoinType)0
          ;
        }
        return 
        (RS::JoinType)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RS_JoinType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RS_KnownVariable(RJSApi& handler, RS::KnownVariable v) {
        return QJSValue(v);
      }

      RS::KnownVariable RJSHelper_qcad::js2cpp_RS_KnownVariable(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RS::KnownVariable)0
          ;
        }
        return 
        (RS::KnownVariable)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RS_KnownVariable(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RS_KnownVariableType(RJSApi& handler, RS::KnownVariableType v) {
        return QJSValue(v);
      }

      RS::KnownVariableType RJSHelper_qcad::js2cpp_RS_KnownVariableType(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RS::KnownVariableType)0
          ;
        }
        return 
        (RS::KnownVariableType)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RS_KnownVariableType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RS_LinearFormat(RJSApi& handler, RS::LinearFormat v) {
        return QJSValue(v);
      }

      RS::LinearFormat RJSHelper_qcad::js2cpp_RS_LinearFormat(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RS::LinearFormat)0
          ;
        }
        return 
        (RS::LinearFormat)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RS_LinearFormat(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RS_Measurement(RJSApi& handler, RS::Measurement v) {
        return QJSValue(v);
      }

      RS::Measurement RJSHelper_qcad::js2cpp_RS_Measurement(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RS::Measurement)0
          ;
        }
        return 
        (RS::Measurement)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RS_Measurement(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RS_MetaType(RJSApi& handler, RS::MetaType v) {
        return QJSValue(v);
      }

      RS::MetaType RJSHelper_qcad::js2cpp_RS_MetaType(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RS::MetaType)0
          ;
        }
        return 
        (RS::MetaType)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RS_MetaType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RS_Orientation(RJSApi& handler, RS::Orientation v) {
        return QJSValue(v);
      }

      RS::Orientation RJSHelper_qcad::js2cpp_RS_Orientation(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RS::Orientation)0
          ;
        }
        return 
        (RS::Orientation)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RS_Orientation(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RS_OrthoMode(RJSApi& handler, RS::OrthoMode v) {
        return QJSValue(v);
      }

      RS::OrthoMode RJSHelper_qcad::js2cpp_RS_OrthoMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RS::OrthoMode)0
          ;
        }
        return 
        (RS::OrthoMode)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RS_OrthoMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RS_ProjectionRenderingHint(RJSApi& handler, RS::ProjectionRenderingHint v) {
        return QJSValue(v);
      }

      RS::ProjectionRenderingHint RJSHelper_qcad::js2cpp_RS_ProjectionRenderingHint(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RS::ProjectionRenderingHint)0
          ;
        }
        return 
        (RS::ProjectionRenderingHint)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RS_ProjectionRenderingHint(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RS_Side(RJSApi& handler, RS::Side v) {
        return QJSValue(v);
      }

      RS::Side RJSHelper_qcad::js2cpp_RS_Side(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RS::Side)0
          ;
        }
        return 
        (RS::Side)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RS_Side(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RS_TextDrawingDirection(RJSApi& handler, RS::TextDrawingDirection v) {
        return QJSValue(v);
      }

      RS::TextDrawingDirection RJSHelper_qcad::js2cpp_RS_TextDrawingDirection(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RS::TextDrawingDirection)0
          ;
        }
        return 
        (RS::TextDrawingDirection)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RS_TextDrawingDirection(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RS_TextLineSpacingStyle(RJSApi& handler, RS::TextLineSpacingStyle v) {
        return QJSValue(v);
      }

      RS::TextLineSpacingStyle RJSHelper_qcad::js2cpp_RS_TextLineSpacingStyle(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RS::TextLineSpacingStyle)0
          ;
        }
        return 
        (RS::TextLineSpacingStyle)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RS_TextLineSpacingStyle(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RS_Unit(RJSApi& handler, RS::Unit v) {
        return QJSValue(v);
      }

      RS::Unit RJSHelper_qcad::js2cpp_RS_Unit(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RS::Unit)0
          ;
        }
        return 
        (RS::Unit)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RS_Unit(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RS_VAlign(RJSApi& handler, RS::VAlign v) {
        return QJSValue(v);
      }

      RS::VAlign RJSHelper_qcad::js2cpp_RS_VAlign(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RS::VAlign)0
          ;
        }
        return 
        (RS::VAlign)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RS_VAlign(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RShape_Type(RJSApi& handler, RShape::Type v) {
        return QJSValue(v);
      }

      RShape::Type RJSHelper_qcad::js2cpp_RShape_Type(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RShape::Type)0
          ;
        }
        return 
        (RShape::Type)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RShape_Type(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnap_Status(RJSApi& handler, RSnap::Status v) {
        return QJSValue(v);
      }

      RSnap::Status RJSHelper_qcad::js2cpp_RSnap_Status(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RSnap::Status)0
          ;
        }
        return 
        (RSnap::Status)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RSnap_Status(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapAuto_Mode(RJSApi& handler, RSnapAuto::Mode v) {
        return QJSValue(v);
      }

      RSnapAuto::Mode RJSHelper_qcad::js2cpp_RSnapAuto_Mode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RSnapAuto::Mode)0
          ;
        }
        return 
        (RSnapAuto::Mode)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RSnapAuto_Mode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSolidEntity_Id(RJSApi& handler, RSolidEntity::Id v) {
        return QJSValue(v);
      }

      RSolidEntity::Id RJSHelper_qcad::js2cpp_RSolidEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RSolidEntity::Id)0
          ;
        }
        return 
        (RSolidEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RSolidEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSplineEntity_Id(RJSApi& handler, RSplineEntity::Id v) {
        return QJSValue(v);
      }

      RSplineEntity::Id RJSHelper_qcad::js2cpp_RSplineEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RSplineEntity::Id)0
          ;
        }
        return 
        (RSplineEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RSplineEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTextBasedData_TextFlag(RJSApi& handler, RTextBasedData::TextFlag v) {
        return QJSValue(v);
      }

      RTextBasedData::TextFlag RJSHelper_qcad::js2cpp_RTextBasedData_TextFlag(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RTextBasedData::TextFlag)0
          ;
        }
        return 
        (RTextBasedData::TextFlag)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RTextBasedData_TextFlag(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTextBasedEntity_Id(RJSApi& handler, RTextBasedEntity::Id v) {
        return QJSValue(v);
      }

      RTextBasedEntity::Id RJSHelper_qcad::js2cpp_RTextBasedEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RTextBasedEntity::Id)0
          ;
        }
        return 
        (RTextBasedEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RTextBasedEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTextEntity_Id(RJSApi& handler, RTextEntity::Id v) {
        return QJSValue(v);
      }

      RTextEntity::Id RJSHelper_qcad::js2cpp_RTextEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RTextEntity::Id)0
          ;
        }
        return 
        (RTextEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RTextEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTextRenderer_Target(RJSApi& handler, RTextRenderer::Target v) {
        return QJSValue(v);
      }

      RTextRenderer::Target RJSHelper_qcad::js2cpp_RTextRenderer_Target(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RTextRenderer::Target)0
          ;
        }
        return 
        (RTextRenderer::Target)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RTextRenderer_Target(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RToleranceEntity_Id(RJSApi& handler, RToleranceEntity::Id v) {
        return QJSValue(v);
      }

      RToleranceEntity::Id RJSHelper_qcad::js2cpp_RToleranceEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RToleranceEntity::Id)0
          ;
        }
        return 
        (RToleranceEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RToleranceEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTraceEntity_Id(RJSApi& handler, RTraceEntity::Id v) {
        return QJSValue(v);
      }

      RTraceEntity::Id RJSHelper_qcad::js2cpp_RTraceEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RTraceEntity::Id)0
          ;
        }
        return 
        (RTraceEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RTraceEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTransaction_Type(RJSApi& handler, RTransaction::Type v) {
        return QJSValue(v);
      }

      RTransaction::Type RJSHelper_qcad::js2cpp_RTransaction_Type(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RTransaction::Type)0
          ;
        }
        return 
        (RTransaction::Type)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RTransaction_Type(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTransaction_Types(RJSApi& handler, RTransaction::Types v) {
        return QJSValue(v);
      }

      RTransaction::Types RJSHelper_qcad::js2cpp_RTransaction_Types(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RTransaction::Types)0
          ;
        }
        return 
        (RTransaction::Types)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RTransaction_Types(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTransformOp_Type(RJSApi& handler, RTransformOp::Type v) {
        return QJSValue(v);
      }

      RTransformOp::Type RJSHelper_qcad::js2cpp_RTransformOp_Type(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RTransformOp::Type)0
          ;
        }
        return 
        (RTransformOp::Type)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RTransformOp_Type(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RUcs_Id(RJSApi& handler, RUcs::Id v) {
        return QJSValue(v);
      }

      RUcs::Id RJSHelper_qcad::js2cpp_RUcs_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RUcs::Id)0
          ;
        }
        return 
        (RUcs::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RUcs_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RView_Id(RJSApi& handler, RView::Id v) {
        return QJSValue(v);
      }

      RView::Id RJSHelper_qcad::js2cpp_RView_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RView::Id)0
          ;
        }
        return 
        (RView::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RView_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RViewportEntity_Id(RJSApi& handler, RViewportEntity::Id v) {
        return QJSValue(v);
      }

      RViewportEntity::Id RJSHelper_qcad::js2cpp_RViewportEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RViewportEntity::Id)0
          ;
        }
        return 
        (RViewportEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RViewportEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RXLineEntity_Id(RJSApi& handler, RXLineEntity::Id v) {
        return QJSValue(v);
      }

      RXLineEntity::Id RJSHelper_qcad::js2cpp_RXLineEntity_Id(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (RXLineEntity::Id)0
          ;
        }
        return 
        (RXLineEntity::Id)
      v.toInt();
      }

      bool RJSHelper_qcad::is_RXLineEntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
  // ---------------------
  // QSharedPointer types:
  // ---------------------
  
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_REntity(RJSApi& handler, const QSharedPointer<REntity>& v) {
          QJSEngine* engine = handler.getEngine();
          REntity_Wrapper* ret = new REntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new REntity('__GOT_WRAPPER__', wrapper);");

          // JS: new REntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("REntity");
          if (cl.isUndefined()) {
              qWarning() << "Class REntity is undefined. Use REntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<REntity> RJSHelper_qcad::js2cpp_QSharedPointer_REntity(RJSApi& handler, const QJSValue& v) {
          REntity_Wrapper* wrapper = getWrapper<REntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_REntity: no wrapper";
              return QSharedPointer<REntity>();
          }
          //return QSharedPointer<REntity>(getWrapped_REntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<REntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<REntity>(wrapper->getWrappedClone());
              //return QSharedPointer<REntity>(wrapper->getWrapped());
              
                  // create clone on the fly:
                  return QSharedPointer<REntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_REntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_REntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RShape(RJSApi& handler, const QSharedPointer<RShape>& v) {
          QJSEngine* engine = handler.getEngine();
          RShape_Wrapper* ret = new RShape_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RShape('__GOT_WRAPPER__', wrapper);");

          // JS: new RShape('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RShape");
          if (cl.isUndefined()) {
              qWarning() << "Class RShape is undefined. Use RShape_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RShape> RJSHelper_qcad::js2cpp_QSharedPointer_RShape(RJSApi& handler, const QJSValue& v) {
          RShape_Wrapper* wrapper = getWrapper<RShape_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RShape: no wrapper";
              return QSharedPointer<RShape>();
          }
          //return QSharedPointer<RShape>(getWrapped_RShape(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RShape>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RShape>(wrapper->getWrappedClone());
              //return QSharedPointer<RShape>(wrapper->getWrapped());
              
                  // create clone on the fly:
                  return QSharedPointer<RShape>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RShape(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RShape_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RArc(RJSApi& handler, const QSharedPointer<RArc>& v) {
          QJSEngine* engine = handler.getEngine();
          RArc_Wrapper* ret = new RArc_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RArc('__GOT_WRAPPER__', wrapper);");

          // JS: new RArc('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RArc");
          if (cl.isUndefined()) {
              qWarning() << "Class RArc is undefined. Use RArc_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RArc> RJSHelper_qcad::js2cpp_QSharedPointer_RArc(RJSApi& handler, const QJSValue& v) {
          RArc_Wrapper* wrapper = getWrapper<RArc_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RArc: no wrapper";
              return QSharedPointer<RArc>();
          }
          //return QSharedPointer<RArc>(getWrapped_RArc(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RArc>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RArc>(wrapper->getWrappedClone());
              //return QSharedPointer<RArc>(wrapper->getWrapped());
              
                  // create clone on the fly:
                  return QSharedPointer<RArc>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RArc(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RArc_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RCircle(RJSApi& handler, const QSharedPointer<RCircle>& v) {
          QJSEngine* engine = handler.getEngine();
          RCircle_Wrapper* ret = new RCircle_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RCircle('__GOT_WRAPPER__', wrapper);");

          // JS: new RCircle('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCircle");
          if (cl.isUndefined()) {
              qWarning() << "Class RCircle is undefined. Use RCircle_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RCircle> RJSHelper_qcad::js2cpp_QSharedPointer_RCircle(RJSApi& handler, const QJSValue& v) {
          RCircle_Wrapper* wrapper = getWrapper<RCircle_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RCircle: no wrapper";
              return QSharedPointer<RCircle>();
          }
          //return QSharedPointer<RCircle>(getWrapped_RCircle(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RCircle>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RCircle>(wrapper->getWrappedClone());
              //return QSharedPointer<RCircle>(wrapper->getWrapped());
              
                  // create clone on the fly:
                  return QSharedPointer<RCircle>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RCircle(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RCircle_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_REllipse(RJSApi& handler, const QSharedPointer<REllipse>& v) {
          QJSEngine* engine = handler.getEngine();
          REllipse_Wrapper* ret = new REllipse_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new REllipse('__GOT_WRAPPER__', wrapper);");

          // JS: new REllipse('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("REllipse");
          if (cl.isUndefined()) {
              qWarning() << "Class REllipse is undefined. Use REllipse_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<REllipse> RJSHelper_qcad::js2cpp_QSharedPointer_REllipse(RJSApi& handler, const QJSValue& v) {
          REllipse_Wrapper* wrapper = getWrapper<REllipse_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_REllipse: no wrapper";
              return QSharedPointer<REllipse>();
          }
          //return QSharedPointer<REllipse>(getWrapped_REllipse(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<REllipse>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<REllipse>(wrapper->getWrappedClone());
              //return QSharedPointer<REllipse>(wrapper->getWrapped());
              
                  // create clone on the fly:
                  return QSharedPointer<REllipse>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_REllipse(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_REllipse_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RLine(RJSApi& handler, const QSharedPointer<RLine>& v) {
          QJSEngine* engine = handler.getEngine();
          RLine_Wrapper* ret = new RLine_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RLine('__GOT_WRAPPER__', wrapper);");

          // JS: new RLine('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLine");
          if (cl.isUndefined()) {
              qWarning() << "Class RLine is undefined. Use RLine_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RLine> RJSHelper_qcad::js2cpp_QSharedPointer_RLine(RJSApi& handler, const QJSValue& v) {
          RLine_Wrapper* wrapper = getWrapper<RLine_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RLine: no wrapper";
              return QSharedPointer<RLine>();
          }
          //return QSharedPointer<RLine>(getWrapped_RLine(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RLine>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RLine>(wrapper->getWrappedClone());
              //return QSharedPointer<RLine>(wrapper->getWrapped());
              
                  // create clone on the fly:
                  return QSharedPointer<RLine>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RLine(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RLine_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RPoint(RJSApi& handler, const QSharedPointer<RPoint>& v) {
          QJSEngine* engine = handler.getEngine();
          RPoint_Wrapper* ret = new RPoint_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RPoint('__GOT_WRAPPER__', wrapper);");

          // JS: new RPoint('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPoint");
          if (cl.isUndefined()) {
              qWarning() << "Class RPoint is undefined. Use RPoint_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RPoint> RJSHelper_qcad::js2cpp_QSharedPointer_RPoint(RJSApi& handler, const QJSValue& v) {
          RPoint_Wrapper* wrapper = getWrapper<RPoint_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RPoint: no wrapper";
              return QSharedPointer<RPoint>();
          }
          //return QSharedPointer<RPoint>(getWrapped_RPoint(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RPoint>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RPoint>(wrapper->getWrappedClone());
              //return QSharedPointer<RPoint>(wrapper->getWrapped());
              
                  // create clone on the fly:
                  return QSharedPointer<RPoint>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RPoint(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RPoint_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RRay(RJSApi& handler, const QSharedPointer<RRay>& v) {
          QJSEngine* engine = handler.getEngine();
          RRay_Wrapper* ret = new RRay_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RRay('__GOT_WRAPPER__', wrapper);");

          // JS: new RRay('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRay");
          if (cl.isUndefined()) {
              qWarning() << "Class RRay is undefined. Use RRay_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RRay> RJSHelper_qcad::js2cpp_QSharedPointer_RRay(RJSApi& handler, const QJSValue& v) {
          RRay_Wrapper* wrapper = getWrapper<RRay_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RRay: no wrapper";
              return QSharedPointer<RRay>();
          }
          //return QSharedPointer<RRay>(getWrapped_RRay(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RRay>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RRay>(wrapper->getWrappedClone());
              //return QSharedPointer<RRay>(wrapper->getWrapped());
              
                  // create clone on the fly:
                  return QSharedPointer<RRay>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RRay(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RRay_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RSpline(RJSApi& handler, const QSharedPointer<RSpline>& v) {
          QJSEngine* engine = handler.getEngine();
          RSpline_Wrapper* ret = new RSpline_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RSpline('__GOT_WRAPPER__', wrapper);");

          // JS: new RSpline('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSpline");
          if (cl.isUndefined()) {
              qWarning() << "Class RSpline is undefined. Use RSpline_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RSpline> RJSHelper_qcad::js2cpp_QSharedPointer_RSpline(RJSApi& handler, const QJSValue& v) {
          RSpline_Wrapper* wrapper = getWrapper<RSpline_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RSpline: no wrapper";
              return QSharedPointer<RSpline>();
          }
          //return QSharedPointer<RSpline>(getWrapped_RSpline(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RSpline>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RSpline>(wrapper->getWrappedClone());
              //return QSharedPointer<RSpline>(wrapper->getWrapped());
              
                  // create clone on the fly:
                  return QSharedPointer<RSpline>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RSpline(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RSpline_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RTriangle(RJSApi& handler, const QSharedPointer<RTriangle>& v) {
          QJSEngine* engine = handler.getEngine();
          RTriangle_Wrapper* ret = new RTriangle_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RTriangle('__GOT_WRAPPER__', wrapper);");

          // JS: new RTriangle('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTriangle");
          if (cl.isUndefined()) {
              qWarning() << "Class RTriangle is undefined. Use RTriangle_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RTriangle> RJSHelper_qcad::js2cpp_QSharedPointer_RTriangle(RJSApi& handler, const QJSValue& v) {
          RTriangle_Wrapper* wrapper = getWrapper<RTriangle_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RTriangle: no wrapper";
              return QSharedPointer<RTriangle>();
          }
          //return QSharedPointer<RTriangle>(getWrapped_RTriangle(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RTriangle>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RTriangle>(wrapper->getWrappedClone());
              //return QSharedPointer<RTriangle>(wrapper->getWrapped());
              
                  // create clone on the fly:
                  return QSharedPointer<RTriangle>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RTriangle(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RTriangle_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RXLine(RJSApi& handler, const QSharedPointer<RXLine>& v) {
          QJSEngine* engine = handler.getEngine();
          RXLine_Wrapper* ret = new RXLine_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RXLine('__GOT_WRAPPER__', wrapper);");

          // JS: new RXLine('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RXLine");
          if (cl.isUndefined()) {
              qWarning() << "Class RXLine is undefined. Use RXLine_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RXLine> RJSHelper_qcad::js2cpp_QSharedPointer_RXLine(RJSApi& handler, const QJSValue& v) {
          RXLine_Wrapper* wrapper = getWrapper<RXLine_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RXLine: no wrapper";
              return QSharedPointer<RXLine>();
          }
          //return QSharedPointer<RXLine>(getWrapped_RXLine(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RXLine>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RXLine>(wrapper->getWrappedClone());
              //return QSharedPointer<RXLine>(wrapper->getWrapped());
              
                  // create clone on the fly:
                  return QSharedPointer<RXLine>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RXLine(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RXLine_Type;
          return !v.isUndefined();
      }
    
  // ------------------------------------
  // QSharedPointer types (non-copyable):
  // ------------------------------------
  
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RObject(RJSApi& handler, const QSharedPointer<RObject>& v) {
          QJSEngine* engine = handler.getEngine();
          RObject_Wrapper* ret = new RObject_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RObject('__GOT_WRAPPER__', wrapper);");

          // JS: new RObject('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RObject");
          if (cl.isUndefined()) {
              qWarning() << "Class RObject is undefined. Use RObject_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RObject> RJSHelper_qcad::js2cpp_QSharedPointer_RObject(RJSApi& handler, const QJSValue& v) {
          RObject_Wrapper* wrapper = getWrapper<RObject_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RObject: no wrapper";
              return QSharedPointer<RObject>();
          }
          //return QSharedPointer<RObject>(getWrapped_RObject(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RObject>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RObject>(wrapper->getWrappedClone());
              //return QSharedPointer<RObject>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RObject: object cannot be cloned";
              //return QSharedPointer<RObject>();

              
                  // create clone on the fly:
                  return QSharedPointer<RObject>((RObject*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RObject>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RObject(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RObject_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RArcEntity(RJSApi& handler, const QSharedPointer<RArcEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RArcEntity_Wrapper* ret = new RArcEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RArcEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RArcEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RArcEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RArcEntity is undefined. Use RArcEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RArcEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RArcEntity(RJSApi& handler, const QJSValue& v) {
          RArcEntity_Wrapper* wrapper = getWrapper<RArcEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RArcEntity: no wrapper";
              return QSharedPointer<RArcEntity>();
          }
          //return QSharedPointer<RArcEntity>(getWrapped_RArcEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RArcEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RArcEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RArcEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RArcEntity: object cannot be cloned";
              //return QSharedPointer<RArcEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RArcEntity>((RArcEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RArcEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RArcEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RArcEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RAttributeDefinitionEntity(RJSApi& handler, const QSharedPointer<RAttributeDefinitionEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RAttributeDefinitionEntity_Wrapper* ret = new RAttributeDefinitionEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RAttributeDefinitionEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RAttributeDefinitionEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RAttributeDefinitionEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RAttributeDefinitionEntity is undefined. Use RAttributeDefinitionEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RAttributeDefinitionEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RAttributeDefinitionEntity(RJSApi& handler, const QJSValue& v) {
          RAttributeDefinitionEntity_Wrapper* wrapper = getWrapper<RAttributeDefinitionEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RAttributeDefinitionEntity: no wrapper";
              return QSharedPointer<RAttributeDefinitionEntity>();
          }
          //return QSharedPointer<RAttributeDefinitionEntity>(getWrapped_RAttributeDefinitionEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RAttributeDefinitionEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RAttributeDefinitionEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RAttributeDefinitionEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RAttributeDefinitionEntity: object cannot be cloned";
              //return QSharedPointer<RAttributeDefinitionEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RAttributeDefinitionEntity>((RAttributeDefinitionEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RAttributeDefinitionEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RAttributeDefinitionEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RAttributeDefinitionEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RAttributeEntity(RJSApi& handler, const QSharedPointer<RAttributeEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RAttributeEntity_Wrapper* ret = new RAttributeEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RAttributeEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RAttributeEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RAttributeEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RAttributeEntity is undefined. Use RAttributeEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RAttributeEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RAttributeEntity(RJSApi& handler, const QJSValue& v) {
          RAttributeEntity_Wrapper* wrapper = getWrapper<RAttributeEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RAttributeEntity: no wrapper";
              return QSharedPointer<RAttributeEntity>();
          }
          //return QSharedPointer<RAttributeEntity>(getWrapped_RAttributeEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RAttributeEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RAttributeEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RAttributeEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RAttributeEntity: object cannot be cloned";
              //return QSharedPointer<RAttributeEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RAttributeEntity>((RAttributeEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RAttributeEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RAttributeEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RAttributeEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RBlock(RJSApi& handler, const QSharedPointer<RBlock>& v) {
          QJSEngine* engine = handler.getEngine();
          RBlock_Wrapper* ret = new RBlock_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RBlock('__GOT_WRAPPER__', wrapper);");

          // JS: new RBlock('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RBlock");
          if (cl.isUndefined()) {
              qWarning() << "Class RBlock is undefined. Use RBlock_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RBlock> RJSHelper_qcad::js2cpp_QSharedPointer_RBlock(RJSApi& handler, const QJSValue& v) {
          RBlock_Wrapper* wrapper = getWrapper<RBlock_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RBlock: no wrapper";
              return QSharedPointer<RBlock>();
          }
          //return QSharedPointer<RBlock>(getWrapped_RBlock(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RBlock>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RBlock>(wrapper->getWrappedClone());
              //return QSharedPointer<RBlock>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RBlock: object cannot be cloned";
              //return QSharedPointer<RBlock>();

              
                  // create clone on the fly:
                  return QSharedPointer<RBlock>((RBlock*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RBlock>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RBlock(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RBlock_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RBlockReferenceEntity(RJSApi& handler, const QSharedPointer<RBlockReferenceEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RBlockReferenceEntity_Wrapper* ret = new RBlockReferenceEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RBlockReferenceEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RBlockReferenceEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RBlockReferenceEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RBlockReferenceEntity is undefined. Use RBlockReferenceEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RBlockReferenceEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RBlockReferenceEntity(RJSApi& handler, const QJSValue& v) {
          RBlockReferenceEntity_Wrapper* wrapper = getWrapper<RBlockReferenceEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RBlockReferenceEntity: no wrapper";
              return QSharedPointer<RBlockReferenceEntity>();
          }
          //return QSharedPointer<RBlockReferenceEntity>(getWrapped_RBlockReferenceEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RBlockReferenceEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RBlockReferenceEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RBlockReferenceEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RBlockReferenceEntity: object cannot be cloned";
              //return QSharedPointer<RBlockReferenceEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RBlockReferenceEntity>((RBlockReferenceEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RBlockReferenceEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RBlockReferenceEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RBlockReferenceEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RCircleEntity(RJSApi& handler, const QSharedPointer<RCircleEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RCircleEntity_Wrapper* ret = new RCircleEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RCircleEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RCircleEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCircleEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RCircleEntity is undefined. Use RCircleEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RCircleEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RCircleEntity(RJSApi& handler, const QJSValue& v) {
          RCircleEntity_Wrapper* wrapper = getWrapper<RCircleEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RCircleEntity: no wrapper";
              return QSharedPointer<RCircleEntity>();
          }
          //return QSharedPointer<RCircleEntity>(getWrapped_RCircleEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RCircleEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RCircleEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RCircleEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RCircleEntity: object cannot be cloned";
              //return QSharedPointer<RCircleEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RCircleEntity>((RCircleEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RCircleEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RCircleEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RCircleEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RDimAlignedEntity(RJSApi& handler, const QSharedPointer<RDimAlignedEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RDimAlignedEntity_Wrapper* ret = new RDimAlignedEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RDimAlignedEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RDimAlignedEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAlignedEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAlignedEntity is undefined. Use RDimAlignedEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RDimAlignedEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RDimAlignedEntity(RJSApi& handler, const QJSValue& v) {
          RDimAlignedEntity_Wrapper* wrapper = getWrapper<RDimAlignedEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RDimAlignedEntity: no wrapper";
              return QSharedPointer<RDimAlignedEntity>();
          }
          //return QSharedPointer<RDimAlignedEntity>(getWrapped_RDimAlignedEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RDimAlignedEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RDimAlignedEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RDimAlignedEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RDimAlignedEntity: object cannot be cloned";
              //return QSharedPointer<RDimAlignedEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RDimAlignedEntity>((RDimAlignedEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RDimAlignedEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RDimAlignedEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RDimAlignedEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RDimAngular2LEntity(RJSApi& handler, const QSharedPointer<RDimAngular2LEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RDimAngular2LEntity_Wrapper* ret = new RDimAngular2LEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RDimAngular2LEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RDimAngular2LEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAngular2LEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAngular2LEntity is undefined. Use RDimAngular2LEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RDimAngular2LEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RDimAngular2LEntity(RJSApi& handler, const QJSValue& v) {
          RDimAngular2LEntity_Wrapper* wrapper = getWrapper<RDimAngular2LEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RDimAngular2LEntity: no wrapper";
              return QSharedPointer<RDimAngular2LEntity>();
          }
          //return QSharedPointer<RDimAngular2LEntity>(getWrapped_RDimAngular2LEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RDimAngular2LEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RDimAngular2LEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RDimAngular2LEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RDimAngular2LEntity: object cannot be cloned";
              //return QSharedPointer<RDimAngular2LEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RDimAngular2LEntity>((RDimAngular2LEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RDimAngular2LEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RDimAngular2LEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RDimAngular2LEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RDimAngular3PEntity(RJSApi& handler, const QSharedPointer<RDimAngular3PEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RDimAngular3PEntity_Wrapper* ret = new RDimAngular3PEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RDimAngular3PEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RDimAngular3PEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAngular3PEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAngular3PEntity is undefined. Use RDimAngular3PEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RDimAngular3PEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RDimAngular3PEntity(RJSApi& handler, const QJSValue& v) {
          RDimAngular3PEntity_Wrapper* wrapper = getWrapper<RDimAngular3PEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RDimAngular3PEntity: no wrapper";
              return QSharedPointer<RDimAngular3PEntity>();
          }
          //return QSharedPointer<RDimAngular3PEntity>(getWrapped_RDimAngular3PEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RDimAngular3PEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RDimAngular3PEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RDimAngular3PEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RDimAngular3PEntity: object cannot be cloned";
              //return QSharedPointer<RDimAngular3PEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RDimAngular3PEntity>((RDimAngular3PEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RDimAngular3PEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RDimAngular3PEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RDimAngular3PEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RDimAngularData(RJSApi& handler, const QSharedPointer<RDimAngularData>& v) {
          QJSEngine* engine = handler.getEngine();
          RDimAngularData_Wrapper* ret = new RDimAngularData_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RDimAngularData('__GOT_WRAPPER__', wrapper);");

          // JS: new RDimAngularData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAngularData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAngularData is undefined. Use RDimAngularData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RDimAngularData> RJSHelper_qcad::js2cpp_QSharedPointer_RDimAngularData(RJSApi& handler, const QJSValue& v) {
          RDimAngularData_Wrapper* wrapper = getWrapper<RDimAngularData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RDimAngularData: no wrapper";
              return QSharedPointer<RDimAngularData>();
          }
          //return QSharedPointer<RDimAngularData>(getWrapped_RDimAngularData(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RDimAngularData>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RDimAngularData>(wrapper->getWrappedClone());
              //return QSharedPointer<RDimAngularData>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RDimAngularData: object cannot be cloned";
              //return QSharedPointer<RDimAngularData>();

              
                  // cannot be cloned:
                  return QSharedPointer<RDimAngularData>(wrapper->getWrapped());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RDimAngularData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RDimAngularData_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RDimAngularEntity(RJSApi& handler, const QSharedPointer<RDimAngularEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RDimAngularEntity_Wrapper* ret = new RDimAngularEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RDimAngularEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RDimAngularEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAngularEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAngularEntity is undefined. Use RDimAngularEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RDimAngularEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RDimAngularEntity(RJSApi& handler, const QJSValue& v) {
          RDimAngularEntity_Wrapper* wrapper = getWrapper<RDimAngularEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RDimAngularEntity: no wrapper";
              return QSharedPointer<RDimAngularEntity>();
          }
          //return QSharedPointer<RDimAngularEntity>(getWrapped_RDimAngularEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RDimAngularEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RDimAngularEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RDimAngularEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RDimAngularEntity: object cannot be cloned";
              //return QSharedPointer<RDimAngularEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RDimAngularEntity>((RDimAngularEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RDimAngularEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RDimAngularEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RDimAngularEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RDimArcLengthEntity(RJSApi& handler, const QSharedPointer<RDimArcLengthEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RDimArcLengthEntity_Wrapper* ret = new RDimArcLengthEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RDimArcLengthEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RDimArcLengthEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimArcLengthEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimArcLengthEntity is undefined. Use RDimArcLengthEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RDimArcLengthEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RDimArcLengthEntity(RJSApi& handler, const QJSValue& v) {
          RDimArcLengthEntity_Wrapper* wrapper = getWrapper<RDimArcLengthEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RDimArcLengthEntity: no wrapper";
              return QSharedPointer<RDimArcLengthEntity>();
          }
          //return QSharedPointer<RDimArcLengthEntity>(getWrapped_RDimArcLengthEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RDimArcLengthEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RDimArcLengthEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RDimArcLengthEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RDimArcLengthEntity: object cannot be cloned";
              //return QSharedPointer<RDimArcLengthEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RDimArcLengthEntity>((RDimArcLengthEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RDimArcLengthEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RDimArcLengthEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RDimArcLengthEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RDimDiametricEntity(RJSApi& handler, const QSharedPointer<RDimDiametricEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RDimDiametricEntity_Wrapper* ret = new RDimDiametricEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RDimDiametricEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RDimDiametricEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimDiametricEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimDiametricEntity is undefined. Use RDimDiametricEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RDimDiametricEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RDimDiametricEntity(RJSApi& handler, const QJSValue& v) {
          RDimDiametricEntity_Wrapper* wrapper = getWrapper<RDimDiametricEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RDimDiametricEntity: no wrapper";
              return QSharedPointer<RDimDiametricEntity>();
          }
          //return QSharedPointer<RDimDiametricEntity>(getWrapped_RDimDiametricEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RDimDiametricEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RDimDiametricEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RDimDiametricEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RDimDiametricEntity: object cannot be cloned";
              //return QSharedPointer<RDimDiametricEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RDimDiametricEntity>((RDimDiametricEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RDimDiametricEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RDimDiametricEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RDimDiametricEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RDimLinearEntity(RJSApi& handler, const QSharedPointer<RDimLinearEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RDimLinearEntity_Wrapper* ret = new RDimLinearEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RDimLinearEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RDimLinearEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimLinearEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimLinearEntity is undefined. Use RDimLinearEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RDimLinearEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RDimLinearEntity(RJSApi& handler, const QJSValue& v) {
          RDimLinearEntity_Wrapper* wrapper = getWrapper<RDimLinearEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RDimLinearEntity: no wrapper";
              return QSharedPointer<RDimLinearEntity>();
          }
          //return QSharedPointer<RDimLinearEntity>(getWrapped_RDimLinearEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RDimLinearEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RDimLinearEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RDimLinearEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RDimLinearEntity: object cannot be cloned";
              //return QSharedPointer<RDimLinearEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RDimLinearEntity>((RDimLinearEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RDimLinearEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RDimLinearEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RDimLinearEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RDimOrdinateEntity(RJSApi& handler, const QSharedPointer<RDimOrdinateEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RDimOrdinateEntity_Wrapper* ret = new RDimOrdinateEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RDimOrdinateEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RDimOrdinateEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimOrdinateEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimOrdinateEntity is undefined. Use RDimOrdinateEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RDimOrdinateEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RDimOrdinateEntity(RJSApi& handler, const QJSValue& v) {
          RDimOrdinateEntity_Wrapper* wrapper = getWrapper<RDimOrdinateEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RDimOrdinateEntity: no wrapper";
              return QSharedPointer<RDimOrdinateEntity>();
          }
          //return QSharedPointer<RDimOrdinateEntity>(getWrapped_RDimOrdinateEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RDimOrdinateEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RDimOrdinateEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RDimOrdinateEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RDimOrdinateEntity: object cannot be cloned";
              //return QSharedPointer<RDimOrdinateEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RDimOrdinateEntity>((RDimOrdinateEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RDimOrdinateEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RDimOrdinateEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RDimOrdinateEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RDimRadialEntity(RJSApi& handler, const QSharedPointer<RDimRadialEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RDimRadialEntity_Wrapper* ret = new RDimRadialEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RDimRadialEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RDimRadialEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimRadialEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimRadialEntity is undefined. Use RDimRadialEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RDimRadialEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RDimRadialEntity(RJSApi& handler, const QJSValue& v) {
          RDimRadialEntity_Wrapper* wrapper = getWrapper<RDimRadialEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RDimRadialEntity: no wrapper";
              return QSharedPointer<RDimRadialEntity>();
          }
          //return QSharedPointer<RDimRadialEntity>(getWrapped_RDimRadialEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RDimRadialEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RDimRadialEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RDimRadialEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RDimRadialEntity: object cannot be cloned";
              //return QSharedPointer<RDimRadialEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RDimRadialEntity>((RDimRadialEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RDimRadialEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RDimRadialEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RDimRadialEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RDimRotatedEntity(RJSApi& handler, const QSharedPointer<RDimRotatedEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RDimRotatedEntity_Wrapper* ret = new RDimRotatedEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RDimRotatedEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RDimRotatedEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimRotatedEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimRotatedEntity is undefined. Use RDimRotatedEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RDimRotatedEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RDimRotatedEntity(RJSApi& handler, const QJSValue& v) {
          RDimRotatedEntity_Wrapper* wrapper = getWrapper<RDimRotatedEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RDimRotatedEntity: no wrapper";
              return QSharedPointer<RDimRotatedEntity>();
          }
          //return QSharedPointer<RDimRotatedEntity>(getWrapped_RDimRotatedEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RDimRotatedEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RDimRotatedEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RDimRotatedEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RDimRotatedEntity: object cannot be cloned";
              //return QSharedPointer<RDimRotatedEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RDimRotatedEntity>((RDimRotatedEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RDimRotatedEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RDimRotatedEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RDimRotatedEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RDimStyle(RJSApi& handler, const QSharedPointer<RDimStyle>& v) {
          QJSEngine* engine = handler.getEngine();
          RDimStyle_Wrapper* ret = new RDimStyle_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RDimStyle('__GOT_WRAPPER__', wrapper);");

          // JS: new RDimStyle('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimStyle");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimStyle is undefined. Use RDimStyle_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RDimStyle> RJSHelper_qcad::js2cpp_QSharedPointer_RDimStyle(RJSApi& handler, const QJSValue& v) {
          RDimStyle_Wrapper* wrapper = getWrapper<RDimStyle_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RDimStyle: no wrapper";
              return QSharedPointer<RDimStyle>();
          }
          //return QSharedPointer<RDimStyle>(getWrapped_RDimStyle(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RDimStyle>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RDimStyle>(wrapper->getWrappedClone());
              //return QSharedPointer<RDimStyle>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RDimStyle: object cannot be cloned";
              //return QSharedPointer<RDimStyle>();

              
                  // create clone on the fly:
                  return QSharedPointer<RDimStyle>((RDimStyle*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RDimStyle>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RDimStyle(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RDimStyle_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RDimensionEntity(RJSApi& handler, const QSharedPointer<RDimensionEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RDimensionEntity_Wrapper* ret = new RDimensionEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RDimensionEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RDimensionEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimensionEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimensionEntity is undefined. Use RDimensionEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RDimensionEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RDimensionEntity(RJSApi& handler, const QJSValue& v) {
          RDimensionEntity_Wrapper* wrapper = getWrapper<RDimensionEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RDimensionEntity: no wrapper";
              return QSharedPointer<RDimensionEntity>();
          }
          //return QSharedPointer<RDimensionEntity>(getWrapped_RDimensionEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RDimensionEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RDimensionEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RDimensionEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RDimensionEntity: object cannot be cloned";
              //return QSharedPointer<RDimensionEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RDimensionEntity>((RDimensionEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RDimensionEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RDimensionEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RDimensionEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RDocumentVariables(RJSApi& handler, const QSharedPointer<RDocumentVariables>& v) {
          QJSEngine* engine = handler.getEngine();
          RDocumentVariables_Wrapper* ret = new RDocumentVariables_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RDocumentVariables('__GOT_WRAPPER__', wrapper);");

          // JS: new RDocumentVariables('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDocumentVariables");
          if (cl.isUndefined()) {
              qWarning() << "Class RDocumentVariables is undefined. Use RDocumentVariables_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RDocumentVariables> RJSHelper_qcad::js2cpp_QSharedPointer_RDocumentVariables(RJSApi& handler, const QJSValue& v) {
          RDocumentVariables_Wrapper* wrapper = getWrapper<RDocumentVariables_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RDocumentVariables: no wrapper";
              return QSharedPointer<RDocumentVariables>();
          }
          //return QSharedPointer<RDocumentVariables>(getWrapped_RDocumentVariables(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RDocumentVariables>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RDocumentVariables>(wrapper->getWrappedClone());
              //return QSharedPointer<RDocumentVariables>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RDocumentVariables: object cannot be cloned";
              //return QSharedPointer<RDocumentVariables>();

              
                  // create clone on the fly:
                  return QSharedPointer<RDocumentVariables>((RDocumentVariables*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RDocumentVariables>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RDocumentVariables(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RDocumentVariables_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_REllipseEntity(RJSApi& handler, const QSharedPointer<REllipseEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          REllipseEntity_Wrapper* ret = new REllipseEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new REllipseEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new REllipseEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("REllipseEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class REllipseEntity is undefined. Use REllipseEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<REllipseEntity> RJSHelper_qcad::js2cpp_QSharedPointer_REllipseEntity(RJSApi& handler, const QJSValue& v) {
          REllipseEntity_Wrapper* wrapper = getWrapper<REllipseEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_REllipseEntity: no wrapper";
              return QSharedPointer<REllipseEntity>();
          }
          //return QSharedPointer<REllipseEntity>(getWrapped_REllipseEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<REllipseEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<REllipseEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<REllipseEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_REllipseEntity: object cannot be cloned";
              //return QSharedPointer<REllipseEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<REllipseEntity>((REllipseEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<REllipseEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_REllipseEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_REllipseEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RFaceEntity(RJSApi& handler, const QSharedPointer<RFaceEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RFaceEntity_Wrapper* ret = new RFaceEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RFaceEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RFaceEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFaceEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RFaceEntity is undefined. Use RFaceEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RFaceEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RFaceEntity(RJSApi& handler, const QJSValue& v) {
          RFaceEntity_Wrapper* wrapper = getWrapper<RFaceEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RFaceEntity: no wrapper";
              return QSharedPointer<RFaceEntity>();
          }
          //return QSharedPointer<RFaceEntity>(getWrapped_RFaceEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RFaceEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RFaceEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RFaceEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RFaceEntity: object cannot be cloned";
              //return QSharedPointer<RFaceEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RFaceEntity>((RFaceEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RFaceEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RFaceEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RFaceEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RHatchEntity(RJSApi& handler, const QSharedPointer<RHatchEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RHatchEntity_Wrapper* ret = new RHatchEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RHatchEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RHatchEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RHatchEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RHatchEntity is undefined. Use RHatchEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RHatchEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RHatchEntity(RJSApi& handler, const QJSValue& v) {
          RHatchEntity_Wrapper* wrapper = getWrapper<RHatchEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RHatchEntity: no wrapper";
              return QSharedPointer<RHatchEntity>();
          }
          //return QSharedPointer<RHatchEntity>(getWrapped_RHatchEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RHatchEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RHatchEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RHatchEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RHatchEntity: object cannot be cloned";
              //return QSharedPointer<RHatchEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RHatchEntity>((RHatchEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RHatchEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RHatchEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RHatchEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RImageEntity(RJSApi& handler, const QSharedPointer<RImageEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RImageEntity_Wrapper* ret = new RImageEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RImageEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RImageEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RImageEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RImageEntity is undefined. Use RImageEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RImageEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RImageEntity(RJSApi& handler, const QJSValue& v) {
          RImageEntity_Wrapper* wrapper = getWrapper<RImageEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RImageEntity: no wrapper";
              return QSharedPointer<RImageEntity>();
          }
          //return QSharedPointer<RImageEntity>(getWrapped_RImageEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RImageEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RImageEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RImageEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RImageEntity: object cannot be cloned";
              //return QSharedPointer<RImageEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RImageEntity>((RImageEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RImageEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RImageEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RImageEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RLayer(RJSApi& handler, const QSharedPointer<RLayer>& v) {
          QJSEngine* engine = handler.getEngine();
          RLayer_Wrapper* ret = new RLayer_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RLayer('__GOT_WRAPPER__', wrapper);");

          // JS: new RLayer('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLayer");
          if (cl.isUndefined()) {
              qWarning() << "Class RLayer is undefined. Use RLayer_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RLayer> RJSHelper_qcad::js2cpp_QSharedPointer_RLayer(RJSApi& handler, const QJSValue& v) {
          RLayer_Wrapper* wrapper = getWrapper<RLayer_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RLayer: no wrapper";
              return QSharedPointer<RLayer>();
          }
          //return QSharedPointer<RLayer>(getWrapped_RLayer(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RLayer>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RLayer>(wrapper->getWrappedClone());
              //return QSharedPointer<RLayer>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RLayer: object cannot be cloned";
              //return QSharedPointer<RLayer>();

              
                  // create clone on the fly:
                  return QSharedPointer<RLayer>((RLayer*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RLayer>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RLayer(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RLayer_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RLayerState(RJSApi& handler, const QSharedPointer<RLayerState>& v) {
          QJSEngine* engine = handler.getEngine();
          RLayerState_Wrapper* ret = new RLayerState_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RLayerState('__GOT_WRAPPER__', wrapper);");

          // JS: new RLayerState('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLayerState");
          if (cl.isUndefined()) {
              qWarning() << "Class RLayerState is undefined. Use RLayerState_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RLayerState> RJSHelper_qcad::js2cpp_QSharedPointer_RLayerState(RJSApi& handler, const QJSValue& v) {
          RLayerState_Wrapper* wrapper = getWrapper<RLayerState_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RLayerState: no wrapper";
              return QSharedPointer<RLayerState>();
          }
          //return QSharedPointer<RLayerState>(getWrapped_RLayerState(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RLayerState>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RLayerState>(wrapper->getWrappedClone());
              //return QSharedPointer<RLayerState>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RLayerState: object cannot be cloned";
              //return QSharedPointer<RLayerState>();

              
                  // create clone on the fly:
                  return QSharedPointer<RLayerState>((RLayerState*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RLayerState>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RLayerState(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RLayerState_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RLayout(RJSApi& handler, const QSharedPointer<RLayout>& v) {
          QJSEngine* engine = handler.getEngine();
          RLayout_Wrapper* ret = new RLayout_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RLayout('__GOT_WRAPPER__', wrapper);");

          // JS: new RLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class RLayout is undefined. Use RLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RLayout> RJSHelper_qcad::js2cpp_QSharedPointer_RLayout(RJSApi& handler, const QJSValue& v) {
          RLayout_Wrapper* wrapper = getWrapper<RLayout_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RLayout: no wrapper";
              return QSharedPointer<RLayout>();
          }
          //return QSharedPointer<RLayout>(getWrapped_RLayout(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RLayout>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RLayout>(wrapper->getWrappedClone());
              //return QSharedPointer<RLayout>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RLayout: object cannot be cloned";
              //return QSharedPointer<RLayout>();

              
                  // create clone on the fly:
                  return QSharedPointer<RLayout>((RLayout*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RLayout>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RLayout(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RLayout_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RLeaderEntity(RJSApi& handler, const QSharedPointer<RLeaderEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RLeaderEntity_Wrapper* ret = new RLeaderEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RLeaderEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RLeaderEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLeaderEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RLeaderEntity is undefined. Use RLeaderEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RLeaderEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RLeaderEntity(RJSApi& handler, const QJSValue& v) {
          RLeaderEntity_Wrapper* wrapper = getWrapper<RLeaderEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RLeaderEntity: no wrapper";
              return QSharedPointer<RLeaderEntity>();
          }
          //return QSharedPointer<RLeaderEntity>(getWrapped_RLeaderEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RLeaderEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RLeaderEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RLeaderEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RLeaderEntity: object cannot be cloned";
              //return QSharedPointer<RLeaderEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RLeaderEntity>((RLeaderEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RLeaderEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RLeaderEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RLeaderEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RLineEntity(RJSApi& handler, const QSharedPointer<RLineEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RLineEntity_Wrapper* ret = new RLineEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RLineEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RLineEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLineEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RLineEntity is undefined. Use RLineEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RLineEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RLineEntity(RJSApi& handler, const QJSValue& v) {
          RLineEntity_Wrapper* wrapper = getWrapper<RLineEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RLineEntity: no wrapper";
              return QSharedPointer<RLineEntity>();
          }
          //return QSharedPointer<RLineEntity>(getWrapped_RLineEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RLineEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RLineEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RLineEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RLineEntity: object cannot be cloned";
              //return QSharedPointer<RLineEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RLineEntity>((RLineEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RLineEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RLineEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RLineEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RLinetype(RJSApi& handler, const QSharedPointer<RLinetype>& v) {
          QJSEngine* engine = handler.getEngine();
          RLinetype_Wrapper* ret = new RLinetype_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RLinetype('__GOT_WRAPPER__', wrapper);");

          // JS: new RLinetype('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLinetype");
          if (cl.isUndefined()) {
              qWarning() << "Class RLinetype is undefined. Use RLinetype_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RLinetype> RJSHelper_qcad::js2cpp_QSharedPointer_RLinetype(RJSApi& handler, const QJSValue& v) {
          RLinetype_Wrapper* wrapper = getWrapper<RLinetype_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RLinetype: no wrapper";
              return QSharedPointer<RLinetype>();
          }
          //return QSharedPointer<RLinetype>(getWrapped_RLinetype(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RLinetype>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RLinetype>(wrapper->getWrappedClone());
              //return QSharedPointer<RLinetype>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RLinetype: object cannot be cloned";
              //return QSharedPointer<RLinetype>();

              
                  // create clone on the fly:
                  return QSharedPointer<RLinetype>((RLinetype*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RLinetype>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RLinetype(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RLinetype_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RPointEntity(RJSApi& handler, const QSharedPointer<RPointEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RPointEntity_Wrapper* ret = new RPointEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RPointEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RPointEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPointEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RPointEntity is undefined. Use RPointEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RPointEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RPointEntity(RJSApi& handler, const QJSValue& v) {
          RPointEntity_Wrapper* wrapper = getWrapper<RPointEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RPointEntity: no wrapper";
              return QSharedPointer<RPointEntity>();
          }
          //return QSharedPointer<RPointEntity>(getWrapped_RPointEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RPointEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RPointEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RPointEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RPointEntity: object cannot be cloned";
              //return QSharedPointer<RPointEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RPointEntity>((RPointEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RPointEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RPointEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RPointEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RPolyline(RJSApi& handler, const QSharedPointer<RPolyline>& v) {
          QJSEngine* engine = handler.getEngine();
          RPolyline_Wrapper* ret = new RPolyline_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RPolyline('__GOT_WRAPPER__', wrapper);");

          // JS: new RPolyline('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPolyline");
          if (cl.isUndefined()) {
              qWarning() << "Class RPolyline is undefined. Use RPolyline_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RPolyline> RJSHelper_qcad::js2cpp_QSharedPointer_RPolyline(RJSApi& handler, const QJSValue& v) {
          RPolyline_Wrapper* wrapper = getWrapper<RPolyline_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RPolyline: no wrapper";
              return QSharedPointer<RPolyline>();
          }
          //return QSharedPointer<RPolyline>(getWrapped_RPolyline(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RPolyline>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RPolyline>(wrapper->getWrappedClone());
              //return QSharedPointer<RPolyline>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RPolyline: object cannot be cloned";
              //return QSharedPointer<RPolyline>();

              
                  // create clone on the fly:
                  return QSharedPointer<RPolyline>((RPolyline*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RPolyline>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RPolyline(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RPolyline_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RPolylineEntity(RJSApi& handler, const QSharedPointer<RPolylineEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RPolylineEntity_Wrapper* ret = new RPolylineEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RPolylineEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RPolylineEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPolylineEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RPolylineEntity is undefined. Use RPolylineEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RPolylineEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RPolylineEntity(RJSApi& handler, const QJSValue& v) {
          RPolylineEntity_Wrapper* wrapper = getWrapper<RPolylineEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RPolylineEntity: no wrapper";
              return QSharedPointer<RPolylineEntity>();
          }
          //return QSharedPointer<RPolylineEntity>(getWrapped_RPolylineEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RPolylineEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RPolylineEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RPolylineEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RPolylineEntity: object cannot be cloned";
              //return QSharedPointer<RPolylineEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RPolylineEntity>((RPolylineEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RPolylineEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RPolylineEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RPolylineEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RRayEntity(RJSApi& handler, const QSharedPointer<RRayEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RRayEntity_Wrapper* ret = new RRayEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RRayEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RRayEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRayEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RRayEntity is undefined. Use RRayEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RRayEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RRayEntity(RJSApi& handler, const QJSValue& v) {
          RRayEntity_Wrapper* wrapper = getWrapper<RRayEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RRayEntity: no wrapper";
              return QSharedPointer<RRayEntity>();
          }
          //return QSharedPointer<RRayEntity>(getWrapped_RRayEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RRayEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RRayEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RRayEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RRayEntity: object cannot be cloned";
              //return QSharedPointer<RRayEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RRayEntity>((RRayEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RRayEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RRayEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RRayEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RSolidEntity(RJSApi& handler, const QSharedPointer<RSolidEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RSolidEntity_Wrapper* ret = new RSolidEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RSolidEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RSolidEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSolidEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RSolidEntity is undefined. Use RSolidEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RSolidEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RSolidEntity(RJSApi& handler, const QJSValue& v) {
          RSolidEntity_Wrapper* wrapper = getWrapper<RSolidEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RSolidEntity: no wrapper";
              return QSharedPointer<RSolidEntity>();
          }
          //return QSharedPointer<RSolidEntity>(getWrapped_RSolidEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RSolidEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RSolidEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RSolidEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RSolidEntity: object cannot be cloned";
              //return QSharedPointer<RSolidEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RSolidEntity>((RSolidEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RSolidEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RSolidEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RSolidEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RSplineEntity(RJSApi& handler, const QSharedPointer<RSplineEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RSplineEntity_Wrapper* ret = new RSplineEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RSplineEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RSplineEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSplineEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RSplineEntity is undefined. Use RSplineEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RSplineEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RSplineEntity(RJSApi& handler, const QJSValue& v) {
          RSplineEntity_Wrapper* wrapper = getWrapper<RSplineEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RSplineEntity: no wrapper";
              return QSharedPointer<RSplineEntity>();
          }
          //return QSharedPointer<RSplineEntity>(getWrapped_RSplineEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RSplineEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RSplineEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RSplineEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RSplineEntity: object cannot be cloned";
              //return QSharedPointer<RSplineEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RSplineEntity>((RSplineEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RSplineEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RSplineEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RSplineEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RTextEntity(RJSApi& handler, const QSharedPointer<RTextEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RTextEntity_Wrapper* ret = new RTextEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RTextEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RTextEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTextEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RTextEntity is undefined. Use RTextEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RTextEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RTextEntity(RJSApi& handler, const QJSValue& v) {
          RTextEntity_Wrapper* wrapper = getWrapper<RTextEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RTextEntity: no wrapper";
              return QSharedPointer<RTextEntity>();
          }
          //return QSharedPointer<RTextEntity>(getWrapped_RTextEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RTextEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RTextEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RTextEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RTextEntity: object cannot be cloned";
              //return QSharedPointer<RTextEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RTextEntity>((RTextEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RTextEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RTextEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RTextEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RToleranceEntity(RJSApi& handler, const QSharedPointer<RToleranceEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RToleranceEntity_Wrapper* ret = new RToleranceEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RToleranceEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RToleranceEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RToleranceEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RToleranceEntity is undefined. Use RToleranceEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RToleranceEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RToleranceEntity(RJSApi& handler, const QJSValue& v) {
          RToleranceEntity_Wrapper* wrapper = getWrapper<RToleranceEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RToleranceEntity: no wrapper";
              return QSharedPointer<RToleranceEntity>();
          }
          //return QSharedPointer<RToleranceEntity>(getWrapped_RToleranceEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RToleranceEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RToleranceEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RToleranceEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RToleranceEntity: object cannot be cloned";
              //return QSharedPointer<RToleranceEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RToleranceEntity>((RToleranceEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RToleranceEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RToleranceEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RToleranceEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RTraceEntity(RJSApi& handler, const QSharedPointer<RTraceEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RTraceEntity_Wrapper* ret = new RTraceEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RTraceEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RTraceEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTraceEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RTraceEntity is undefined. Use RTraceEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RTraceEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RTraceEntity(RJSApi& handler, const QJSValue& v) {
          RTraceEntity_Wrapper* wrapper = getWrapper<RTraceEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RTraceEntity: no wrapper";
              return QSharedPointer<RTraceEntity>();
          }
          //return QSharedPointer<RTraceEntity>(getWrapped_RTraceEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RTraceEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RTraceEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RTraceEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RTraceEntity: object cannot be cloned";
              //return QSharedPointer<RTraceEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RTraceEntity>((RTraceEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RTraceEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RTraceEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RTraceEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RUcs(RJSApi& handler, const QSharedPointer<RUcs>& v) {
          QJSEngine* engine = handler.getEngine();
          RUcs_Wrapper* ret = new RUcs_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RUcs('__GOT_WRAPPER__', wrapper);");

          // JS: new RUcs('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RUcs");
          if (cl.isUndefined()) {
              qWarning() << "Class RUcs is undefined. Use RUcs_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RUcs> RJSHelper_qcad::js2cpp_QSharedPointer_RUcs(RJSApi& handler, const QJSValue& v) {
          RUcs_Wrapper* wrapper = getWrapper<RUcs_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RUcs: no wrapper";
              return QSharedPointer<RUcs>();
          }
          //return QSharedPointer<RUcs>(getWrapped_RUcs(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RUcs>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RUcs>(wrapper->getWrappedClone());
              //return QSharedPointer<RUcs>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RUcs: object cannot be cloned";
              //return QSharedPointer<RUcs>();

              
                  // create clone on the fly:
                  return QSharedPointer<RUcs>((RUcs*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RUcs>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RUcs(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RUcs_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RView(RJSApi& handler, const QSharedPointer<RView>& v) {
          QJSEngine* engine = handler.getEngine();
          RView_Wrapper* ret = new RView_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RView('__GOT_WRAPPER__', wrapper);");

          // JS: new RView('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RView");
          if (cl.isUndefined()) {
              qWarning() << "Class RView is undefined. Use RView_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RView> RJSHelper_qcad::js2cpp_QSharedPointer_RView(RJSApi& handler, const QJSValue& v) {
          RView_Wrapper* wrapper = getWrapper<RView_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RView: no wrapper";
              return QSharedPointer<RView>();
          }
          //return QSharedPointer<RView>(getWrapped_RView(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RView>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RView>(wrapper->getWrappedClone());
              //return QSharedPointer<RView>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RView: object cannot be cloned";
              //return QSharedPointer<RView>();

              
                  // create clone on the fly:
                  return QSharedPointer<RView>((RView*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RView>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RView(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RView_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RViewportEntity(RJSApi& handler, const QSharedPointer<RViewportEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RViewportEntity_Wrapper* ret = new RViewportEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RViewportEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RViewportEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RViewportEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RViewportEntity is undefined. Use RViewportEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RViewportEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RViewportEntity(RJSApi& handler, const QJSValue& v) {
          RViewportEntity_Wrapper* wrapper = getWrapper<RViewportEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RViewportEntity: no wrapper";
              return QSharedPointer<RViewportEntity>();
          }
          //return QSharedPointer<RViewportEntity>(getWrapped_RViewportEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RViewportEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RViewportEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RViewportEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RViewportEntity: object cannot be cloned";
              //return QSharedPointer<RViewportEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RViewportEntity>((RViewportEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RViewportEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RViewportEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RViewportEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RXLineEntity(RJSApi& handler, const QSharedPointer<RXLineEntity>& v) {
          QJSEngine* engine = handler.getEngine();
          RXLineEntity_Wrapper* ret = new RXLineEntity_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RXLineEntity('__GOT_WRAPPER__', wrapper);");

          // JS: new RXLineEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RXLineEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RXLineEntity is undefined. Use RXLineEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RXLineEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RXLineEntity(RJSApi& handler, const QJSValue& v) {
          RXLineEntity_Wrapper* wrapper = getWrapper<RXLineEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RXLineEntity: no wrapper";
              return QSharedPointer<RXLineEntity>();
          }
          //return QSharedPointer<RXLineEntity>(getWrapped_RXLineEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RXLineEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RXLineEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RXLineEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RXLineEntity: object cannot be cloned";
              //return QSharedPointer<RXLineEntity>();

              
                  // create clone on the fly:
                  return QSharedPointer<RXLineEntity>((RXLineEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RXLineEntity>(wrapper->getWrapped()->clone());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RXLineEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RXLineEntity_Type;
          return !v.isUndefined();
      }
    
  // --------------
  // wrapped types:
  // --------------
  
      QJSValue RJSHelper_qcad::cpp2js_RArc(RJSApi& handler, const RArc* v) {
          QJSEngine* engine = handler.getEngine();
          RArc_Wrapper* ret;

          if (v==nullptr) {
              ret = new RArc_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RArc object:
              ret = new RArc_Wrapper(handler, new RArc(*v), true);
          }

          // JS: new RArc('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RArc");
          if (cl.isUndefined()) {
              qWarning() << "Class RArc is undefined. Use RArc_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RArc('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RArc(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RArc(RJSApi& handler, const RArc& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RArc object:
          RArc_Wrapper* ret = new RArc_Wrapper(handler, new RArc(v), true);

          // JS: new RArc('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RArc");
          if (cl.isUndefined()) {
              qWarning() << "Class RArc is undefined. Use RArc_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RArc('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RArc(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RArc RJSHelper_qcad::js2cpp_RArc(RJSApi& handler, const QJSValue& v) {
          /*
          RArc_Wrapper* wrapper = getWrapper<RArc_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RArc: no wrapper";
              Q_ASSERT(false);
              return RArc();
          }
          //return *(RArc*)wrapper->getWrappedVoid();
          RArc* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RArc: wrapped pointer is NULL";
              return RArc();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RArc: not a QObject";
              return RArc();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RArc_ptr: no wrapper";
              return RArc();
          }
          //RArc* ret = getWrapped_RArc(wrapper);
          RArc* ret = RArc_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RArc();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RArc(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RArc: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RArc::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RArcData(RJSApi& handler, const RArcData* v) {
          QJSEngine* engine = handler.getEngine();
          RArcData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RArcData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RArcData object:
              ret = new RArcData_Wrapper(handler, new RArcData(*v), true);
          }

          // JS: new RArcData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RArcData");
          if (cl.isUndefined()) {
              qWarning() << "Class RArcData is undefined. Use RArcData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RArcData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RArcData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RArcData(RJSApi& handler, const RArcData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RArcData object:
          RArcData_Wrapper* ret = new RArcData_Wrapper(handler, new RArcData(v), true);

          // JS: new RArcData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RArcData");
          if (cl.isUndefined()) {
              qWarning() << "Class RArcData is undefined. Use RArcData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RArcData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RArcData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RArcData RJSHelper_qcad::js2cpp_RArcData(RJSApi& handler, const QJSValue& v) {
          /*
          RArcData_Wrapper* wrapper = getWrapper<RArcData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RArcData: no wrapper";
              Q_ASSERT(false);
              return RArcData();
          }
          //return *(RArcData*)wrapper->getWrappedVoid();
          RArcData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RArcData: wrapped pointer is NULL";
              return RArcData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RArcData: not a QObject";
              return RArcData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RArcData_ptr: no wrapper";
              return RArcData();
          }
          //RArcData* ret = getWrapped_RArcData(wrapper);
          RArcData* ret = RArcData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RArcData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RArcData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RArcData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RArcData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RAttributeData(RJSApi& handler, const RAttributeData* v) {
          QJSEngine* engine = handler.getEngine();
          RAttributeData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RAttributeData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RAttributeData object:
              ret = new RAttributeData_Wrapper(handler, new RAttributeData(*v), true);
          }

          // JS: new RAttributeData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RAttributeData");
          if (cl.isUndefined()) {
              qWarning() << "Class RAttributeData is undefined. Use RAttributeData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RAttributeData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RAttributeData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RAttributeData(RJSApi& handler, const RAttributeData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RAttributeData object:
          RAttributeData_Wrapper* ret = new RAttributeData_Wrapper(handler, new RAttributeData(v), true);

          // JS: new RAttributeData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RAttributeData");
          if (cl.isUndefined()) {
              qWarning() << "Class RAttributeData is undefined. Use RAttributeData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RAttributeData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RAttributeData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RAttributeData RJSHelper_qcad::js2cpp_RAttributeData(RJSApi& handler, const QJSValue& v) {
          /*
          RAttributeData_Wrapper* wrapper = getWrapper<RAttributeData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RAttributeData: no wrapper";
              Q_ASSERT(false);
              return RAttributeData();
          }
          //return *(RAttributeData*)wrapper->getWrappedVoid();
          RAttributeData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RAttributeData: wrapped pointer is NULL";
              return RAttributeData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RAttributeData: not a QObject";
              return RAttributeData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RAttributeData_ptr: no wrapper";
              return RAttributeData();
          }
          //RAttributeData* ret = getWrapped_RAttributeData(wrapper);
          RAttributeData* ret = RAttributeData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RAttributeData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RAttributeData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RAttributeData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RAttributeData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RAttributeDefinitionData(RJSApi& handler, const RAttributeDefinitionData* v) {
          QJSEngine* engine = handler.getEngine();
          RAttributeDefinitionData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RAttributeDefinitionData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RAttributeDefinitionData object:
              ret = new RAttributeDefinitionData_Wrapper(handler, new RAttributeDefinitionData(*v), true);
          }

          // JS: new RAttributeDefinitionData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RAttributeDefinitionData");
          if (cl.isUndefined()) {
              qWarning() << "Class RAttributeDefinitionData is undefined. Use RAttributeDefinitionData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RAttributeDefinitionData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RAttributeDefinitionData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RAttributeDefinitionData(RJSApi& handler, const RAttributeDefinitionData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RAttributeDefinitionData object:
          RAttributeDefinitionData_Wrapper* ret = new RAttributeDefinitionData_Wrapper(handler, new RAttributeDefinitionData(v), true);

          // JS: new RAttributeDefinitionData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RAttributeDefinitionData");
          if (cl.isUndefined()) {
              qWarning() << "Class RAttributeDefinitionData is undefined. Use RAttributeDefinitionData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RAttributeDefinitionData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RAttributeDefinitionData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RAttributeDefinitionData RJSHelper_qcad::js2cpp_RAttributeDefinitionData(RJSApi& handler, const QJSValue& v) {
          /*
          RAttributeDefinitionData_Wrapper* wrapper = getWrapper<RAttributeDefinitionData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RAttributeDefinitionData: no wrapper";
              Q_ASSERT(false);
              return RAttributeDefinitionData();
          }
          //return *(RAttributeDefinitionData*)wrapper->getWrappedVoid();
          RAttributeDefinitionData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RAttributeDefinitionData: wrapped pointer is NULL";
              return RAttributeDefinitionData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RAttributeDefinitionData: not a QObject";
              return RAttributeDefinitionData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RAttributeDefinitionData_ptr: no wrapper";
              return RAttributeDefinitionData();
          }
          //RAttributeDefinitionData* ret = getWrapped_RAttributeDefinitionData(wrapper);
          RAttributeDefinitionData* ret = RAttributeDefinitionData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RAttributeDefinitionData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RAttributeDefinitionData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RAttributeDefinitionData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RAttributeDefinitionData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RAutoLoadJs(RJSApi& handler, const RAutoLoadJs* v) {
          QJSEngine* engine = handler.getEngine();
          RAutoLoadJs_Wrapper* ret;

          if (v==nullptr) {
              ret = new RAutoLoadJs_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RAutoLoadJs object:
              ret = new RAutoLoadJs_Wrapper(handler, new RAutoLoadJs(*v), true);
          }

          // JS: new RAutoLoadJs('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RAutoLoadJs");
          if (cl.isUndefined()) {
              qWarning() << "Class RAutoLoadJs is undefined. Use RAutoLoadJs_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RAutoLoadJs('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RAutoLoadJs(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RAutoLoadJs(RJSApi& handler, const RAutoLoadJs& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RAutoLoadJs object:
          RAutoLoadJs_Wrapper* ret = new RAutoLoadJs_Wrapper(handler, new RAutoLoadJs(v), true);

          // JS: new RAutoLoadJs('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RAutoLoadJs");
          if (cl.isUndefined()) {
              qWarning() << "Class RAutoLoadJs is undefined. Use RAutoLoadJs_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RAutoLoadJs('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RAutoLoadJs(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RAutoLoadJs RJSHelper_qcad::js2cpp_RAutoLoadJs(RJSApi& handler, const QJSValue& v) {
          /*
          RAutoLoadJs_Wrapper* wrapper = getWrapper<RAutoLoadJs_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RAutoLoadJs: no wrapper";
              Q_ASSERT(false);
              return RAutoLoadJs();
          }
          //return *(RAutoLoadJs*)wrapper->getWrappedVoid();
          RAutoLoadJs* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RAutoLoadJs: wrapped pointer is NULL";
              return RAutoLoadJs();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RAutoLoadJs: not a QObject";
              return RAutoLoadJs();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RAutoLoadJs_ptr: no wrapper";
              return RAutoLoadJs();
          }
          //RAutoLoadJs* ret = getWrapped_RAutoLoadJs(wrapper);
          RAutoLoadJs* ret = RAutoLoadJs_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RAutoLoadJs();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RAutoLoadJs(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RAutoLoadJs: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RAutoLoadJs::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RBlockReferenceData(RJSApi& handler, const RBlockReferenceData* v) {
          QJSEngine* engine = handler.getEngine();
          RBlockReferenceData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RBlockReferenceData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RBlockReferenceData object:
              ret = new RBlockReferenceData_Wrapper(handler, new RBlockReferenceData(*v), true);
          }

          // JS: new RBlockReferenceData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RBlockReferenceData");
          if (cl.isUndefined()) {
              qWarning() << "Class RBlockReferenceData is undefined. Use RBlockReferenceData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RBlockReferenceData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RBlockReferenceData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RBlockReferenceData(RJSApi& handler, const RBlockReferenceData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RBlockReferenceData object:
          RBlockReferenceData_Wrapper* ret = new RBlockReferenceData_Wrapper(handler, new RBlockReferenceData(v), true);

          // JS: new RBlockReferenceData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RBlockReferenceData");
          if (cl.isUndefined()) {
              qWarning() << "Class RBlockReferenceData is undefined. Use RBlockReferenceData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RBlockReferenceData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RBlockReferenceData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RBlockReferenceData RJSHelper_qcad::js2cpp_RBlockReferenceData(RJSApi& handler, const QJSValue& v) {
          /*
          RBlockReferenceData_Wrapper* wrapper = getWrapper<RBlockReferenceData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RBlockReferenceData: no wrapper";
              Q_ASSERT(false);
              return RBlockReferenceData();
          }
          //return *(RBlockReferenceData*)wrapper->getWrappedVoid();
          RBlockReferenceData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RBlockReferenceData: wrapped pointer is NULL";
              return RBlockReferenceData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RBlockReferenceData: not a QObject";
              return RBlockReferenceData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RBlockReferenceData_ptr: no wrapper";
              return RBlockReferenceData();
          }
          //RBlockReferenceData* ret = getWrapped_RBlockReferenceData(wrapper);
          RBlockReferenceData* ret = RBlockReferenceData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RBlockReferenceData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RBlockReferenceData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RBlockReferenceData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RBlockReferenceData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RBox(RJSApi& handler, const RBox* v) {
          QJSEngine* engine = handler.getEngine();
          RBox_Wrapper* ret;

          if (v==nullptr) {
              ret = new RBox_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RBox object:
              ret = new RBox_Wrapper(handler, new RBox(*v), true);
          }

          // JS: new RBox('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RBox");
          if (cl.isUndefined()) {
              qWarning() << "Class RBox is undefined. Use RBox_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RBox('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RBox(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RBox(RJSApi& handler, const RBox& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RBox object:
          RBox_Wrapper* ret = new RBox_Wrapper(handler, new RBox(v), true);

          // JS: new RBox('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RBox");
          if (cl.isUndefined()) {
              qWarning() << "Class RBox is undefined. Use RBox_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RBox('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RBox(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RBox RJSHelper_qcad::js2cpp_RBox(RJSApi& handler, const QJSValue& v) {
          /*
          RBox_Wrapper* wrapper = getWrapper<RBox_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RBox: no wrapper";
              Q_ASSERT(false);
              return RBox();
          }
          //return *(RBox*)wrapper->getWrappedVoid();
          RBox* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RBox: wrapped pointer is NULL";
              return RBox();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RBox: not a QObject";
              return RBox();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RBox_ptr: no wrapper";
              return RBox();
          }
          //RBox* ret = getWrapped_RBox(wrapper);
          RBox* ret = RBox_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RBox();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RBox(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RBox: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RBox::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RCircle(RJSApi& handler, const RCircle* v) {
          QJSEngine* engine = handler.getEngine();
          RCircle_Wrapper* ret;

          if (v==nullptr) {
              ret = new RCircle_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RCircle object:
              ret = new RCircle_Wrapper(handler, new RCircle(*v), true);
          }

          // JS: new RCircle('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCircle");
          if (cl.isUndefined()) {
              qWarning() << "Class RCircle is undefined. Use RCircle_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCircle('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCircle(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RCircle(RJSApi& handler, const RCircle& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RCircle object:
          RCircle_Wrapper* ret = new RCircle_Wrapper(handler, new RCircle(v), true);

          // JS: new RCircle('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCircle");
          if (cl.isUndefined()) {
              qWarning() << "Class RCircle is undefined. Use RCircle_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCircle('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCircle(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RCircle RJSHelper_qcad::js2cpp_RCircle(RJSApi& handler, const QJSValue& v) {
          /*
          RCircle_Wrapper* wrapper = getWrapper<RCircle_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCircle: no wrapper";
              Q_ASSERT(false);
              return RCircle();
          }
          //return *(RCircle*)wrapper->getWrappedVoid();
          RCircle* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RCircle: wrapped pointer is NULL";
              return RCircle();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RCircle: not a QObject";
              return RCircle();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCircle_ptr: no wrapper";
              return RCircle();
          }
          //RCircle* ret = getWrapped_RCircle(wrapper);
          RCircle* ret = RCircle_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RCircle();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RCircle(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RCircle: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RCircle::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RCircleData(RJSApi& handler, const RCircleData* v) {
          QJSEngine* engine = handler.getEngine();
          RCircleData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RCircleData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RCircleData object:
              ret = new RCircleData_Wrapper(handler, new RCircleData(*v), true);
          }

          // JS: new RCircleData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCircleData");
          if (cl.isUndefined()) {
              qWarning() << "Class RCircleData is undefined. Use RCircleData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCircleData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCircleData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RCircleData(RJSApi& handler, const RCircleData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RCircleData object:
          RCircleData_Wrapper* ret = new RCircleData_Wrapper(handler, new RCircleData(v), true);

          // JS: new RCircleData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCircleData");
          if (cl.isUndefined()) {
              qWarning() << "Class RCircleData is undefined. Use RCircleData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCircleData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCircleData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RCircleData RJSHelper_qcad::js2cpp_RCircleData(RJSApi& handler, const QJSValue& v) {
          /*
          RCircleData_Wrapper* wrapper = getWrapper<RCircleData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCircleData: no wrapper";
              Q_ASSERT(false);
              return RCircleData();
          }
          //return *(RCircleData*)wrapper->getWrappedVoid();
          RCircleData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RCircleData: wrapped pointer is NULL";
              return RCircleData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RCircleData: not a QObject";
              return RCircleData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCircleData_ptr: no wrapper";
              return RCircleData();
          }
          //RCircleData* ret = getWrapped_RCircleData(wrapper);
          RCircleData* ret = RCircleData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RCircleData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RCircleData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RCircleData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RCircleData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RColor(RJSApi& handler, const RColor* v) {
          QJSEngine* engine = handler.getEngine();
          RColor_Wrapper* ret;

          if (v==nullptr) {
              ret = new RColor_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RColor object:
              ret = new RColor_Wrapper(handler, new RColor(*v), true);
          }

          // JS: new RColor('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RColor");
          if (cl.isUndefined()) {
              qWarning() << "Class RColor is undefined. Use RColor_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RColor('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RColor(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RColor(RJSApi& handler, const RColor& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RColor object:
          RColor_Wrapper* ret = new RColor_Wrapper(handler, new RColor(v), true);

          // JS: new RColor('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RColor");
          if (cl.isUndefined()) {
              qWarning() << "Class RColor is undefined. Use RColor_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RColor('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RColor(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RColor RJSHelper_qcad::js2cpp_RColor(RJSApi& handler, const QJSValue& v) {
          /*
          RColor_Wrapper* wrapper = getWrapper<RColor_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RColor: no wrapper";
              Q_ASSERT(false);
              return RColor();
          }
          //return *(RColor*)wrapper->getWrappedVoid();
          RColor* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RColor: wrapped pointer is NULL";
              return RColor();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RColor: not a QObject";
              return RColor();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RColor_ptr: no wrapper";
              return RColor();
          }
          //RColor* ret = getWrapped_RColor(wrapper);
          RColor* ret = RColor_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RColor();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RColor(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RColor: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RColor::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDebug(RJSApi& handler, const RDebug* v) {
          QJSEngine* engine = handler.getEngine();
          RDebug_Wrapper* ret;

          if (v==nullptr) {
              ret = new RDebug_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RDebug object:
              ret = new RDebug_Wrapper(handler, new RDebug(*v), true);
          }

          // JS: new RDebug('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDebug");
          if (cl.isUndefined()) {
              qWarning() << "Class RDebug is undefined. Use RDebug_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDebug('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDebug(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RDebug(RJSApi& handler, const RDebug& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RDebug object:
          RDebug_Wrapper* ret = new RDebug_Wrapper(handler, new RDebug(v), true);

          // JS: new RDebug('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDebug");
          if (cl.isUndefined()) {
              qWarning() << "Class RDebug is undefined. Use RDebug_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDebug('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDebug(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RDebug RJSHelper_qcad::js2cpp_RDebug(RJSApi& handler, const QJSValue& v) {
          /*
          RDebug_Wrapper* wrapper = getWrapper<RDebug_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDebug: no wrapper";
              Q_ASSERT(false);
              return RDebug();
          }
          //return *(RDebug*)wrapper->getWrappedVoid();
          RDebug* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RDebug: wrapped pointer is NULL";
              return RDebug();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDebug: not a QObject";
              return RDebug();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDebug_ptr: no wrapper";
              return RDebug();
          }
          //RDebug* ret = getWrapped_RDebug(wrapper);
          RDebug* ret = RDebug_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RDebug();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RDebug(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDebug: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RDebug::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimAlignedData(RJSApi& handler, const RDimAlignedData* v) {
          QJSEngine* engine = handler.getEngine();
          RDimAlignedData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RDimAlignedData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RDimAlignedData object:
              ret = new RDimAlignedData_Wrapper(handler, new RDimAlignedData(*v), true);
          }

          // JS: new RDimAlignedData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAlignedData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAlignedData is undefined. Use RDimAlignedData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimAlignedData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimAlignedData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RDimAlignedData(RJSApi& handler, const RDimAlignedData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RDimAlignedData object:
          RDimAlignedData_Wrapper* ret = new RDimAlignedData_Wrapper(handler, new RDimAlignedData(v), true);

          // JS: new RDimAlignedData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAlignedData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAlignedData is undefined. Use RDimAlignedData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimAlignedData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimAlignedData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RDimAlignedData RJSHelper_qcad::js2cpp_RDimAlignedData(RJSApi& handler, const QJSValue& v) {
          /*
          RDimAlignedData_Wrapper* wrapper = getWrapper<RDimAlignedData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimAlignedData: no wrapper";
              Q_ASSERT(false);
              return RDimAlignedData();
          }
          //return *(RDimAlignedData*)wrapper->getWrappedVoid();
          RDimAlignedData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RDimAlignedData: wrapped pointer is NULL";
              return RDimAlignedData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimAlignedData: not a QObject";
              return RDimAlignedData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimAlignedData_ptr: no wrapper";
              return RDimAlignedData();
          }
          //RDimAlignedData* ret = getWrapped_RDimAlignedData(wrapper);
          RDimAlignedData* ret = RDimAlignedData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RDimAlignedData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RDimAlignedData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimAlignedData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RDimAlignedData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimAngular2LData(RJSApi& handler, const RDimAngular2LData* v) {
          QJSEngine* engine = handler.getEngine();
          RDimAngular2LData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RDimAngular2LData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RDimAngular2LData object:
              ret = new RDimAngular2LData_Wrapper(handler, new RDimAngular2LData(*v), true);
          }

          // JS: new RDimAngular2LData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAngular2LData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAngular2LData is undefined. Use RDimAngular2LData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimAngular2LData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimAngular2LData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RDimAngular2LData(RJSApi& handler, const RDimAngular2LData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RDimAngular2LData object:
          RDimAngular2LData_Wrapper* ret = new RDimAngular2LData_Wrapper(handler, new RDimAngular2LData(v), true);

          // JS: new RDimAngular2LData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAngular2LData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAngular2LData is undefined. Use RDimAngular2LData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimAngular2LData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimAngular2LData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RDimAngular2LData RJSHelper_qcad::js2cpp_RDimAngular2LData(RJSApi& handler, const QJSValue& v) {
          /*
          RDimAngular2LData_Wrapper* wrapper = getWrapper<RDimAngular2LData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimAngular2LData: no wrapper";
              Q_ASSERT(false);
              return RDimAngular2LData();
          }
          //return *(RDimAngular2LData*)wrapper->getWrappedVoid();
          RDimAngular2LData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RDimAngular2LData: wrapped pointer is NULL";
              return RDimAngular2LData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimAngular2LData: not a QObject";
              return RDimAngular2LData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimAngular2LData_ptr: no wrapper";
              return RDimAngular2LData();
          }
          //RDimAngular2LData* ret = getWrapped_RDimAngular2LData(wrapper);
          RDimAngular2LData* ret = RDimAngular2LData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RDimAngular2LData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RDimAngular2LData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimAngular2LData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RDimAngular2LData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimAngular3PData(RJSApi& handler, const RDimAngular3PData* v) {
          QJSEngine* engine = handler.getEngine();
          RDimAngular3PData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RDimAngular3PData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RDimAngular3PData object:
              ret = new RDimAngular3PData_Wrapper(handler, new RDimAngular3PData(*v), true);
          }

          // JS: new RDimAngular3PData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAngular3PData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAngular3PData is undefined. Use RDimAngular3PData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimAngular3PData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimAngular3PData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RDimAngular3PData(RJSApi& handler, const RDimAngular3PData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RDimAngular3PData object:
          RDimAngular3PData_Wrapper* ret = new RDimAngular3PData_Wrapper(handler, new RDimAngular3PData(v), true);

          // JS: new RDimAngular3PData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAngular3PData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAngular3PData is undefined. Use RDimAngular3PData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimAngular3PData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimAngular3PData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RDimAngular3PData RJSHelper_qcad::js2cpp_RDimAngular3PData(RJSApi& handler, const QJSValue& v) {
          /*
          RDimAngular3PData_Wrapper* wrapper = getWrapper<RDimAngular3PData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimAngular3PData: no wrapper";
              Q_ASSERT(false);
              return RDimAngular3PData();
          }
          //return *(RDimAngular3PData*)wrapper->getWrappedVoid();
          RDimAngular3PData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RDimAngular3PData: wrapped pointer is NULL";
              return RDimAngular3PData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimAngular3PData: not a QObject";
              return RDimAngular3PData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimAngular3PData_ptr: no wrapper";
              return RDimAngular3PData();
          }
          //RDimAngular3PData* ret = getWrapped_RDimAngular3PData(wrapper);
          RDimAngular3PData* ret = RDimAngular3PData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RDimAngular3PData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RDimAngular3PData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimAngular3PData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RDimAngular3PData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimArcLengthData(RJSApi& handler, const RDimArcLengthData* v) {
          QJSEngine* engine = handler.getEngine();
          RDimArcLengthData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RDimArcLengthData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RDimArcLengthData object:
              ret = new RDimArcLengthData_Wrapper(handler, new RDimArcLengthData(*v), true);
          }

          // JS: new RDimArcLengthData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimArcLengthData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimArcLengthData is undefined. Use RDimArcLengthData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimArcLengthData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimArcLengthData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RDimArcLengthData(RJSApi& handler, const RDimArcLengthData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RDimArcLengthData object:
          RDimArcLengthData_Wrapper* ret = new RDimArcLengthData_Wrapper(handler, new RDimArcLengthData(v), true);

          // JS: new RDimArcLengthData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimArcLengthData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimArcLengthData is undefined. Use RDimArcLengthData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimArcLengthData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimArcLengthData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RDimArcLengthData RJSHelper_qcad::js2cpp_RDimArcLengthData(RJSApi& handler, const QJSValue& v) {
          /*
          RDimArcLengthData_Wrapper* wrapper = getWrapper<RDimArcLengthData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimArcLengthData: no wrapper";
              Q_ASSERT(false);
              return RDimArcLengthData();
          }
          //return *(RDimArcLengthData*)wrapper->getWrappedVoid();
          RDimArcLengthData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RDimArcLengthData: wrapped pointer is NULL";
              return RDimArcLengthData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimArcLengthData: not a QObject";
              return RDimArcLengthData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimArcLengthData_ptr: no wrapper";
              return RDimArcLengthData();
          }
          //RDimArcLengthData* ret = getWrapped_RDimArcLengthData(wrapper);
          RDimArcLengthData* ret = RDimArcLengthData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RDimArcLengthData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RDimArcLengthData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimArcLengthData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RDimArcLengthData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimDiametricData(RJSApi& handler, const RDimDiametricData* v) {
          QJSEngine* engine = handler.getEngine();
          RDimDiametricData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RDimDiametricData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RDimDiametricData object:
              ret = new RDimDiametricData_Wrapper(handler, new RDimDiametricData(*v), true);
          }

          // JS: new RDimDiametricData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimDiametricData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimDiametricData is undefined. Use RDimDiametricData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimDiametricData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimDiametricData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RDimDiametricData(RJSApi& handler, const RDimDiametricData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RDimDiametricData object:
          RDimDiametricData_Wrapper* ret = new RDimDiametricData_Wrapper(handler, new RDimDiametricData(v), true);

          // JS: new RDimDiametricData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimDiametricData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimDiametricData is undefined. Use RDimDiametricData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimDiametricData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimDiametricData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RDimDiametricData RJSHelper_qcad::js2cpp_RDimDiametricData(RJSApi& handler, const QJSValue& v) {
          /*
          RDimDiametricData_Wrapper* wrapper = getWrapper<RDimDiametricData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimDiametricData: no wrapper";
              Q_ASSERT(false);
              return RDimDiametricData();
          }
          //return *(RDimDiametricData*)wrapper->getWrappedVoid();
          RDimDiametricData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RDimDiametricData: wrapped pointer is NULL";
              return RDimDiametricData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimDiametricData: not a QObject";
              return RDimDiametricData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimDiametricData_ptr: no wrapper";
              return RDimDiametricData();
          }
          //RDimDiametricData* ret = getWrapped_RDimDiametricData(wrapper);
          RDimDiametricData* ret = RDimDiametricData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RDimDiametricData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RDimDiametricData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimDiametricData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RDimDiametricData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimLinearData(RJSApi& handler, const RDimLinearData* v) {
          QJSEngine* engine = handler.getEngine();
          RDimLinearData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RDimLinearData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RDimLinearData object:
              ret = new RDimLinearData_Wrapper(handler, new RDimLinearData(*v), true);
          }

          // JS: new RDimLinearData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimLinearData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimLinearData is undefined. Use RDimLinearData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimLinearData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimLinearData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RDimLinearData(RJSApi& handler, const RDimLinearData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RDimLinearData object:
          RDimLinearData_Wrapper* ret = new RDimLinearData_Wrapper(handler, new RDimLinearData(v), true);

          // JS: new RDimLinearData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimLinearData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimLinearData is undefined. Use RDimLinearData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimLinearData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimLinearData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RDimLinearData RJSHelper_qcad::js2cpp_RDimLinearData(RJSApi& handler, const QJSValue& v) {
          /*
          RDimLinearData_Wrapper* wrapper = getWrapper<RDimLinearData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimLinearData: no wrapper";
              Q_ASSERT(false);
              return RDimLinearData();
          }
          //return *(RDimLinearData*)wrapper->getWrappedVoid();
          RDimLinearData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RDimLinearData: wrapped pointer is NULL";
              return RDimLinearData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimLinearData: not a QObject";
              return RDimLinearData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimLinearData_ptr: no wrapper";
              return RDimLinearData();
          }
          //RDimLinearData* ret = getWrapped_RDimLinearData(wrapper);
          RDimLinearData* ret = RDimLinearData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RDimLinearData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RDimLinearData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimLinearData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RDimLinearData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimOrdinateData(RJSApi& handler, const RDimOrdinateData* v) {
          QJSEngine* engine = handler.getEngine();
          RDimOrdinateData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RDimOrdinateData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RDimOrdinateData object:
              ret = new RDimOrdinateData_Wrapper(handler, new RDimOrdinateData(*v), true);
          }

          // JS: new RDimOrdinateData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimOrdinateData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimOrdinateData is undefined. Use RDimOrdinateData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimOrdinateData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimOrdinateData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RDimOrdinateData(RJSApi& handler, const RDimOrdinateData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RDimOrdinateData object:
          RDimOrdinateData_Wrapper* ret = new RDimOrdinateData_Wrapper(handler, new RDimOrdinateData(v), true);

          // JS: new RDimOrdinateData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimOrdinateData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimOrdinateData is undefined. Use RDimOrdinateData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimOrdinateData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimOrdinateData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RDimOrdinateData RJSHelper_qcad::js2cpp_RDimOrdinateData(RJSApi& handler, const QJSValue& v) {
          /*
          RDimOrdinateData_Wrapper* wrapper = getWrapper<RDimOrdinateData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimOrdinateData: no wrapper";
              Q_ASSERT(false);
              return RDimOrdinateData();
          }
          //return *(RDimOrdinateData*)wrapper->getWrappedVoid();
          RDimOrdinateData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RDimOrdinateData: wrapped pointer is NULL";
              return RDimOrdinateData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimOrdinateData: not a QObject";
              return RDimOrdinateData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimOrdinateData_ptr: no wrapper";
              return RDimOrdinateData();
          }
          //RDimOrdinateData* ret = getWrapped_RDimOrdinateData(wrapper);
          RDimOrdinateData* ret = RDimOrdinateData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RDimOrdinateData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RDimOrdinateData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimOrdinateData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RDimOrdinateData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimRadialData(RJSApi& handler, const RDimRadialData* v) {
          QJSEngine* engine = handler.getEngine();
          RDimRadialData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RDimRadialData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RDimRadialData object:
              ret = new RDimRadialData_Wrapper(handler, new RDimRadialData(*v), true);
          }

          // JS: new RDimRadialData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimRadialData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimRadialData is undefined. Use RDimRadialData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimRadialData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimRadialData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RDimRadialData(RJSApi& handler, const RDimRadialData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RDimRadialData object:
          RDimRadialData_Wrapper* ret = new RDimRadialData_Wrapper(handler, new RDimRadialData(v), true);

          // JS: new RDimRadialData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimRadialData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimRadialData is undefined. Use RDimRadialData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimRadialData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimRadialData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RDimRadialData RJSHelper_qcad::js2cpp_RDimRadialData(RJSApi& handler, const QJSValue& v) {
          /*
          RDimRadialData_Wrapper* wrapper = getWrapper<RDimRadialData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimRadialData: no wrapper";
              Q_ASSERT(false);
              return RDimRadialData();
          }
          //return *(RDimRadialData*)wrapper->getWrappedVoid();
          RDimRadialData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RDimRadialData: wrapped pointer is NULL";
              return RDimRadialData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimRadialData: not a QObject";
              return RDimRadialData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimRadialData_ptr: no wrapper";
              return RDimRadialData();
          }
          //RDimRadialData* ret = getWrapped_RDimRadialData(wrapper);
          RDimRadialData* ret = RDimRadialData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RDimRadialData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RDimRadialData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimRadialData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RDimRadialData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimRotatedData(RJSApi& handler, const RDimRotatedData* v) {
          QJSEngine* engine = handler.getEngine();
          RDimRotatedData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RDimRotatedData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RDimRotatedData object:
              ret = new RDimRotatedData_Wrapper(handler, new RDimRotatedData(*v), true);
          }

          // JS: new RDimRotatedData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimRotatedData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimRotatedData is undefined. Use RDimRotatedData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimRotatedData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimRotatedData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RDimRotatedData(RJSApi& handler, const RDimRotatedData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RDimRotatedData object:
          RDimRotatedData_Wrapper* ret = new RDimRotatedData_Wrapper(handler, new RDimRotatedData(v), true);

          // JS: new RDimRotatedData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimRotatedData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimRotatedData is undefined. Use RDimRotatedData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimRotatedData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimRotatedData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RDimRotatedData RJSHelper_qcad::js2cpp_RDimRotatedData(RJSApi& handler, const QJSValue& v) {
          /*
          RDimRotatedData_Wrapper* wrapper = getWrapper<RDimRotatedData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimRotatedData: no wrapper";
              Q_ASSERT(false);
              return RDimRotatedData();
          }
          //return *(RDimRotatedData*)wrapper->getWrappedVoid();
          RDimRotatedData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RDimRotatedData: wrapped pointer is NULL";
              return RDimRotatedData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimRotatedData: not a QObject";
              return RDimRotatedData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimRotatedData_ptr: no wrapper";
              return RDimRotatedData();
          }
          //RDimRotatedData* ret = getWrapped_RDimRotatedData(wrapper);
          RDimRotatedData* ret = RDimRotatedData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RDimRotatedData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RDimRotatedData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimRotatedData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RDimRotatedData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimStyleData(RJSApi& handler, const RDimStyleData* v) {
          QJSEngine* engine = handler.getEngine();
          RDimStyleData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RDimStyleData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RDimStyleData object:
              ret = new RDimStyleData_Wrapper(handler, new RDimStyleData(*v), true);
          }

          // JS: new RDimStyleData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimStyleData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimStyleData is undefined. Use RDimStyleData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimStyleData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimStyleData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RDimStyleData(RJSApi& handler, const RDimStyleData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RDimStyleData object:
          RDimStyleData_Wrapper* ret = new RDimStyleData_Wrapper(handler, new RDimStyleData(v), true);

          // JS: new RDimStyleData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimStyleData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimStyleData is undefined. Use RDimStyleData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimStyleData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimStyleData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RDimStyleData RJSHelper_qcad::js2cpp_RDimStyleData(RJSApi& handler, const QJSValue& v) {
          /*
          RDimStyleData_Wrapper* wrapper = getWrapper<RDimStyleData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimStyleData: no wrapper";
              Q_ASSERT(false);
              return RDimStyleData();
          }
          //return *(RDimStyleData*)wrapper->getWrappedVoid();
          RDimStyleData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RDimStyleData: wrapped pointer is NULL";
              return RDimStyleData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimStyleData: not a QObject";
              return RDimStyleData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimStyleData_ptr: no wrapper";
              return RDimStyleData();
          }
          //RDimStyleData* ret = getWrapped_RDimStyleData(wrapper);
          RDimStyleData* ret = RDimStyleData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RDimStyleData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RDimStyleData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimStyleData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RDimStyleData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDxfServices(RJSApi& handler, const RDxfServices* v) {
          QJSEngine* engine = handler.getEngine();
          RDxfServices_Wrapper* ret;

          if (v==nullptr) {
              ret = new RDxfServices_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RDxfServices object:
              ret = new RDxfServices_Wrapper(handler, new RDxfServices(*v), true);
          }

          // JS: new RDxfServices('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDxfServices");
          if (cl.isUndefined()) {
              qWarning() << "Class RDxfServices is undefined. Use RDxfServices_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDxfServices('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDxfServices(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RDxfServices(RJSApi& handler, const RDxfServices& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RDxfServices object:
          RDxfServices_Wrapper* ret = new RDxfServices_Wrapper(handler, new RDxfServices(v), true);

          // JS: new RDxfServices('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDxfServices");
          if (cl.isUndefined()) {
              qWarning() << "Class RDxfServices is undefined. Use RDxfServices_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDxfServices('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDxfServices(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RDxfServices RJSHelper_qcad::js2cpp_RDxfServices(RJSApi& handler, const QJSValue& v) {
          /*
          RDxfServices_Wrapper* wrapper = getWrapper<RDxfServices_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDxfServices: no wrapper";
              Q_ASSERT(false);
              return RDxfServices();
          }
          //return *(RDxfServices*)wrapper->getWrappedVoid();
          RDxfServices* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RDxfServices: wrapped pointer is NULL";
              return RDxfServices();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDxfServices: not a QObject";
              return RDxfServices();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDxfServices_ptr: no wrapper";
              return RDxfServices();
          }
          //RDxfServices* ret = getWrapped_RDxfServices(wrapper);
          RDxfServices* ret = RDxfServices_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RDxfServices();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RDxfServices(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDxfServices: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RDxfServices::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_REllipse(RJSApi& handler, const REllipse* v) {
          QJSEngine* engine = handler.getEngine();
          REllipse_Wrapper* ret;

          if (v==nullptr) {
              ret = new REllipse_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of REllipse object:
              ret = new REllipse_Wrapper(handler, new REllipse(*v), true);
          }

          // JS: new REllipse('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("REllipse");
          if (cl.isUndefined()) {
              qWarning() << "Class REllipse is undefined. Use REllipse_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new REllipse('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new REllipse(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_REllipse(RJSApi& handler, const REllipse& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the REllipse object:
          REllipse_Wrapper* ret = new REllipse_Wrapper(handler, new REllipse(v), true);

          // JS: new REllipse('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("REllipse");
          if (cl.isUndefined()) {
              qWarning() << "Class REllipse is undefined. Use REllipse_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new REllipse('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new REllipse(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      REllipse RJSHelper_qcad::js2cpp_REllipse(RJSApi& handler, const QJSValue& v) {
          /*
          REllipse_Wrapper* wrapper = getWrapper<REllipse_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_REllipse: no wrapper";
              Q_ASSERT(false);
              return REllipse();
          }
          //return *(REllipse*)wrapper->getWrappedVoid();
          REllipse* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_REllipse: wrapped pointer is NULL";
              return REllipse();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_REllipse: not a QObject";
              return REllipse();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_REllipse_ptr: no wrapper";
              return REllipse();
          }
          //REllipse* ret = getWrapped_REllipse(wrapper);
          REllipse* ret = REllipse_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return REllipse();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_REllipse(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_REllipse: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_REllipse::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_REllipseData(RJSApi& handler, const REllipseData* v) {
          QJSEngine* engine = handler.getEngine();
          REllipseData_Wrapper* ret;

          if (v==nullptr) {
              ret = new REllipseData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of REllipseData object:
              ret = new REllipseData_Wrapper(handler, new REllipseData(*v), true);
          }

          // JS: new REllipseData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("REllipseData");
          if (cl.isUndefined()) {
              qWarning() << "Class REllipseData is undefined. Use REllipseData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new REllipseData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new REllipseData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_REllipseData(RJSApi& handler, const REllipseData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the REllipseData object:
          REllipseData_Wrapper* ret = new REllipseData_Wrapper(handler, new REllipseData(v), true);

          // JS: new REllipseData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("REllipseData");
          if (cl.isUndefined()) {
              qWarning() << "Class REllipseData is undefined. Use REllipseData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new REllipseData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new REllipseData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      REllipseData RJSHelper_qcad::js2cpp_REllipseData(RJSApi& handler, const QJSValue& v) {
          /*
          REllipseData_Wrapper* wrapper = getWrapper<REllipseData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_REllipseData: no wrapper";
              Q_ASSERT(false);
              return REllipseData();
          }
          //return *(REllipseData*)wrapper->getWrappedVoid();
          REllipseData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_REllipseData: wrapped pointer is NULL";
              return REllipseData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_REllipseData: not a QObject";
              return REllipseData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_REllipseData_ptr: no wrapper";
              return REllipseData();
          }
          //REllipseData* ret = getWrapped_REllipseData(wrapper);
          REllipseData* ret = REllipseData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return REllipseData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_REllipseData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_REllipseData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_REllipseData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFaceData(RJSApi& handler, const RFaceData* v) {
          QJSEngine* engine = handler.getEngine();
          RFaceData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RFaceData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RFaceData object:
              ret = new RFaceData_Wrapper(handler, new RFaceData(*v), true);
          }

          // JS: new RFaceData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFaceData");
          if (cl.isUndefined()) {
              qWarning() << "Class RFaceData is undefined. Use RFaceData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFaceData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFaceData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RFaceData(RJSApi& handler, const RFaceData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RFaceData object:
          RFaceData_Wrapper* ret = new RFaceData_Wrapper(handler, new RFaceData(v), true);

          // JS: new RFaceData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFaceData");
          if (cl.isUndefined()) {
              qWarning() << "Class RFaceData is undefined. Use RFaceData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFaceData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFaceData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RFaceData RJSHelper_qcad::js2cpp_RFaceData(RJSApi& handler, const QJSValue& v) {
          /*
          RFaceData_Wrapper* wrapper = getWrapper<RFaceData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFaceData: no wrapper";
              Q_ASSERT(false);
              return RFaceData();
          }
          //return *(RFaceData*)wrapper->getWrappedVoid();
          RFaceData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RFaceData: wrapped pointer is NULL";
              return RFaceData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFaceData: not a QObject";
              return RFaceData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFaceData_ptr: no wrapper";
              return RFaceData();
          }
          //RFaceData* ret = getWrapped_RFaceData(wrapper);
          RFaceData* ret = RFaceData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RFaceData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RFaceData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFaceData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RFaceData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFileCache(RJSApi& handler, const RFileCache* v) {
          QJSEngine* engine = handler.getEngine();
          RFileCache_Wrapper* ret;

          if (v==nullptr) {
              ret = new RFileCache_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RFileCache object:
              ret = new RFileCache_Wrapper(handler, new RFileCache(*v), true);
          }

          // JS: new RFileCache('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileCache");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileCache is undefined. Use RFileCache_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileCache('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileCache(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RFileCache(RJSApi& handler, const RFileCache& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RFileCache object:
          RFileCache_Wrapper* ret = new RFileCache_Wrapper(handler, new RFileCache(v), true);

          // JS: new RFileCache('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileCache");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileCache is undefined. Use RFileCache_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileCache('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileCache(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RFileCache RJSHelper_qcad::js2cpp_RFileCache(RJSApi& handler, const QJSValue& v) {
          /*
          RFileCache_Wrapper* wrapper = getWrapper<RFileCache_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileCache: no wrapper";
              Q_ASSERT(false);
              return RFileCache();
          }
          //return *(RFileCache*)wrapper->getWrappedVoid();
          RFileCache* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RFileCache: wrapped pointer is NULL";
              return RFileCache();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFileCache: not a QObject";
              return RFileCache();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileCache_ptr: no wrapper";
              return RFileCache();
          }
          //RFileCache* ret = getWrapped_RFileCache(wrapper);
          RFileCache* ret = RFileCache_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RFileCache();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RFileCache(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFileCache: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RFileCache::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFileExporterAdapter(RJSApi& handler, const RFileExporterAdapter* v) {
          QJSEngine* engine = handler.getEngine();
          RFileExporterAdapter_Wrapper* ret;

          if (v==nullptr) {
              ret = new RFileExporterAdapter_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RFileExporterAdapter object:
              ret = new RFileExporterAdapter_Wrapper(handler, new RFileExporterAdapter(*v), true);
          }

          // JS: new RFileExporterAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileExporterAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileExporterAdapter is undefined. Use RFileExporterAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileExporterAdapter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileExporterAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RFileExporterAdapter(RJSApi& handler, const RFileExporterAdapter& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RFileExporterAdapter object:
          RFileExporterAdapter_Wrapper* ret = new RFileExporterAdapter_Wrapper(handler, new RFileExporterAdapter(v), true);

          // JS: new RFileExporterAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileExporterAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileExporterAdapter is undefined. Use RFileExporterAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileExporterAdapter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileExporterAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RFileExporterAdapter RJSHelper_qcad::js2cpp_RFileExporterAdapter(RJSApi& handler, const QJSValue& v) {
          /*
          RFileExporterAdapter_Wrapper* wrapper = getWrapper<RFileExporterAdapter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileExporterAdapter: no wrapper";
              Q_ASSERT(false);
              return RFileExporterAdapter();
          }
          //return *(RFileExporterAdapter*)wrapper->getWrappedVoid();
          RFileExporterAdapter* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RFileExporterAdapter: wrapped pointer is NULL";
              return RFileExporterAdapter();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFileExporterAdapter: not a QObject";
              return RFileExporterAdapter();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileExporterAdapter_ptr: no wrapper";
              return RFileExporterAdapter();
          }
          //RFileExporterAdapter* ret = getWrapped_RFileExporterAdapter(wrapper);
          RFileExporterAdapter* ret = RFileExporterAdapter_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RFileExporterAdapter();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RFileExporterAdapter(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFileExporterAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RFileExporterAdapter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFileExporterFactoryAdapter(RJSApi& handler, const RFileExporterFactoryAdapter* v) {
          QJSEngine* engine = handler.getEngine();
          RFileExporterFactoryAdapter_Wrapper* ret;

          if (v==nullptr) {
              ret = new RFileExporterFactoryAdapter_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RFileExporterFactoryAdapter object:
              ret = new RFileExporterFactoryAdapter_Wrapper(handler, new RFileExporterFactoryAdapter(*v), true);
          }

          // JS: new RFileExporterFactoryAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileExporterFactoryAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileExporterFactoryAdapter is undefined. Use RFileExporterFactoryAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileExporterFactoryAdapter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileExporterFactoryAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RFileExporterFactoryAdapter(RJSApi& handler, const RFileExporterFactoryAdapter& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RFileExporterFactoryAdapter object:
          RFileExporterFactoryAdapter_Wrapper* ret = new RFileExporterFactoryAdapter_Wrapper(handler, new RFileExporterFactoryAdapter(v), true);

          // JS: new RFileExporterFactoryAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileExporterFactoryAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileExporterFactoryAdapter is undefined. Use RFileExporterFactoryAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileExporterFactoryAdapter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileExporterFactoryAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RFileExporterFactoryAdapter RJSHelper_qcad::js2cpp_RFileExporterFactoryAdapter(RJSApi& handler, const QJSValue& v) {
          /*
          RFileExporterFactoryAdapter_Wrapper* wrapper = getWrapper<RFileExporterFactoryAdapter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileExporterFactoryAdapter: no wrapper";
              Q_ASSERT(false);
              return RFileExporterFactoryAdapter();
          }
          //return *(RFileExporterFactoryAdapter*)wrapper->getWrappedVoid();
          RFileExporterFactoryAdapter* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RFileExporterFactoryAdapter: wrapped pointer is NULL";
              return RFileExporterFactoryAdapter();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFileExporterFactoryAdapter: not a QObject";
              return RFileExporterFactoryAdapter();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileExporterFactoryAdapter_ptr: no wrapper";
              return RFileExporterFactoryAdapter();
          }
          //RFileExporterFactoryAdapter* ret = getWrapped_RFileExporterFactoryAdapter(wrapper);
          RFileExporterFactoryAdapter* ret = RFileExporterFactoryAdapter_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RFileExporterFactoryAdapter();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RFileExporterFactoryAdapter(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFileExporterFactoryAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RFileExporterFactoryAdapter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFileExporterRegistry(RJSApi& handler, const RFileExporterRegistry* v) {
          QJSEngine* engine = handler.getEngine();
          RFileExporterRegistry_Wrapper* ret;

          if (v==nullptr) {
              ret = new RFileExporterRegistry_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RFileExporterRegistry object:
              ret = new RFileExporterRegistry_Wrapper(handler, new RFileExporterRegistry(*v), true);
          }

          // JS: new RFileExporterRegistry('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileExporterRegistry");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileExporterRegistry is undefined. Use RFileExporterRegistry_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileExporterRegistry('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileExporterRegistry(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RFileExporterRegistry(RJSApi& handler, const RFileExporterRegistry& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RFileExporterRegistry object:
          RFileExporterRegistry_Wrapper* ret = new RFileExporterRegistry_Wrapper(handler, new RFileExporterRegistry(v), true);

          // JS: new RFileExporterRegistry('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileExporterRegistry");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileExporterRegistry is undefined. Use RFileExporterRegistry_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileExporterRegistry('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileExporterRegistry(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RFileExporterRegistry RJSHelper_qcad::js2cpp_RFileExporterRegistry(RJSApi& handler, const QJSValue& v) {
          /*
          RFileExporterRegistry_Wrapper* wrapper = getWrapper<RFileExporterRegistry_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileExporterRegistry: no wrapper";
              Q_ASSERT(false);
              return RFileExporterRegistry();
          }
          //return *(RFileExporterRegistry*)wrapper->getWrappedVoid();
          RFileExporterRegistry* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RFileExporterRegistry: wrapped pointer is NULL";
              return RFileExporterRegistry();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFileExporterRegistry: not a QObject";
              return RFileExporterRegistry();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileExporterRegistry_ptr: no wrapper";
              return RFileExporterRegistry();
          }
          //RFileExporterRegistry* ret = getWrapped_RFileExporterRegistry(wrapper);
          RFileExporterRegistry* ret = RFileExporterRegistry_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RFileExporterRegistry();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RFileExporterRegistry(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFileExporterRegistry: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RFileExporterRegistry::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFileImporterAdapter(RJSApi& handler, const RFileImporterAdapter* v) {
          QJSEngine* engine = handler.getEngine();
          RFileImporterAdapter_Wrapper* ret;

          if (v==nullptr) {
              ret = new RFileImporterAdapter_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RFileImporterAdapter object:
              ret = new RFileImporterAdapter_Wrapper(handler, new RFileImporterAdapter(*v), true);
          }

          // JS: new RFileImporterAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileImporterAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileImporterAdapter is undefined. Use RFileImporterAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileImporterAdapter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileImporterAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RFileImporterAdapter(RJSApi& handler, const RFileImporterAdapter& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RFileImporterAdapter object:
          RFileImporterAdapter_Wrapper* ret = new RFileImporterAdapter_Wrapper(handler, new RFileImporterAdapter(v), true);

          // JS: new RFileImporterAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileImporterAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileImporterAdapter is undefined. Use RFileImporterAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileImporterAdapter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileImporterAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RFileImporterAdapter RJSHelper_qcad::js2cpp_RFileImporterAdapter(RJSApi& handler, const QJSValue& v) {
          /*
          RFileImporterAdapter_Wrapper* wrapper = getWrapper<RFileImporterAdapter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileImporterAdapter: no wrapper";
              Q_ASSERT(false);
              return RFileImporterAdapter();
          }
          //return *(RFileImporterAdapter*)wrapper->getWrappedVoid();
          RFileImporterAdapter* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RFileImporterAdapter: wrapped pointer is NULL";
              return RFileImporterAdapter();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFileImporterAdapter: not a QObject";
              return RFileImporterAdapter();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileImporterAdapter_ptr: no wrapper";
              return RFileImporterAdapter();
          }
          //RFileImporterAdapter* ret = getWrapped_RFileImporterAdapter(wrapper);
          RFileImporterAdapter* ret = RFileImporterAdapter_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RFileImporterAdapter();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RFileImporterAdapter(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFileImporterAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RFileImporterAdapter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFileImporterFactoryAdapter(RJSApi& handler, const RFileImporterFactoryAdapter* v) {
          QJSEngine* engine = handler.getEngine();
          RFileImporterFactoryAdapter_Wrapper* ret;

          if (v==nullptr) {
              ret = new RFileImporterFactoryAdapter_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RFileImporterFactoryAdapter object:
              ret = new RFileImporterFactoryAdapter_Wrapper(handler, new RFileImporterFactoryAdapter(*v), true);
          }

          // JS: new RFileImporterFactoryAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileImporterFactoryAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileImporterFactoryAdapter is undefined. Use RFileImporterFactoryAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileImporterFactoryAdapter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileImporterFactoryAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RFileImporterFactoryAdapter(RJSApi& handler, const RFileImporterFactoryAdapter& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RFileImporterFactoryAdapter object:
          RFileImporterFactoryAdapter_Wrapper* ret = new RFileImporterFactoryAdapter_Wrapper(handler, new RFileImporterFactoryAdapter(v), true);

          // JS: new RFileImporterFactoryAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileImporterFactoryAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileImporterFactoryAdapter is undefined. Use RFileImporterFactoryAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileImporterFactoryAdapter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileImporterFactoryAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RFileImporterFactoryAdapter RJSHelper_qcad::js2cpp_RFileImporterFactoryAdapter(RJSApi& handler, const QJSValue& v) {
          /*
          RFileImporterFactoryAdapter_Wrapper* wrapper = getWrapper<RFileImporterFactoryAdapter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileImporterFactoryAdapter: no wrapper";
              Q_ASSERT(false);
              return RFileImporterFactoryAdapter();
          }
          //return *(RFileImporterFactoryAdapter*)wrapper->getWrappedVoid();
          RFileImporterFactoryAdapter* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RFileImporterFactoryAdapter: wrapped pointer is NULL";
              return RFileImporterFactoryAdapter();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFileImporterFactoryAdapter: not a QObject";
              return RFileImporterFactoryAdapter();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileImporterFactoryAdapter_ptr: no wrapper";
              return RFileImporterFactoryAdapter();
          }
          //RFileImporterFactoryAdapter* ret = getWrapped_RFileImporterFactoryAdapter(wrapper);
          RFileImporterFactoryAdapter* ret = RFileImporterFactoryAdapter_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RFileImporterFactoryAdapter();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RFileImporterFactoryAdapter(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFileImporterFactoryAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RFileImporterFactoryAdapter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFileImporterRegistry(RJSApi& handler, const RFileImporterRegistry* v) {
          QJSEngine* engine = handler.getEngine();
          RFileImporterRegistry_Wrapper* ret;

          if (v==nullptr) {
              ret = new RFileImporterRegistry_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RFileImporterRegistry object:
              ret = new RFileImporterRegistry_Wrapper(handler, new RFileImporterRegistry(*v), true);
          }

          // JS: new RFileImporterRegistry('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileImporterRegistry");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileImporterRegistry is undefined. Use RFileImporterRegistry_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileImporterRegistry('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileImporterRegistry(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RFileImporterRegistry(RJSApi& handler, const RFileImporterRegistry& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RFileImporterRegistry object:
          RFileImporterRegistry_Wrapper* ret = new RFileImporterRegistry_Wrapper(handler, new RFileImporterRegistry(v), true);

          // JS: new RFileImporterRegistry('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileImporterRegistry");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileImporterRegistry is undefined. Use RFileImporterRegistry_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileImporterRegistry('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileImporterRegistry(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RFileImporterRegistry RJSHelper_qcad::js2cpp_RFileImporterRegistry(RJSApi& handler, const QJSValue& v) {
          /*
          RFileImporterRegistry_Wrapper* wrapper = getWrapper<RFileImporterRegistry_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileImporterRegistry: no wrapper";
              Q_ASSERT(false);
              return RFileImporterRegistry();
          }
          //return *(RFileImporterRegistry*)wrapper->getWrappedVoid();
          RFileImporterRegistry* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RFileImporterRegistry: wrapped pointer is NULL";
              return RFileImporterRegistry();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFileImporterRegistry: not a QObject";
              return RFileImporterRegistry();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileImporterRegistry_ptr: no wrapper";
              return RFileImporterRegistry();
          }
          //RFileImporterRegistry* ret = getWrapped_RFileImporterRegistry(wrapper);
          RFileImporterRegistry* ret = RFileImporterRegistry_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RFileImporterRegistry();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RFileImporterRegistry(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFileImporterRegistry: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RFileImporterRegistry::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFont(RJSApi& handler, const RFont* v) {
          QJSEngine* engine = handler.getEngine();
          RFont_Wrapper* ret;

          if (v==nullptr) {
              ret = new RFont_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RFont object:
              ret = new RFont_Wrapper(handler, new RFont(*v), true);
          }

          // JS: new RFont('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFont");
          if (cl.isUndefined()) {
              qWarning() << "Class RFont is undefined. Use RFont_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFont('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFont(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RFont(RJSApi& handler, const RFont& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RFont object:
          RFont_Wrapper* ret = new RFont_Wrapper(handler, new RFont(v), true);

          // JS: new RFont('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFont");
          if (cl.isUndefined()) {
              qWarning() << "Class RFont is undefined. Use RFont_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFont('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFont(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RFont RJSHelper_qcad::js2cpp_RFont(RJSApi& handler, const QJSValue& v) {
          /*
          RFont_Wrapper* wrapper = getWrapper<RFont_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFont: no wrapper";
              Q_ASSERT(false);
              return RFont();
          }
          //return *(RFont*)wrapper->getWrappedVoid();
          RFont* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RFont: wrapped pointer is NULL";
              return RFont();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFont: not a QObject";
              return RFont();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFont_ptr: no wrapper";
              return RFont();
          }
          //RFont* ret = getWrapped_RFont(wrapper);
          RFont* ret = RFont_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RFont();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RFont(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFont: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RFont::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFontList(RJSApi& handler, const RFontList* v) {
          QJSEngine* engine = handler.getEngine();
          RFontList_Wrapper* ret;

          if (v==nullptr) {
              ret = new RFontList_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RFontList object:
              ret = new RFontList_Wrapper(handler, new RFontList(*v), true);
          }

          // JS: new RFontList('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFontList");
          if (cl.isUndefined()) {
              qWarning() << "Class RFontList is undefined. Use RFontList_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFontList('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFontList(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RFontList(RJSApi& handler, const RFontList& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RFontList object:
          RFontList_Wrapper* ret = new RFontList_Wrapper(handler, new RFontList(v), true);

          // JS: new RFontList('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFontList");
          if (cl.isUndefined()) {
              qWarning() << "Class RFontList is undefined. Use RFontList_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFontList('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFontList(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RFontList RJSHelper_qcad::js2cpp_RFontList(RJSApi& handler, const QJSValue& v) {
          /*
          RFontList_Wrapper* wrapper = getWrapper<RFontList_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFontList: no wrapper";
              Q_ASSERT(false);
              return RFontList();
          }
          //return *(RFontList*)wrapper->getWrappedVoid();
          RFontList* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RFontList: wrapped pointer is NULL";
              return RFontList();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFontList: not a QObject";
              return RFontList();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFontList_ptr: no wrapper";
              return RFontList();
          }
          //RFontList* ret = getWrapped_RFontList(wrapper);
          RFontList* ret = RFontList_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RFontList();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RFontList(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFontList: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RFontList::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RGraphicsSceneDrawable(RJSApi& handler, const RGraphicsSceneDrawable* v) {
          QJSEngine* engine = handler.getEngine();
          RGraphicsSceneDrawable_Wrapper* ret;

          if (v==nullptr) {
              ret = new RGraphicsSceneDrawable_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RGraphicsSceneDrawable object:
              ret = new RGraphicsSceneDrawable_Wrapper(handler, new RGraphicsSceneDrawable(*v), true);
          }

          // JS: new RGraphicsSceneDrawable('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RGraphicsSceneDrawable");
          if (cl.isUndefined()) {
              qWarning() << "Class RGraphicsSceneDrawable is undefined. Use RGraphicsSceneDrawable_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RGraphicsSceneDrawable('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RGraphicsSceneDrawable(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RGraphicsSceneDrawable(RJSApi& handler, const RGraphicsSceneDrawable& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RGraphicsSceneDrawable object:
          RGraphicsSceneDrawable_Wrapper* ret = new RGraphicsSceneDrawable_Wrapper(handler, new RGraphicsSceneDrawable(v), true);

          // JS: new RGraphicsSceneDrawable('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RGraphicsSceneDrawable");
          if (cl.isUndefined()) {
              qWarning() << "Class RGraphicsSceneDrawable is undefined. Use RGraphicsSceneDrawable_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RGraphicsSceneDrawable('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RGraphicsSceneDrawable(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RGraphicsSceneDrawable RJSHelper_qcad::js2cpp_RGraphicsSceneDrawable(RJSApi& handler, const QJSValue& v) {
          /*
          RGraphicsSceneDrawable_Wrapper* wrapper = getWrapper<RGraphicsSceneDrawable_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RGraphicsSceneDrawable: no wrapper";
              Q_ASSERT(false);
              return RGraphicsSceneDrawable();
          }
          //return *(RGraphicsSceneDrawable*)wrapper->getWrappedVoid();
          RGraphicsSceneDrawable* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RGraphicsSceneDrawable: wrapped pointer is NULL";
              return RGraphicsSceneDrawable();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RGraphicsSceneDrawable: not a QObject";
              return RGraphicsSceneDrawable();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RGraphicsSceneDrawable_ptr: no wrapper";
              return RGraphicsSceneDrawable();
          }
          //RGraphicsSceneDrawable* ret = getWrapped_RGraphicsSceneDrawable(wrapper);
          RGraphicsSceneDrawable* ret = RGraphicsSceneDrawable_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RGraphicsSceneDrawable();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RGraphicsSceneDrawable(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RGraphicsSceneDrawable: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RGraphicsSceneDrawable::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RHatchData(RJSApi& handler, const RHatchData* v) {
          QJSEngine* engine = handler.getEngine();
          RHatchData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RHatchData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RHatchData object:
              ret = new RHatchData_Wrapper(handler, new RHatchData(*v), true);
          }

          // JS: new RHatchData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RHatchData");
          if (cl.isUndefined()) {
              qWarning() << "Class RHatchData is undefined. Use RHatchData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RHatchData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RHatchData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RHatchData(RJSApi& handler, const RHatchData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RHatchData object:
          RHatchData_Wrapper* ret = new RHatchData_Wrapper(handler, new RHatchData(v), true);

          // JS: new RHatchData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RHatchData");
          if (cl.isUndefined()) {
              qWarning() << "Class RHatchData is undefined. Use RHatchData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RHatchData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RHatchData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RHatchData RJSHelper_qcad::js2cpp_RHatchData(RJSApi& handler, const QJSValue& v) {
          /*
          RHatchData_Wrapper* wrapper = getWrapper<RHatchData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RHatchData: no wrapper";
              Q_ASSERT(false);
              return RHatchData();
          }
          //return *(RHatchData*)wrapper->getWrappedVoid();
          RHatchData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RHatchData: wrapped pointer is NULL";
              return RHatchData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RHatchData: not a QObject";
              return RHatchData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RHatchData_ptr: no wrapper";
              return RHatchData();
          }
          //RHatchData* ret = getWrapped_RHatchData(wrapper);
          RHatchData* ret = RHatchData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RHatchData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RHatchData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RHatchData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RHatchData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RImageData(RJSApi& handler, const RImageData* v) {
          QJSEngine* engine = handler.getEngine();
          RImageData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RImageData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RImageData object:
              ret = new RImageData_Wrapper(handler, new RImageData(*v), true);
          }

          // JS: new RImageData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RImageData");
          if (cl.isUndefined()) {
              qWarning() << "Class RImageData is undefined. Use RImageData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RImageData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RImageData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RImageData(RJSApi& handler, const RImageData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RImageData object:
          RImageData_Wrapper* ret = new RImageData_Wrapper(handler, new RImageData(v), true);

          // JS: new RImageData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RImageData");
          if (cl.isUndefined()) {
              qWarning() << "Class RImageData is undefined. Use RImageData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RImageData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RImageData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RImageData RJSHelper_qcad::js2cpp_RImageData(RJSApi& handler, const QJSValue& v) {
          /*
          RImageData_Wrapper* wrapper = getWrapper<RImageData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RImageData: no wrapper";
              Q_ASSERT(false);
              return RImageData();
          }
          //return *(RImageData*)wrapper->getWrappedVoid();
          RImageData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RImageData: wrapped pointer is NULL";
              return RImageData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RImageData: not a QObject";
              return RImageData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RImageData_ptr: no wrapper";
              return RImageData();
          }
          //RImageData* ret = getWrapped_RImageData(wrapper);
          RImageData* ret = RImageData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RImageData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RImageData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RImageData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RImageData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLeaderData(RJSApi& handler, const RLeaderData* v) {
          QJSEngine* engine = handler.getEngine();
          RLeaderData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RLeaderData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RLeaderData object:
              ret = new RLeaderData_Wrapper(handler, new RLeaderData(*v), true);
          }

          // JS: new RLeaderData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLeaderData");
          if (cl.isUndefined()) {
              qWarning() << "Class RLeaderData is undefined. Use RLeaderData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLeaderData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLeaderData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RLeaderData(RJSApi& handler, const RLeaderData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RLeaderData object:
          RLeaderData_Wrapper* ret = new RLeaderData_Wrapper(handler, new RLeaderData(v), true);

          // JS: new RLeaderData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLeaderData");
          if (cl.isUndefined()) {
              qWarning() << "Class RLeaderData is undefined. Use RLeaderData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLeaderData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLeaderData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RLeaderData RJSHelper_qcad::js2cpp_RLeaderData(RJSApi& handler, const QJSValue& v) {
          /*
          RLeaderData_Wrapper* wrapper = getWrapper<RLeaderData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLeaderData: no wrapper";
              Q_ASSERT(false);
              return RLeaderData();
          }
          //return *(RLeaderData*)wrapper->getWrappedVoid();
          RLeaderData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RLeaderData: wrapped pointer is NULL";
              return RLeaderData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLeaderData: not a QObject";
              return RLeaderData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLeaderData_ptr: no wrapper";
              return RLeaderData();
          }
          //RLeaderData* ret = getWrapped_RLeaderData(wrapper);
          RLeaderData* ret = RLeaderData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RLeaderData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RLeaderData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLeaderData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RLeaderData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLine(RJSApi& handler, const RLine* v) {
          QJSEngine* engine = handler.getEngine();
          RLine_Wrapper* ret;

          if (v==nullptr) {
              ret = new RLine_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RLine object:
              ret = new RLine_Wrapper(handler, new RLine(*v), true);
          }

          // JS: new RLine('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLine");
          if (cl.isUndefined()) {
              qWarning() << "Class RLine is undefined. Use RLine_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLine('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLine(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RLine(RJSApi& handler, const RLine& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RLine object:
          RLine_Wrapper* ret = new RLine_Wrapper(handler, new RLine(v), true);

          // JS: new RLine('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLine");
          if (cl.isUndefined()) {
              qWarning() << "Class RLine is undefined. Use RLine_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLine('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLine(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RLine RJSHelper_qcad::js2cpp_RLine(RJSApi& handler, const QJSValue& v) {
          /*
          RLine_Wrapper* wrapper = getWrapper<RLine_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLine: no wrapper";
              Q_ASSERT(false);
              return RLine();
          }
          //return *(RLine*)wrapper->getWrappedVoid();
          RLine* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RLine: wrapped pointer is NULL";
              return RLine();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLine: not a QObject";
              return RLine();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLine_ptr: no wrapper";
              return RLine();
          }
          //RLine* ret = getWrapped_RLine(wrapper);
          RLine* ret = RLine_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RLine();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RLine(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLine: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RLine::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLineData(RJSApi& handler, const RLineData* v) {
          QJSEngine* engine = handler.getEngine();
          RLineData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RLineData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RLineData object:
              ret = new RLineData_Wrapper(handler, new RLineData(*v), true);
          }

          // JS: new RLineData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLineData");
          if (cl.isUndefined()) {
              qWarning() << "Class RLineData is undefined. Use RLineData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLineData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLineData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RLineData(RJSApi& handler, const RLineData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RLineData object:
          RLineData_Wrapper* ret = new RLineData_Wrapper(handler, new RLineData(v), true);

          // JS: new RLineData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLineData");
          if (cl.isUndefined()) {
              qWarning() << "Class RLineData is undefined. Use RLineData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLineData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLineData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RLineData RJSHelper_qcad::js2cpp_RLineData(RJSApi& handler, const QJSValue& v) {
          /*
          RLineData_Wrapper* wrapper = getWrapper<RLineData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLineData: no wrapper";
              Q_ASSERT(false);
              return RLineData();
          }
          //return *(RLineData*)wrapper->getWrappedVoid();
          RLineData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RLineData: wrapped pointer is NULL";
              return RLineData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLineData: not a QObject";
              return RLineData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLineData_ptr: no wrapper";
              return RLineData();
          }
          //RLineData* ret = getWrapped_RLineData(wrapper);
          RLineData* ret = RLineData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RLineData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RLineData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLineData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RLineData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLinetypePattern(RJSApi& handler, const RLinetypePattern* v) {
          QJSEngine* engine = handler.getEngine();
          RLinetypePattern_Wrapper* ret;

          if (v==nullptr) {
              ret = new RLinetypePattern_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RLinetypePattern object:
              ret = new RLinetypePattern_Wrapper(handler, new RLinetypePattern(*v), true);
          }

          // JS: new RLinetypePattern('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLinetypePattern");
          if (cl.isUndefined()) {
              qWarning() << "Class RLinetypePattern is undefined. Use RLinetypePattern_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLinetypePattern('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLinetypePattern(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RLinetypePattern(RJSApi& handler, const RLinetypePattern& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RLinetypePattern object:
          RLinetypePattern_Wrapper* ret = new RLinetypePattern_Wrapper(handler, new RLinetypePattern(v), true);

          // JS: new RLinetypePattern('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLinetypePattern");
          if (cl.isUndefined()) {
              qWarning() << "Class RLinetypePattern is undefined. Use RLinetypePattern_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLinetypePattern('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLinetypePattern(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RLinetypePattern RJSHelper_qcad::js2cpp_RLinetypePattern(RJSApi& handler, const QJSValue& v) {
          /*
          RLinetypePattern_Wrapper* wrapper = getWrapper<RLinetypePattern_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLinetypePattern: no wrapper";
              Q_ASSERT(false);
              return RLinetypePattern();
          }
          //return *(RLinetypePattern*)wrapper->getWrappedVoid();
          RLinetypePattern* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RLinetypePattern: wrapped pointer is NULL";
              return RLinetypePattern();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLinetypePattern: not a QObject";
              return RLinetypePattern();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLinetypePattern_ptr: no wrapper";
              return RLinetypePattern();
          }
          //RLinetypePattern* ret = getWrapped_RLinetypePattern(wrapper);
          RLinetypePattern* ret = RLinetypePattern_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RLinetypePattern();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RLinetypePattern(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLinetypePattern: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RLinetypePattern::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLineweight(RJSApi& handler, const RLineweight* v) {
          QJSEngine* engine = handler.getEngine();
          RLineweight_Wrapper* ret;

          if (v==nullptr) {
              ret = new RLineweight_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RLineweight object:
              ret = new RLineweight_Wrapper(handler, new RLineweight(*v), true);
          }

          // JS: new RLineweight('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLineweight");
          if (cl.isUndefined()) {
              qWarning() << "Class RLineweight is undefined. Use RLineweight_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLineweight('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLineweight(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RLineweight(RJSApi& handler, const RLineweight& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RLineweight object:
          RLineweight_Wrapper* ret = new RLineweight_Wrapper(handler, new RLineweight(v), true);

          // JS: new RLineweight('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLineweight");
          if (cl.isUndefined()) {
              qWarning() << "Class RLineweight is undefined. Use RLineweight_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLineweight('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLineweight(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RLineweight RJSHelper_qcad::js2cpp_RLineweight(RJSApi& handler, const QJSValue& v) {
          /*
          RLineweight_Wrapper* wrapper = getWrapper<RLineweight_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLineweight: no wrapper";
              Q_ASSERT(false);
              return RLineweight();
          }
          //return *(RLineweight*)wrapper->getWrappedVoid();
          RLineweight* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RLineweight: wrapped pointer is NULL";
              return RLineweight();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLineweight: not a QObject";
              return RLineweight();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLineweight_ptr: no wrapper";
              return RLineweight();
          }
          //RLineweight* ret = getWrapped_RLineweight(wrapper);
          RLineweight* ret = RLineweight_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RLineweight();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RLineweight(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLineweight: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RLineweight::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RMath(RJSApi& handler, const RMath* v) {
          QJSEngine* engine = handler.getEngine();
          RMath_Wrapper* ret;

          if (v==nullptr) {
              ret = new RMath_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RMath object:
              ret = new RMath_Wrapper(handler, new RMath(*v), true);
          }

          // JS: new RMath('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMath");
          if (cl.isUndefined()) {
              qWarning() << "Class RMath is undefined. Use RMath_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMath('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMath(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RMath(RJSApi& handler, const RMath& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RMath object:
          RMath_Wrapper* ret = new RMath_Wrapper(handler, new RMath(v), true);

          // JS: new RMath('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMath");
          if (cl.isUndefined()) {
              qWarning() << "Class RMath is undefined. Use RMath_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMath('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMath(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RMath RJSHelper_qcad::js2cpp_RMath(RJSApi& handler, const QJSValue& v) {
          /*
          RMath_Wrapper* wrapper = getWrapper<RMath_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMath: no wrapper";
              Q_ASSERT(false);
              return RMath();
          }
          //return *(RMath*)wrapper->getWrappedVoid();
          RMath* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RMath: wrapped pointer is NULL";
              return RMath();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RMath: not a QObject";
              return RMath();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMath_ptr: no wrapper";
              return RMath();
          }
          //RMath* ret = getWrapped_RMath(wrapper);
          RMath* ret = RMath_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RMath();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RMath(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RMath: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RMath::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RMatrix(RJSApi& handler, const RMatrix* v) {
          QJSEngine* engine = handler.getEngine();
          RMatrix_Wrapper* ret;

          if (v==nullptr) {
              ret = new RMatrix_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RMatrix object:
              ret = new RMatrix_Wrapper(handler, new RMatrix(*v), true);
          }

          // JS: new RMatrix('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMatrix");
          if (cl.isUndefined()) {
              qWarning() << "Class RMatrix is undefined. Use RMatrix_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMatrix('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMatrix(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RMatrix(RJSApi& handler, const RMatrix& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RMatrix object:
          RMatrix_Wrapper* ret = new RMatrix_Wrapper(handler, new RMatrix(v), true);

          // JS: new RMatrix('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMatrix");
          if (cl.isUndefined()) {
              qWarning() << "Class RMatrix is undefined. Use RMatrix_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMatrix('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMatrix(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RMatrix RJSHelper_qcad::js2cpp_RMatrix(RJSApi& handler, const QJSValue& v) {
          /*
          RMatrix_Wrapper* wrapper = getWrapper<RMatrix_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMatrix: no wrapper";
              Q_ASSERT(false);
              return RMatrix();
          }
          //return *(RMatrix*)wrapper->getWrappedVoid();
          RMatrix* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RMatrix: wrapped pointer is NULL";
              return RMatrix();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RMatrix: not a QObject";
              return RMatrix();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMatrix_ptr: no wrapper";
              return RMatrix();
          }
          //RMatrix* ret = getWrapped_RMatrix(wrapper);
          RMatrix* ret = RMatrix_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RMatrix();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RMatrix(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RMatrix: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RMatrix::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPainterPath(RJSApi& handler, const RPainterPath* v) {
          QJSEngine* engine = handler.getEngine();
          RPainterPath_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPainterPath_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPainterPath object:
              ret = new RPainterPath_Wrapper(handler, new RPainterPath(*v), true);
          }

          // JS: new RPainterPath('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPainterPath");
          if (cl.isUndefined()) {
              qWarning() << "Class RPainterPath is undefined. Use RPainterPath_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPainterPath('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPainterPath(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPainterPath(RJSApi& handler, const RPainterPath& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPainterPath object:
          RPainterPath_Wrapper* ret = new RPainterPath_Wrapper(handler, new RPainterPath(v), true);

          // JS: new RPainterPath('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPainterPath");
          if (cl.isUndefined()) {
              qWarning() << "Class RPainterPath is undefined. Use RPainterPath_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPainterPath('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPainterPath(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPainterPath RJSHelper_qcad::js2cpp_RPainterPath(RJSApi& handler, const QJSValue& v) {
          /*
          RPainterPath_Wrapper* wrapper = getWrapper<RPainterPath_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPainterPath: no wrapper";
              Q_ASSERT(false);
              return RPainterPath();
          }
          //return *(RPainterPath*)wrapper->getWrappedVoid();
          RPainterPath* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPainterPath: wrapped pointer is NULL";
              return RPainterPath();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPainterPath: not a QObject";
              return RPainterPath();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPainterPath_ptr: no wrapper";
              return RPainterPath();
          }
          //RPainterPath* ret = getWrapped_RPainterPath(wrapper);
          RPainterPath* ret = RPainterPath_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPainterPath();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPainterPath(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPainterPath: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPainterPath::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPattern(RJSApi& handler, const RPattern* v) {
          QJSEngine* engine = handler.getEngine();
          RPattern_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPattern_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPattern object:
              ret = new RPattern_Wrapper(handler, new RPattern(*v), true);
          }

          // JS: new RPattern('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPattern");
          if (cl.isUndefined()) {
              qWarning() << "Class RPattern is undefined. Use RPattern_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPattern('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPattern(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPattern(RJSApi& handler, const RPattern& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPattern object:
          RPattern_Wrapper* ret = new RPattern_Wrapper(handler, new RPattern(v), true);

          // JS: new RPattern('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPattern");
          if (cl.isUndefined()) {
              qWarning() << "Class RPattern is undefined. Use RPattern_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPattern('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPattern(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPattern RJSHelper_qcad::js2cpp_RPattern(RJSApi& handler, const QJSValue& v) {
          /*
          RPattern_Wrapper* wrapper = getWrapper<RPattern_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPattern: no wrapper";
              Q_ASSERT(false);
              return RPattern();
          }
          //return *(RPattern*)wrapper->getWrappedVoid();
          RPattern* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPattern: wrapped pointer is NULL";
              return RPattern();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPattern: not a QObject";
              return RPattern();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPattern_ptr: no wrapper";
              return RPattern();
          }
          //RPattern* ret = getWrapped_RPattern(wrapper);
          RPattern* ret = RPattern_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPattern();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPattern(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPattern: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPattern::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPatternLine(RJSApi& handler, const RPatternLine* v) {
          QJSEngine* engine = handler.getEngine();
          RPatternLine_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPatternLine_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPatternLine object:
              ret = new RPatternLine_Wrapper(handler, new RPatternLine(*v), true);
          }

          // JS: new RPatternLine('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPatternLine");
          if (cl.isUndefined()) {
              qWarning() << "Class RPatternLine is undefined. Use RPatternLine_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPatternLine('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPatternLine(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPatternLine(RJSApi& handler, const RPatternLine& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPatternLine object:
          RPatternLine_Wrapper* ret = new RPatternLine_Wrapper(handler, new RPatternLine(v), true);

          // JS: new RPatternLine('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPatternLine");
          if (cl.isUndefined()) {
              qWarning() << "Class RPatternLine is undefined. Use RPatternLine_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPatternLine('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPatternLine(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPatternLine RJSHelper_qcad::js2cpp_RPatternLine(RJSApi& handler, const QJSValue& v) {
          /*
          RPatternLine_Wrapper* wrapper = getWrapper<RPatternLine_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPatternLine: no wrapper";
              Q_ASSERT(false);
              return RPatternLine();
          }
          //return *(RPatternLine*)wrapper->getWrappedVoid();
          RPatternLine* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPatternLine: wrapped pointer is NULL";
              return RPatternLine();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPatternLine: not a QObject";
              return RPatternLine();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPatternLine_ptr: no wrapper";
              return RPatternLine();
          }
          //RPatternLine* ret = getWrapped_RPatternLine(wrapper);
          RPatternLine* ret = RPatternLine_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPatternLine();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPatternLine(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPatternLine: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPatternLine::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPatternList(RJSApi& handler, const RPatternList* v) {
          QJSEngine* engine = handler.getEngine();
          RPatternList_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPatternList_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPatternList object:
              ret = new RPatternList_Wrapper(handler, new RPatternList(*v), true);
          }

          // JS: new RPatternList('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPatternList");
          if (cl.isUndefined()) {
              qWarning() << "Class RPatternList is undefined. Use RPatternList_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPatternList('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPatternList(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPatternList(RJSApi& handler, const RPatternList& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPatternList object:
          RPatternList_Wrapper* ret = new RPatternList_Wrapper(handler, new RPatternList(v), true);

          // JS: new RPatternList('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPatternList");
          if (cl.isUndefined()) {
              qWarning() << "Class RPatternList is undefined. Use RPatternList_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPatternList('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPatternList(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPatternList RJSHelper_qcad::js2cpp_RPatternList(RJSApi& handler, const QJSValue& v) {
          /*
          RPatternList_Wrapper* wrapper = getWrapper<RPatternList_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPatternList: no wrapper";
              Q_ASSERT(false);
              return RPatternList();
          }
          //return *(RPatternList*)wrapper->getWrappedVoid();
          RPatternList* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPatternList: wrapped pointer is NULL";
              return RPatternList();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPatternList: not a QObject";
              return RPatternList();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPatternList_ptr: no wrapper";
              return RPatternList();
          }
          //RPatternList* ret = getWrapped_RPatternList(wrapper);
          RPatternList* ret = RPatternList_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPatternList();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPatternList(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPatternList: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPatternList::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPatternListImperial(RJSApi& handler, const RPatternListImperial* v) {
          QJSEngine* engine = handler.getEngine();
          RPatternListImperial_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPatternListImperial_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPatternListImperial object:
              ret = new RPatternListImperial_Wrapper(handler, new RPatternListImperial(*v), true);
          }

          // JS: new RPatternListImperial('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPatternListImperial");
          if (cl.isUndefined()) {
              qWarning() << "Class RPatternListImperial is undefined. Use RPatternListImperial_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPatternListImperial('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPatternListImperial(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPatternListImperial(RJSApi& handler, const RPatternListImperial& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPatternListImperial object:
          RPatternListImperial_Wrapper* ret = new RPatternListImperial_Wrapper(handler, new RPatternListImperial(v), true);

          // JS: new RPatternListImperial('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPatternListImperial");
          if (cl.isUndefined()) {
              qWarning() << "Class RPatternListImperial is undefined. Use RPatternListImperial_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPatternListImperial('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPatternListImperial(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPatternListImperial RJSHelper_qcad::js2cpp_RPatternListImperial(RJSApi& handler, const QJSValue& v) {
          /*
          RPatternListImperial_Wrapper* wrapper = getWrapper<RPatternListImperial_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPatternListImperial: no wrapper";
              Q_ASSERT(false);
              return RPatternListImperial();
          }
          //return *(RPatternListImperial*)wrapper->getWrappedVoid();
          RPatternListImperial* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPatternListImperial: wrapped pointer is NULL";
              return RPatternListImperial();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPatternListImperial: not a QObject";
              return RPatternListImperial();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPatternListImperial_ptr: no wrapper";
              return RPatternListImperial();
          }
          //RPatternListImperial* ret = getWrapped_RPatternListImperial(wrapper);
          RPatternListImperial* ret = RPatternListImperial_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPatternListImperial();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPatternListImperial(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPatternListImperial: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPatternListImperial::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPatternListMetric(RJSApi& handler, const RPatternListMetric* v) {
          QJSEngine* engine = handler.getEngine();
          RPatternListMetric_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPatternListMetric_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPatternListMetric object:
              ret = new RPatternListMetric_Wrapper(handler, new RPatternListMetric(*v), true);
          }

          // JS: new RPatternListMetric('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPatternListMetric");
          if (cl.isUndefined()) {
              qWarning() << "Class RPatternListMetric is undefined. Use RPatternListMetric_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPatternListMetric('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPatternListMetric(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPatternListMetric(RJSApi& handler, const RPatternListMetric& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPatternListMetric object:
          RPatternListMetric_Wrapper* ret = new RPatternListMetric_Wrapper(handler, new RPatternListMetric(v), true);

          // JS: new RPatternListMetric('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPatternListMetric");
          if (cl.isUndefined()) {
              qWarning() << "Class RPatternListMetric is undefined. Use RPatternListMetric_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPatternListMetric('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPatternListMetric(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPatternListMetric RJSHelper_qcad::js2cpp_RPatternListMetric(RJSApi& handler, const QJSValue& v) {
          /*
          RPatternListMetric_Wrapper* wrapper = getWrapper<RPatternListMetric_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPatternListMetric: no wrapper";
              Q_ASSERT(false);
              return RPatternListMetric();
          }
          //return *(RPatternListMetric*)wrapper->getWrappedVoid();
          RPatternListMetric* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPatternListMetric: wrapped pointer is NULL";
              return RPatternListMetric();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPatternListMetric: not a QObject";
              return RPatternListMetric();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPatternListMetric_ptr: no wrapper";
              return RPatternListMetric();
          }
          //RPatternListMetric* ret = getWrapped_RPatternListMetric(wrapper);
          RPatternListMetric* ret = RPatternListMetric_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPatternListMetric();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPatternListMetric(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPatternListMetric: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPatternListMetric::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPluginInfo(RJSApi& handler, const RPluginInfo* v) {
          QJSEngine* engine = handler.getEngine();
          RPluginInfo_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPluginInfo_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPluginInfo object:
              ret = new RPluginInfo_Wrapper(handler, new RPluginInfo(*v), true);
          }

          // JS: new RPluginInfo('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPluginInfo");
          if (cl.isUndefined()) {
              qWarning() << "Class RPluginInfo is undefined. Use RPluginInfo_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPluginInfo('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPluginInfo(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPluginInfo(RJSApi& handler, const RPluginInfo& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPluginInfo object:
          RPluginInfo_Wrapper* ret = new RPluginInfo_Wrapper(handler, new RPluginInfo(v), true);

          // JS: new RPluginInfo('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPluginInfo");
          if (cl.isUndefined()) {
              qWarning() << "Class RPluginInfo is undefined. Use RPluginInfo_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPluginInfo('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPluginInfo(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPluginInfo RJSHelper_qcad::js2cpp_RPluginInfo(RJSApi& handler, const QJSValue& v) {
          /*
          RPluginInfo_Wrapper* wrapper = getWrapper<RPluginInfo_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPluginInfo: no wrapper";
              Q_ASSERT(false);
              return RPluginInfo();
          }
          //return *(RPluginInfo*)wrapper->getWrappedVoid();
          RPluginInfo* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPluginInfo: wrapped pointer is NULL";
              return RPluginInfo();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPluginInfo: not a QObject";
              return RPluginInfo();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPluginInfo_ptr: no wrapper";
              return RPluginInfo();
          }
          //RPluginInfo* ret = getWrapped_RPluginInfo(wrapper);
          RPluginInfo* ret = RPluginInfo_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPluginInfo();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPluginInfo(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPluginInfo: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPluginInfo::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPluginLoader(RJSApi& handler, const RPluginLoader* v) {
          QJSEngine* engine = handler.getEngine();
          RPluginLoader_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPluginLoader_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPluginLoader object:
              ret = new RPluginLoader_Wrapper(handler, new RPluginLoader(*v), true);
          }

          // JS: new RPluginLoader('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPluginLoader");
          if (cl.isUndefined()) {
              qWarning() << "Class RPluginLoader is undefined. Use RPluginLoader_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPluginLoader('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPluginLoader(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPluginLoader(RJSApi& handler, const RPluginLoader& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPluginLoader object:
          RPluginLoader_Wrapper* ret = new RPluginLoader_Wrapper(handler, new RPluginLoader(v), true);

          // JS: new RPluginLoader('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPluginLoader");
          if (cl.isUndefined()) {
              qWarning() << "Class RPluginLoader is undefined. Use RPluginLoader_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPluginLoader('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPluginLoader(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPluginLoader RJSHelper_qcad::js2cpp_RPluginLoader(RJSApi& handler, const QJSValue& v) {
          /*
          RPluginLoader_Wrapper* wrapper = getWrapper<RPluginLoader_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPluginLoader: no wrapper";
              Q_ASSERT(false);
              return RPluginLoader();
          }
          //return *(RPluginLoader*)wrapper->getWrappedVoid();
          RPluginLoader* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPluginLoader: wrapped pointer is NULL";
              return RPluginLoader();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPluginLoader: not a QObject";
              return RPluginLoader();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPluginLoader_ptr: no wrapper";
              return RPluginLoader();
          }
          //RPluginLoader* ret = getWrapped_RPluginLoader(wrapper);
          RPluginLoader* ret = RPluginLoader_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPluginLoader();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPluginLoader(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPluginLoader: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPluginLoader::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPoint(RJSApi& handler, const RPoint* v) {
          QJSEngine* engine = handler.getEngine();
          RPoint_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPoint_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPoint object:
              ret = new RPoint_Wrapper(handler, new RPoint(*v), true);
          }

          // JS: new RPoint('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPoint");
          if (cl.isUndefined()) {
              qWarning() << "Class RPoint is undefined. Use RPoint_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPoint('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPoint(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPoint(RJSApi& handler, const RPoint& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPoint object:
          RPoint_Wrapper* ret = new RPoint_Wrapper(handler, new RPoint(v), true);

          // JS: new RPoint('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPoint");
          if (cl.isUndefined()) {
              qWarning() << "Class RPoint is undefined. Use RPoint_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPoint('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPoint(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPoint RJSHelper_qcad::js2cpp_RPoint(RJSApi& handler, const QJSValue& v) {
          /*
          RPoint_Wrapper* wrapper = getWrapper<RPoint_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPoint: no wrapper";
              Q_ASSERT(false);
              return RPoint();
          }
          //return *(RPoint*)wrapper->getWrappedVoid();
          RPoint* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPoint: wrapped pointer is NULL";
              return RPoint();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPoint: not a QObject";
              return RPoint();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPoint_ptr: no wrapper";
              return RPoint();
          }
          //RPoint* ret = getWrapped_RPoint(wrapper);
          RPoint* ret = RPoint_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPoint();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPoint(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPoint: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPoint::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPointData(RJSApi& handler, const RPointData* v) {
          QJSEngine* engine = handler.getEngine();
          RPointData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPointData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPointData object:
              ret = new RPointData_Wrapper(handler, new RPointData(*v), true);
          }

          // JS: new RPointData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPointData");
          if (cl.isUndefined()) {
              qWarning() << "Class RPointData is undefined. Use RPointData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPointData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPointData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPointData(RJSApi& handler, const RPointData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPointData object:
          RPointData_Wrapper* ret = new RPointData_Wrapper(handler, new RPointData(v), true);

          // JS: new RPointData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPointData");
          if (cl.isUndefined()) {
              qWarning() << "Class RPointData is undefined. Use RPointData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPointData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPointData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPointData RJSHelper_qcad::js2cpp_RPointData(RJSApi& handler, const QJSValue& v) {
          /*
          RPointData_Wrapper* wrapper = getWrapper<RPointData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPointData: no wrapper";
              Q_ASSERT(false);
              return RPointData();
          }
          //return *(RPointData*)wrapper->getWrappedVoid();
          RPointData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPointData: wrapped pointer is NULL";
              return RPointData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPointData: not a QObject";
              return RPointData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPointData_ptr: no wrapper";
              return RPointData();
          }
          //RPointData* ret = getWrapped_RPointData(wrapper);
          RPointData* ret = RPointData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPointData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPointData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPointData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPointData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPolyline(RJSApi& handler, const RPolyline* v) {
          QJSEngine* engine = handler.getEngine();
          RPolyline_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPolyline_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPolyline object:
              ret = new RPolyline_Wrapper(handler, new RPolyline(*v), true);
          }

          // JS: new RPolyline('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPolyline");
          if (cl.isUndefined()) {
              qWarning() << "Class RPolyline is undefined. Use RPolyline_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPolyline('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPolyline(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPolyline(RJSApi& handler, const RPolyline& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPolyline object:
          RPolyline_Wrapper* ret = new RPolyline_Wrapper(handler, new RPolyline(v), true);

          // JS: new RPolyline('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPolyline");
          if (cl.isUndefined()) {
              qWarning() << "Class RPolyline is undefined. Use RPolyline_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPolyline('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPolyline(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPolyline RJSHelper_qcad::js2cpp_RPolyline(RJSApi& handler, const QJSValue& v) {
          /*
          RPolyline_Wrapper* wrapper = getWrapper<RPolyline_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPolyline: no wrapper";
              Q_ASSERT(false);
              return RPolyline();
          }
          //return *(RPolyline*)wrapper->getWrappedVoid();
          RPolyline* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPolyline: wrapped pointer is NULL";
              return RPolyline();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPolyline: not a QObject";
              return RPolyline();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPolyline_ptr: no wrapper";
              return RPolyline();
          }
          //RPolyline* ret = getWrapped_RPolyline(wrapper);
          RPolyline* ret = RPolyline_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPolyline();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPolyline(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPolyline: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPolyline::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPolylineData(RJSApi& handler, const RPolylineData* v) {
          QJSEngine* engine = handler.getEngine();
          RPolylineData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPolylineData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPolylineData object:
              ret = new RPolylineData_Wrapper(handler, new RPolylineData(*v), true);
          }

          // JS: new RPolylineData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPolylineData");
          if (cl.isUndefined()) {
              qWarning() << "Class RPolylineData is undefined. Use RPolylineData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPolylineData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPolylineData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPolylineData(RJSApi& handler, const RPolylineData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPolylineData object:
          RPolylineData_Wrapper* ret = new RPolylineData_Wrapper(handler, new RPolylineData(v), true);

          // JS: new RPolylineData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPolylineData");
          if (cl.isUndefined()) {
              qWarning() << "Class RPolylineData is undefined. Use RPolylineData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPolylineData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPolylineData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPolylineData RJSHelper_qcad::js2cpp_RPolylineData(RJSApi& handler, const QJSValue& v) {
          /*
          RPolylineData_Wrapper* wrapper = getWrapper<RPolylineData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPolylineData: no wrapper";
              Q_ASSERT(false);
              return RPolylineData();
          }
          //return *(RPolylineData*)wrapper->getWrappedVoid();
          RPolylineData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPolylineData: wrapped pointer is NULL";
              return RPolylineData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPolylineData: not a QObject";
              return RPolylineData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPolylineData_ptr: no wrapper";
              return RPolylineData();
          }
          //RPolylineData* ret = getWrapped_RPolylineData(wrapper);
          RPolylineData* ret = RPolylineData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPolylineData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPolylineData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPolylineData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPolylineData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPropertyAttributes(RJSApi& handler, const RPropertyAttributes* v) {
          QJSEngine* engine = handler.getEngine();
          RPropertyAttributes_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPropertyAttributes_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPropertyAttributes object:
              ret = new RPropertyAttributes_Wrapper(handler, new RPropertyAttributes(*v), true);
          }

          // JS: new RPropertyAttributes('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPropertyAttributes");
          if (cl.isUndefined()) {
              qWarning() << "Class RPropertyAttributes is undefined. Use RPropertyAttributes_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPropertyAttributes('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPropertyAttributes(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPropertyAttributes(RJSApi& handler, const RPropertyAttributes& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPropertyAttributes object:
          RPropertyAttributes_Wrapper* ret = new RPropertyAttributes_Wrapper(handler, new RPropertyAttributes(v), true);

          // JS: new RPropertyAttributes('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPropertyAttributes");
          if (cl.isUndefined()) {
              qWarning() << "Class RPropertyAttributes is undefined. Use RPropertyAttributes_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPropertyAttributes('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPropertyAttributes(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPropertyAttributes RJSHelper_qcad::js2cpp_RPropertyAttributes(RJSApi& handler, const QJSValue& v) {
          /*
          RPropertyAttributes_Wrapper* wrapper = getWrapper<RPropertyAttributes_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPropertyAttributes: no wrapper";
              Q_ASSERT(false);
              return RPropertyAttributes();
          }
          //return *(RPropertyAttributes*)wrapper->getWrappedVoid();
          RPropertyAttributes* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPropertyAttributes: wrapped pointer is NULL";
              return RPropertyAttributes();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPropertyAttributes: not a QObject";
              return RPropertyAttributes();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPropertyAttributes_ptr: no wrapper";
              return RPropertyAttributes();
          }
          //RPropertyAttributes* ret = getWrapped_RPropertyAttributes(wrapper);
          RPropertyAttributes* ret = RPropertyAttributes_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPropertyAttributes();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPropertyAttributes(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPropertyAttributes: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPropertyAttributes::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPropertyChange(RJSApi& handler, const RPropertyChange* v) {
          QJSEngine* engine = handler.getEngine();
          RPropertyChange_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPropertyChange_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPropertyChange object:
              ret = new RPropertyChange_Wrapper(handler, new RPropertyChange(*v), true);
          }

          // JS: new RPropertyChange('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPropertyChange");
          if (cl.isUndefined()) {
              qWarning() << "Class RPropertyChange is undefined. Use RPropertyChange_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPropertyChange('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPropertyChange(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPropertyChange(RJSApi& handler, const RPropertyChange& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPropertyChange object:
          RPropertyChange_Wrapper* ret = new RPropertyChange_Wrapper(handler, new RPropertyChange(v), true);

          // JS: new RPropertyChange('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPropertyChange");
          if (cl.isUndefined()) {
              qWarning() << "Class RPropertyChange is undefined. Use RPropertyChange_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPropertyChange('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPropertyChange(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPropertyChange RJSHelper_qcad::js2cpp_RPropertyChange(RJSApi& handler, const QJSValue& v) {
          /*
          RPropertyChange_Wrapper* wrapper = getWrapper<RPropertyChange_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPropertyChange: no wrapper";
              Q_ASSERT(false);
              return RPropertyChange();
          }
          //return *(RPropertyChange*)wrapper->getWrappedVoid();
          RPropertyChange* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPropertyChange: wrapped pointer is NULL";
              return RPropertyChange();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPropertyChange: not a QObject";
              return RPropertyChange();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPropertyChange_ptr: no wrapper";
              return RPropertyChange();
          }
          //RPropertyChange* ret = getWrapped_RPropertyChange(wrapper);
          RPropertyChange* ret = RPropertyChange_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPropertyChange();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPropertyChange(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPropertyChange: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPropertyChange::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPropertyEditor(RJSApi& handler, const RPropertyEditor* v) {
          QJSEngine* engine = handler.getEngine();
          RPropertyEditor_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPropertyEditor_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPropertyEditor object:
              ret = new RPropertyEditor_Wrapper(handler, new RPropertyEditor(*v), true);
          }

          // JS: new RPropertyEditor('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPropertyEditor");
          if (cl.isUndefined()) {
              qWarning() << "Class RPropertyEditor is undefined. Use RPropertyEditor_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPropertyEditor('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPropertyEditor(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPropertyEditor(RJSApi& handler, const RPropertyEditor& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPropertyEditor object:
          RPropertyEditor_Wrapper* ret = new RPropertyEditor_Wrapper(handler, new RPropertyEditor(v), true);

          // JS: new RPropertyEditor('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPropertyEditor");
          if (cl.isUndefined()) {
              qWarning() << "Class RPropertyEditor is undefined. Use RPropertyEditor_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPropertyEditor('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPropertyEditor(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPropertyEditor RJSHelper_qcad::js2cpp_RPropertyEditor(RJSApi& handler, const QJSValue& v) {
          /*
          RPropertyEditor_Wrapper* wrapper = getWrapper<RPropertyEditor_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPropertyEditor: no wrapper";
              Q_ASSERT(false);
              return RPropertyEditor();
          }
          //return *(RPropertyEditor*)wrapper->getWrappedVoid();
          RPropertyEditor* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPropertyEditor: wrapped pointer is NULL";
              return RPropertyEditor();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPropertyEditor: not a QObject";
              return RPropertyEditor();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPropertyEditor_ptr: no wrapper";
              return RPropertyEditor();
          }
          //RPropertyEditor* ret = getWrapped_RPropertyEditor(wrapper);
          RPropertyEditor* ret = RPropertyEditor_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPropertyEditor();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPropertyEditor(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPropertyEditor: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPropertyEditor::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPropertyTypeId(RJSApi& handler, const RPropertyTypeId* v) {
          QJSEngine* engine = handler.getEngine();
          RPropertyTypeId_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPropertyTypeId_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPropertyTypeId object:
              ret = new RPropertyTypeId_Wrapper(handler, new RPropertyTypeId(*v), true);
          }

          // JS: new RPropertyTypeId('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPropertyTypeId");
          if (cl.isUndefined()) {
              qWarning() << "Class RPropertyTypeId is undefined. Use RPropertyTypeId_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPropertyTypeId('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPropertyTypeId(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPropertyTypeId(RJSApi& handler, const RPropertyTypeId& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPropertyTypeId object:
          RPropertyTypeId_Wrapper* ret = new RPropertyTypeId_Wrapper(handler, new RPropertyTypeId(v), true);

          // JS: new RPropertyTypeId('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPropertyTypeId");
          if (cl.isUndefined()) {
              qWarning() << "Class RPropertyTypeId is undefined. Use RPropertyTypeId_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPropertyTypeId('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPropertyTypeId(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPropertyTypeId RJSHelper_qcad::js2cpp_RPropertyTypeId(RJSApi& handler, const QJSValue& v) {
          /*
          RPropertyTypeId_Wrapper* wrapper = getWrapper<RPropertyTypeId_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPropertyTypeId: no wrapper";
              Q_ASSERT(false);
              return RPropertyTypeId();
          }
          //return *(RPropertyTypeId*)wrapper->getWrappedVoid();
          RPropertyTypeId* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPropertyTypeId: wrapped pointer is NULL";
              return RPropertyTypeId();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPropertyTypeId: not a QObject";
              return RPropertyTypeId();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPropertyTypeId_ptr: no wrapper";
              return RPropertyTypeId();
          }
          //RPropertyTypeId* ret = getWrapped_RPropertyTypeId(wrapper);
          RPropertyTypeId* ret = RPropertyTypeId_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPropertyTypeId();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPropertyTypeId(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPropertyTypeId: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPropertyTypeId::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RRay(RJSApi& handler, const RRay* v) {
          QJSEngine* engine = handler.getEngine();
          RRay_Wrapper* ret;

          if (v==nullptr) {
              ret = new RRay_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RRay object:
              ret = new RRay_Wrapper(handler, new RRay(*v), true);
          }

          // JS: new RRay('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRay");
          if (cl.isUndefined()) {
              qWarning() << "Class RRay is undefined. Use RRay_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RRay('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RRay(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RRay(RJSApi& handler, const RRay& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RRay object:
          RRay_Wrapper* ret = new RRay_Wrapper(handler, new RRay(v), true);

          // JS: new RRay('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRay");
          if (cl.isUndefined()) {
              qWarning() << "Class RRay is undefined. Use RRay_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RRay('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RRay(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RRay RJSHelper_qcad::js2cpp_RRay(RJSApi& handler, const QJSValue& v) {
          /*
          RRay_Wrapper* wrapper = getWrapper<RRay_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RRay: no wrapper";
              Q_ASSERT(false);
              return RRay();
          }
          //return *(RRay*)wrapper->getWrappedVoid();
          RRay* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RRay: wrapped pointer is NULL";
              return RRay();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RRay: not a QObject";
              return RRay();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RRay_ptr: no wrapper";
              return RRay();
          }
          //RRay* ret = getWrapped_RRay(wrapper);
          RRay* ret = RRay_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RRay();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RRay(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RRay: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RRay::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RRayData(RJSApi& handler, const RRayData* v) {
          QJSEngine* engine = handler.getEngine();
          RRayData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RRayData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RRayData object:
              ret = new RRayData_Wrapper(handler, new RRayData(*v), true);
          }

          // JS: new RRayData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRayData");
          if (cl.isUndefined()) {
              qWarning() << "Class RRayData is undefined. Use RRayData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RRayData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RRayData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RRayData(RJSApi& handler, const RRayData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RRayData object:
          RRayData_Wrapper* ret = new RRayData_Wrapper(handler, new RRayData(v), true);

          // JS: new RRayData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRayData");
          if (cl.isUndefined()) {
              qWarning() << "Class RRayData is undefined. Use RRayData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RRayData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RRayData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RRayData RJSHelper_qcad::js2cpp_RRayData(RJSApi& handler, const QJSValue& v) {
          /*
          RRayData_Wrapper* wrapper = getWrapper<RRayData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RRayData: no wrapper";
              Q_ASSERT(false);
              return RRayData();
          }
          //return *(RRayData*)wrapper->getWrappedVoid();
          RRayData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RRayData: wrapped pointer is NULL";
              return RRayData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RRayData: not a QObject";
              return RRayData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RRayData_ptr: no wrapper";
              return RRayData();
          }
          //RRayData* ret = getWrapped_RRayData(wrapper);
          RRayData* ret = RRayData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RRayData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RRayData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RRayData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RRayData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RRefPoint(RJSApi& handler, const RRefPoint* v) {
          QJSEngine* engine = handler.getEngine();
          RRefPoint_Wrapper* ret;

          if (v==nullptr) {
              ret = new RRefPoint_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RRefPoint object:
              ret = new RRefPoint_Wrapper(handler, new RRefPoint(*v), true);
          }

          // JS: new RRefPoint('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRefPoint");
          if (cl.isUndefined()) {
              qWarning() << "Class RRefPoint is undefined. Use RRefPoint_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RRefPoint('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RRefPoint(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RRefPoint(RJSApi& handler, const RRefPoint& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RRefPoint object:
          RRefPoint_Wrapper* ret = new RRefPoint_Wrapper(handler, new RRefPoint(v), true);

          // JS: new RRefPoint('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRefPoint");
          if (cl.isUndefined()) {
              qWarning() << "Class RRefPoint is undefined. Use RRefPoint_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RRefPoint('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RRefPoint(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RRefPoint RJSHelper_qcad::js2cpp_RRefPoint(RJSApi& handler, const QJSValue& v) {
          /*
          RRefPoint_Wrapper* wrapper = getWrapper<RRefPoint_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RRefPoint: no wrapper";
              Q_ASSERT(false);
              return RRefPoint();
          }
          //return *(RRefPoint*)wrapper->getWrappedVoid();
          RRefPoint* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RRefPoint: wrapped pointer is NULL";
              return RRefPoint();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RRefPoint: not a QObject";
              return RRefPoint();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RRefPoint_ptr: no wrapper";
              return RRefPoint();
          }
          //RRefPoint* ret = getWrapped_RRefPoint(wrapper);
          RRefPoint* ret = RRefPoint_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RRefPoint();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RRefPoint(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RRefPoint: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RRefPoint::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RS(RJSApi& handler, const RS* v) {
          QJSEngine* engine = handler.getEngine();
          RS_Wrapper* ret;

          if (v==nullptr) {
              ret = new RS_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RS object:
              ret = new RS_Wrapper(handler, new RS(*v), true);
          }

          // JS: new RS('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RS");
          if (cl.isUndefined()) {
              qWarning() << "Class RS is undefined. Use RS_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RS('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RS(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RS(RJSApi& handler, const RS& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RS object:
          RS_Wrapper* ret = new RS_Wrapper(handler, new RS(v), true);

          // JS: new RS('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RS");
          if (cl.isUndefined()) {
              qWarning() << "Class RS is undefined. Use RS_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RS('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RS(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RS RJSHelper_qcad::js2cpp_RS(RJSApi& handler, const QJSValue& v) {
          /*
          RS_Wrapper* wrapper = getWrapper<RS_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RS: no wrapper";
              Q_ASSERT(false);
              return RS();
          }
          //return *(RS*)wrapper->getWrappedVoid();
          RS* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RS: wrapped pointer is NULL";
              return RS();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RS: not a QObject";
              return RS();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RS_ptr: no wrapper";
              return RS();
          }
          //RS* ret = getWrapped_RS(wrapper);
          RS* ret = RS_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RS();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RS(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RS: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RS::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSettings(RJSApi& handler, const RSettings* v) {
          QJSEngine* engine = handler.getEngine();
          RSettings_Wrapper* ret;

          if (v==nullptr) {
              ret = new RSettings_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RSettings object:
              ret = new RSettings_Wrapper(handler, new RSettings(*v), true);
          }

          // JS: new RSettings('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSettings");
          if (cl.isUndefined()) {
              qWarning() << "Class RSettings is undefined. Use RSettings_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSettings('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSettings(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RSettings(RJSApi& handler, const RSettings& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RSettings object:
          RSettings_Wrapper* ret = new RSettings_Wrapper(handler, new RSettings(v), true);

          // JS: new RSettings('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSettings");
          if (cl.isUndefined()) {
              qWarning() << "Class RSettings is undefined. Use RSettings_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSettings('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSettings(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RSettings RJSHelper_qcad::js2cpp_RSettings(RJSApi& handler, const QJSValue& v) {
          /*
          RSettings_Wrapper* wrapper = getWrapper<RSettings_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSettings: no wrapper";
              Q_ASSERT(false);
              return RSettings();
          }
          //return *(RSettings*)wrapper->getWrappedVoid();
          RSettings* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RSettings: wrapped pointer is NULL";
              return RSettings();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSettings: not a QObject";
              return RSettings();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSettings_ptr: no wrapper";
              return RSettings();
          }
          //RSettings* ret = getWrapped_RSettings(wrapper);
          RSettings* ret = RSettings_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RSettings();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RSettings(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSettings: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RSettings::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSolidData(RJSApi& handler, const RSolidData* v) {
          QJSEngine* engine = handler.getEngine();
          RSolidData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RSolidData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RSolidData object:
              ret = new RSolidData_Wrapper(handler, new RSolidData(*v), true);
          }

          // JS: new RSolidData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSolidData");
          if (cl.isUndefined()) {
              qWarning() << "Class RSolidData is undefined. Use RSolidData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSolidData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSolidData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RSolidData(RJSApi& handler, const RSolidData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RSolidData object:
          RSolidData_Wrapper* ret = new RSolidData_Wrapper(handler, new RSolidData(v), true);

          // JS: new RSolidData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSolidData");
          if (cl.isUndefined()) {
              qWarning() << "Class RSolidData is undefined. Use RSolidData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSolidData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSolidData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RSolidData RJSHelper_qcad::js2cpp_RSolidData(RJSApi& handler, const QJSValue& v) {
          /*
          RSolidData_Wrapper* wrapper = getWrapper<RSolidData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSolidData: no wrapper";
              Q_ASSERT(false);
              return RSolidData();
          }
          //return *(RSolidData*)wrapper->getWrappedVoid();
          RSolidData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RSolidData: wrapped pointer is NULL";
              return RSolidData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSolidData: not a QObject";
              return RSolidData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSolidData_ptr: no wrapper";
              return RSolidData();
          }
          //RSolidData* ret = getWrapped_RSolidData(wrapper);
          RSolidData* ret = RSolidData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RSolidData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RSolidData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSolidData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RSolidData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSpatialIndexNavel(RJSApi& handler, const RSpatialIndexNavel* v) {
          QJSEngine* engine = handler.getEngine();
          RSpatialIndexNavel_Wrapper* ret;

          if (v==nullptr) {
              ret = new RSpatialIndexNavel_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RSpatialIndexNavel object:
              ret = new RSpatialIndexNavel_Wrapper(handler, new RSpatialIndexNavel(*v), true);
          }

          // JS: new RSpatialIndexNavel('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSpatialIndexNavel");
          if (cl.isUndefined()) {
              qWarning() << "Class RSpatialIndexNavel is undefined. Use RSpatialIndexNavel_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSpatialIndexNavel('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSpatialIndexNavel(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RSpatialIndexNavel(RJSApi& handler, const RSpatialIndexNavel& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RSpatialIndexNavel object:
          RSpatialIndexNavel_Wrapper* ret = new RSpatialIndexNavel_Wrapper(handler, new RSpatialIndexNavel(v), true);

          // JS: new RSpatialIndexNavel('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSpatialIndexNavel");
          if (cl.isUndefined()) {
              qWarning() << "Class RSpatialIndexNavel is undefined. Use RSpatialIndexNavel_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSpatialIndexNavel('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSpatialIndexNavel(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RSpatialIndexNavel RJSHelper_qcad::js2cpp_RSpatialIndexNavel(RJSApi& handler, const QJSValue& v) {
          /*
          RSpatialIndexNavel_Wrapper* wrapper = getWrapper<RSpatialIndexNavel_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSpatialIndexNavel: no wrapper";
              Q_ASSERT(false);
              return RSpatialIndexNavel();
          }
          //return *(RSpatialIndexNavel*)wrapper->getWrappedVoid();
          RSpatialIndexNavel* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RSpatialIndexNavel: wrapped pointer is NULL";
              return RSpatialIndexNavel();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSpatialIndexNavel: not a QObject";
              return RSpatialIndexNavel();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSpatialIndexNavel_ptr: no wrapper";
              return RSpatialIndexNavel();
          }
          //RSpatialIndexNavel* ret = getWrapped_RSpatialIndexNavel(wrapper);
          RSpatialIndexNavel* ret = RSpatialIndexNavel_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RSpatialIndexNavel();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RSpatialIndexNavel(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSpatialIndexNavel: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RSpatialIndexNavel::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSpatialIndexVisitorAdapter(RJSApi& handler, const RSpatialIndexVisitorAdapter* v) {
          QJSEngine* engine = handler.getEngine();
          RSpatialIndexVisitorAdapter_Wrapper* ret;

          if (v==nullptr) {
              ret = new RSpatialIndexVisitorAdapter_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RSpatialIndexVisitorAdapter object:
              ret = new RSpatialIndexVisitorAdapter_Wrapper(handler, new RSpatialIndexVisitorAdapter(*v), true);
          }

          // JS: new RSpatialIndexVisitorAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSpatialIndexVisitorAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RSpatialIndexVisitorAdapter is undefined. Use RSpatialIndexVisitorAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSpatialIndexVisitorAdapter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSpatialIndexVisitorAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RSpatialIndexVisitorAdapter(RJSApi& handler, const RSpatialIndexVisitorAdapter& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RSpatialIndexVisitorAdapter object:
          RSpatialIndexVisitorAdapter_Wrapper* ret = new RSpatialIndexVisitorAdapter_Wrapper(handler, new RSpatialIndexVisitorAdapter(v), true);

          // JS: new RSpatialIndexVisitorAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSpatialIndexVisitorAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RSpatialIndexVisitorAdapter is undefined. Use RSpatialIndexVisitorAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSpatialIndexVisitorAdapter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSpatialIndexVisitorAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RSpatialIndexVisitorAdapter RJSHelper_qcad::js2cpp_RSpatialIndexVisitorAdapter(RJSApi& handler, const QJSValue& v) {
          /*
          RSpatialIndexVisitorAdapter_Wrapper* wrapper = getWrapper<RSpatialIndexVisitorAdapter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSpatialIndexVisitorAdapter: no wrapper";
              Q_ASSERT(false);
              return RSpatialIndexVisitorAdapter();
          }
          //return *(RSpatialIndexVisitorAdapter*)wrapper->getWrappedVoid();
          RSpatialIndexVisitorAdapter* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RSpatialIndexVisitorAdapter: wrapped pointer is NULL";
              return RSpatialIndexVisitorAdapter();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSpatialIndexVisitorAdapter: not a QObject";
              return RSpatialIndexVisitorAdapter();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSpatialIndexVisitorAdapter_ptr: no wrapper";
              return RSpatialIndexVisitorAdapter();
          }
          //RSpatialIndexVisitorAdapter* ret = getWrapped_RSpatialIndexVisitorAdapter(wrapper);
          RSpatialIndexVisitorAdapter* ret = RSpatialIndexVisitorAdapter_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RSpatialIndexVisitorAdapter();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RSpatialIndexVisitorAdapter(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSpatialIndexVisitorAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RSpatialIndexVisitorAdapter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSpline(RJSApi& handler, const RSpline* v) {
          QJSEngine* engine = handler.getEngine();
          RSpline_Wrapper* ret;

          if (v==nullptr) {
              ret = new RSpline_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RSpline object:
              ret = new RSpline_Wrapper(handler, new RSpline(*v), true);
          }

          // JS: new RSpline('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSpline");
          if (cl.isUndefined()) {
              qWarning() << "Class RSpline is undefined. Use RSpline_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSpline('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSpline(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RSpline(RJSApi& handler, const RSpline& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RSpline object:
          RSpline_Wrapper* ret = new RSpline_Wrapper(handler, new RSpline(v), true);

          // JS: new RSpline('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSpline");
          if (cl.isUndefined()) {
              qWarning() << "Class RSpline is undefined. Use RSpline_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSpline('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSpline(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RSpline RJSHelper_qcad::js2cpp_RSpline(RJSApi& handler, const QJSValue& v) {
          /*
          RSpline_Wrapper* wrapper = getWrapper<RSpline_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSpline: no wrapper";
              Q_ASSERT(false);
              return RSpline();
          }
          //return *(RSpline*)wrapper->getWrappedVoid();
          RSpline* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RSpline: wrapped pointer is NULL";
              return RSpline();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSpline: not a QObject";
              return RSpline();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSpline_ptr: no wrapper";
              return RSpline();
          }
          //RSpline* ret = getWrapped_RSpline(wrapper);
          RSpline* ret = RSpline_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RSpline();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RSpline(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSpline: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RSpline::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSplineData(RJSApi& handler, const RSplineData* v) {
          QJSEngine* engine = handler.getEngine();
          RSplineData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RSplineData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RSplineData object:
              ret = new RSplineData_Wrapper(handler, new RSplineData(*v), true);
          }

          // JS: new RSplineData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSplineData");
          if (cl.isUndefined()) {
              qWarning() << "Class RSplineData is undefined. Use RSplineData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSplineData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSplineData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RSplineData(RJSApi& handler, const RSplineData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RSplineData object:
          RSplineData_Wrapper* ret = new RSplineData_Wrapper(handler, new RSplineData(v), true);

          // JS: new RSplineData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSplineData");
          if (cl.isUndefined()) {
              qWarning() << "Class RSplineData is undefined. Use RSplineData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSplineData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSplineData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RSplineData RJSHelper_qcad::js2cpp_RSplineData(RJSApi& handler, const QJSValue& v) {
          /*
          RSplineData_Wrapper* wrapper = getWrapper<RSplineData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSplineData: no wrapper";
              Q_ASSERT(false);
              return RSplineData();
          }
          //return *(RSplineData*)wrapper->getWrappedVoid();
          RSplineData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RSplineData: wrapped pointer is NULL";
              return RSplineData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSplineData: not a QObject";
              return RSplineData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSplineData_ptr: no wrapper";
              return RSplineData();
          }
          //RSplineData* ret = getWrapped_RSplineData(wrapper);
          RSplineData* ret = RSplineData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RSplineData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RSplineData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSplineData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RSplineData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTextBasedData(RJSApi& handler, const RTextBasedData* v) {
          QJSEngine* engine = handler.getEngine();
          RTextBasedData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RTextBasedData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RTextBasedData object:
              ret = new RTextBasedData_Wrapper(handler, new RTextBasedData(*v), true);
          }

          // JS: new RTextBasedData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTextBasedData");
          if (cl.isUndefined()) {
              qWarning() << "Class RTextBasedData is undefined. Use RTextBasedData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTextBasedData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTextBasedData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RTextBasedData(RJSApi& handler, const RTextBasedData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RTextBasedData object:
          RTextBasedData_Wrapper* ret = new RTextBasedData_Wrapper(handler, new RTextBasedData(v), true);

          // JS: new RTextBasedData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTextBasedData");
          if (cl.isUndefined()) {
              qWarning() << "Class RTextBasedData is undefined. Use RTextBasedData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTextBasedData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTextBasedData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RTextBasedData RJSHelper_qcad::js2cpp_RTextBasedData(RJSApi& handler, const QJSValue& v) {
          /*
          RTextBasedData_Wrapper* wrapper = getWrapper<RTextBasedData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTextBasedData: no wrapper";
              Q_ASSERT(false);
              return RTextBasedData();
          }
          //return *(RTextBasedData*)wrapper->getWrappedVoid();
          RTextBasedData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RTextBasedData: wrapped pointer is NULL";
              return RTextBasedData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTextBasedData: not a QObject";
              return RTextBasedData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTextBasedData_ptr: no wrapper";
              return RTextBasedData();
          }
          //RTextBasedData* ret = getWrapped_RTextBasedData(wrapper);
          RTextBasedData* ret = RTextBasedData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RTextBasedData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RTextBasedData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTextBasedData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RTextBasedData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTextData(RJSApi& handler, const RTextData* v) {
          QJSEngine* engine = handler.getEngine();
          RTextData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RTextData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RTextData object:
              ret = new RTextData_Wrapper(handler, new RTextData(*v), true);
          }

          // JS: new RTextData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTextData");
          if (cl.isUndefined()) {
              qWarning() << "Class RTextData is undefined. Use RTextData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTextData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTextData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RTextData(RJSApi& handler, const RTextData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RTextData object:
          RTextData_Wrapper* ret = new RTextData_Wrapper(handler, new RTextData(v), true);

          // JS: new RTextData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTextData");
          if (cl.isUndefined()) {
              qWarning() << "Class RTextData is undefined. Use RTextData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTextData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTextData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RTextData RJSHelper_qcad::js2cpp_RTextData(RJSApi& handler, const QJSValue& v) {
          /*
          RTextData_Wrapper* wrapper = getWrapper<RTextData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTextData: no wrapper";
              Q_ASSERT(false);
              return RTextData();
          }
          //return *(RTextData*)wrapper->getWrappedVoid();
          RTextData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RTextData: wrapped pointer is NULL";
              return RTextData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTextData: not a QObject";
              return RTextData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTextData_ptr: no wrapper";
              return RTextData();
          }
          //RTextData* ret = getWrapped_RTextData(wrapper);
          RTextData* ret = RTextData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RTextData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RTextData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTextData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RTextData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTextLabel(RJSApi& handler, const RTextLabel* v) {
          QJSEngine* engine = handler.getEngine();
          RTextLabel_Wrapper* ret;

          if (v==nullptr) {
              ret = new RTextLabel_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RTextLabel object:
              ret = new RTextLabel_Wrapper(handler, new RTextLabel(*v), true);
          }

          // JS: new RTextLabel('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTextLabel");
          if (cl.isUndefined()) {
              qWarning() << "Class RTextLabel is undefined. Use RTextLabel_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTextLabel('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTextLabel(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RTextLabel(RJSApi& handler, const RTextLabel& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RTextLabel object:
          RTextLabel_Wrapper* ret = new RTextLabel_Wrapper(handler, new RTextLabel(v), true);

          // JS: new RTextLabel('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTextLabel");
          if (cl.isUndefined()) {
              qWarning() << "Class RTextLabel is undefined. Use RTextLabel_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTextLabel('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTextLabel(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RTextLabel RJSHelper_qcad::js2cpp_RTextLabel(RJSApi& handler, const QJSValue& v) {
          /*
          RTextLabel_Wrapper* wrapper = getWrapper<RTextLabel_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTextLabel: no wrapper";
              Q_ASSERT(false);
              return RTextLabel();
          }
          //return *(RTextLabel*)wrapper->getWrappedVoid();
          RTextLabel* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RTextLabel: wrapped pointer is NULL";
              return RTextLabel();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTextLabel: not a QObject";
              return RTextLabel();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTextLabel_ptr: no wrapper";
              return RTextLabel();
          }
          //RTextLabel* ret = getWrapped_RTextLabel(wrapper);
          RTextLabel* ret = RTextLabel_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RTextLabel();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RTextLabel(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTextLabel: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RTextLabel::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTextLayout(RJSApi& handler, const RTextLayout* v) {
          QJSEngine* engine = handler.getEngine();
          RTextLayout_Wrapper* ret;

          if (v==nullptr) {
              ret = new RTextLayout_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RTextLayout object:
              ret = new RTextLayout_Wrapper(handler, new RTextLayout(*v), true);
          }

          // JS: new RTextLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTextLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class RTextLayout is undefined. Use RTextLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTextLayout('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTextLayout(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RTextLayout(RJSApi& handler, const RTextLayout& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RTextLayout object:
          RTextLayout_Wrapper* ret = new RTextLayout_Wrapper(handler, new RTextLayout(v), true);

          // JS: new RTextLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTextLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class RTextLayout is undefined. Use RTextLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTextLayout('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTextLayout(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RTextLayout RJSHelper_qcad::js2cpp_RTextLayout(RJSApi& handler, const QJSValue& v) {
          /*
          RTextLayout_Wrapper* wrapper = getWrapper<RTextLayout_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTextLayout: no wrapper";
              Q_ASSERT(false);
              return RTextLayout();
          }
          //return *(RTextLayout*)wrapper->getWrappedVoid();
          RTextLayout* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RTextLayout: wrapped pointer is NULL";
              return RTextLayout();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTextLayout: not a QObject";
              return RTextLayout();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTextLayout_ptr: no wrapper";
              return RTextLayout();
          }
          //RTextLayout* ret = getWrapped_RTextLayout(wrapper);
          RTextLayout* ret = RTextLayout_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RTextLayout();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RTextLayout(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTextLayout: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RTextLayout::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RToleranceData(RJSApi& handler, const RToleranceData* v) {
          QJSEngine* engine = handler.getEngine();
          RToleranceData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RToleranceData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RToleranceData object:
              ret = new RToleranceData_Wrapper(handler, new RToleranceData(*v), true);
          }

          // JS: new RToleranceData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RToleranceData");
          if (cl.isUndefined()) {
              qWarning() << "Class RToleranceData is undefined. Use RToleranceData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RToleranceData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RToleranceData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RToleranceData(RJSApi& handler, const RToleranceData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RToleranceData object:
          RToleranceData_Wrapper* ret = new RToleranceData_Wrapper(handler, new RToleranceData(v), true);

          // JS: new RToleranceData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RToleranceData");
          if (cl.isUndefined()) {
              qWarning() << "Class RToleranceData is undefined. Use RToleranceData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RToleranceData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RToleranceData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RToleranceData RJSHelper_qcad::js2cpp_RToleranceData(RJSApi& handler, const QJSValue& v) {
          /*
          RToleranceData_Wrapper* wrapper = getWrapper<RToleranceData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RToleranceData: no wrapper";
              Q_ASSERT(false);
              return RToleranceData();
          }
          //return *(RToleranceData*)wrapper->getWrappedVoid();
          RToleranceData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RToleranceData: wrapped pointer is NULL";
              return RToleranceData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RToleranceData: not a QObject";
              return RToleranceData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RToleranceData_ptr: no wrapper";
              return RToleranceData();
          }
          //RToleranceData* ret = getWrapped_RToleranceData(wrapper);
          RToleranceData* ret = RToleranceData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RToleranceData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RToleranceData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RToleranceData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RToleranceData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTraceData(RJSApi& handler, const RTraceData* v) {
          QJSEngine* engine = handler.getEngine();
          RTraceData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RTraceData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RTraceData object:
              ret = new RTraceData_Wrapper(handler, new RTraceData(*v), true);
          }

          // JS: new RTraceData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTraceData");
          if (cl.isUndefined()) {
              qWarning() << "Class RTraceData is undefined. Use RTraceData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTraceData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTraceData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RTraceData(RJSApi& handler, const RTraceData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RTraceData object:
          RTraceData_Wrapper* ret = new RTraceData_Wrapper(handler, new RTraceData(v), true);

          // JS: new RTraceData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTraceData");
          if (cl.isUndefined()) {
              qWarning() << "Class RTraceData is undefined. Use RTraceData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTraceData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTraceData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RTraceData RJSHelper_qcad::js2cpp_RTraceData(RJSApi& handler, const QJSValue& v) {
          /*
          RTraceData_Wrapper* wrapper = getWrapper<RTraceData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTraceData: no wrapper";
              Q_ASSERT(false);
              return RTraceData();
          }
          //return *(RTraceData*)wrapper->getWrappedVoid();
          RTraceData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RTraceData: wrapped pointer is NULL";
              return RTraceData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTraceData: not a QObject";
              return RTraceData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTraceData_ptr: no wrapper";
              return RTraceData();
          }
          //RTraceData* ret = getWrapped_RTraceData(wrapper);
          RTraceData* ret = RTraceData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RTraceData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RTraceData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTraceData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RTraceData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTransaction(RJSApi& handler, const RTransaction* v) {
          QJSEngine* engine = handler.getEngine();
          RTransaction_Wrapper* ret;

          if (v==nullptr) {
              ret = new RTransaction_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RTransaction object:
              ret = new RTransaction_Wrapper(handler, new RTransaction(*v), true);
          }

          // JS: new RTransaction('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTransaction");
          if (cl.isUndefined()) {
              qWarning() << "Class RTransaction is undefined. Use RTransaction_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTransaction('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTransaction(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RTransaction(RJSApi& handler, const RTransaction& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RTransaction object:
          RTransaction_Wrapper* ret = new RTransaction_Wrapper(handler, new RTransaction(v), true);

          // JS: new RTransaction('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTransaction");
          if (cl.isUndefined()) {
              qWarning() << "Class RTransaction is undefined. Use RTransaction_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTransaction('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTransaction(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RTransaction RJSHelper_qcad::js2cpp_RTransaction(RJSApi& handler, const QJSValue& v) {
          /*
          RTransaction_Wrapper* wrapper = getWrapper<RTransaction_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTransaction: no wrapper";
              Q_ASSERT(false);
              return RTransaction();
          }
          //return *(RTransaction*)wrapper->getWrappedVoid();
          RTransaction* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RTransaction: wrapped pointer is NULL";
              return RTransaction();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTransaction: not a QObject";
              return RTransaction();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTransaction_ptr: no wrapper";
              return RTransaction();
          }
          //RTransaction* ret = getWrapped_RTransaction(wrapper);
          RTransaction* ret = RTransaction_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RTransaction();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RTransaction(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTransaction: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RTransaction::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTransform(RJSApi& handler, const RTransform* v) {
          QJSEngine* engine = handler.getEngine();
          RTransform_Wrapper* ret;

          if (v==nullptr) {
              ret = new RTransform_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RTransform object:
              ret = new RTransform_Wrapper(handler, new RTransform(*v), true);
          }

          // JS: new RTransform('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTransform");
          if (cl.isUndefined()) {
              qWarning() << "Class RTransform is undefined. Use RTransform_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTransform('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTransform(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RTransform(RJSApi& handler, const RTransform& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RTransform object:
          RTransform_Wrapper* ret = new RTransform_Wrapper(handler, new RTransform(v), true);

          // JS: new RTransform('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTransform");
          if (cl.isUndefined()) {
              qWarning() << "Class RTransform is undefined. Use RTransform_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTransform('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTransform(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RTransform RJSHelper_qcad::js2cpp_RTransform(RJSApi& handler, const QJSValue& v) {
          /*
          RTransform_Wrapper* wrapper = getWrapper<RTransform_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTransform: no wrapper";
              Q_ASSERT(false);
              return RTransform();
          }
          //return *(RTransform*)wrapper->getWrappedVoid();
          RTransform* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RTransform: wrapped pointer is NULL";
              return RTransform();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTransform: not a QObject";
              return RTransform();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTransform_ptr: no wrapper";
              return RTransform();
          }
          //RTransform* ret = getWrapped_RTransform(wrapper);
          RTransform* ret = RTransform_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RTransform();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RTransform(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTransform: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RTransform::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTransformOp(RJSApi& handler, const RTransformOp* v) {
          QJSEngine* engine = handler.getEngine();
          RTransformOp_Wrapper* ret;

          if (v==nullptr) {
              ret = new RTransformOp_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RTransformOp object:
              ret = new RTransformOp_Wrapper(handler, new RTransformOp(*v), true);
          }

          // JS: new RTransformOp('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTransformOp");
          if (cl.isUndefined()) {
              qWarning() << "Class RTransformOp is undefined. Use RTransformOp_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTransformOp('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTransformOp(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RTransformOp(RJSApi& handler, const RTransformOp& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RTransformOp object:
          RTransformOp_Wrapper* ret = new RTransformOp_Wrapper(handler, new RTransformOp(v), true);

          // JS: new RTransformOp('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTransformOp");
          if (cl.isUndefined()) {
              qWarning() << "Class RTransformOp is undefined. Use RTransformOp_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTransformOp('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTransformOp(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RTransformOp RJSHelper_qcad::js2cpp_RTransformOp(RJSApi& handler, const QJSValue& v) {
          /*
          RTransformOp_Wrapper* wrapper = getWrapper<RTransformOp_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTransformOp: no wrapper";
              Q_ASSERT(false);
              return RTransformOp();
          }
          //return *(RTransformOp*)wrapper->getWrappedVoid();
          RTransformOp* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RTransformOp: wrapped pointer is NULL";
              return RTransformOp();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTransformOp: not a QObject";
              return RTransformOp();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTransformOp_ptr: no wrapper";
              return RTransformOp();
          }
          //RTransformOp* ret = getWrapped_RTransformOp(wrapper);
          RTransformOp* ret = RTransformOp_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RTransformOp();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RTransformOp(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTransformOp: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RTransformOp::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTriangle(RJSApi& handler, const RTriangle* v) {
          QJSEngine* engine = handler.getEngine();
          RTriangle_Wrapper* ret;

          if (v==nullptr) {
              ret = new RTriangle_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RTriangle object:
              ret = new RTriangle_Wrapper(handler, new RTriangle(*v), true);
          }

          // JS: new RTriangle('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTriangle");
          if (cl.isUndefined()) {
              qWarning() << "Class RTriangle is undefined. Use RTriangle_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTriangle('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTriangle(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RTriangle(RJSApi& handler, const RTriangle& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RTriangle object:
          RTriangle_Wrapper* ret = new RTriangle_Wrapper(handler, new RTriangle(v), true);

          // JS: new RTriangle('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTriangle");
          if (cl.isUndefined()) {
              qWarning() << "Class RTriangle is undefined. Use RTriangle_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTriangle('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTriangle(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RTriangle RJSHelper_qcad::js2cpp_RTriangle(RJSApi& handler, const QJSValue& v) {
          /*
          RTriangle_Wrapper* wrapper = getWrapper<RTriangle_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTriangle: no wrapper";
              Q_ASSERT(false);
              return RTriangle();
          }
          //return *(RTriangle*)wrapper->getWrappedVoid();
          RTriangle* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RTriangle: wrapped pointer is NULL";
              return RTriangle();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTriangle: not a QObject";
              return RTriangle();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTriangle_ptr: no wrapper";
              return RTriangle();
          }
          //RTriangle* ret = getWrapped_RTriangle(wrapper);
          RTriangle* ret = RTriangle_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RTriangle();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RTriangle(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTriangle: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RTriangle::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RUnit(RJSApi& handler, const RUnit* v) {
          QJSEngine* engine = handler.getEngine();
          RUnit_Wrapper* ret;

          if (v==nullptr) {
              ret = new RUnit_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RUnit object:
              ret = new RUnit_Wrapper(handler, new RUnit(*v), true);
          }

          // JS: new RUnit('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RUnit");
          if (cl.isUndefined()) {
              qWarning() << "Class RUnit is undefined. Use RUnit_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RUnit('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RUnit(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RUnit(RJSApi& handler, const RUnit& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RUnit object:
          RUnit_Wrapper* ret = new RUnit_Wrapper(handler, new RUnit(v), true);

          // JS: new RUnit('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RUnit");
          if (cl.isUndefined()) {
              qWarning() << "Class RUnit is undefined. Use RUnit_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RUnit('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RUnit(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RUnit RJSHelper_qcad::js2cpp_RUnit(RJSApi& handler, const QJSValue& v) {
          /*
          RUnit_Wrapper* wrapper = getWrapper<RUnit_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RUnit: no wrapper";
              Q_ASSERT(false);
              return RUnit();
          }
          //return *(RUnit*)wrapper->getWrappedVoid();
          RUnit* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RUnit: wrapped pointer is NULL";
              return RUnit();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RUnit: not a QObject";
              return RUnit();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RUnit_ptr: no wrapper";
              return RUnit();
          }
          //RUnit* ret = getWrapped_RUnit(wrapper);
          RUnit* ret = RUnit_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RUnit();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RUnit(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RUnit: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RUnit::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RViewFocusListenerAdapter(RJSApi& handler, const RViewFocusListenerAdapter* v) {
          QJSEngine* engine = handler.getEngine();
          RViewFocusListenerAdapter_Wrapper* ret;

          if (v==nullptr) {
              ret = new RViewFocusListenerAdapter_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RViewFocusListenerAdapter object:
              ret = new RViewFocusListenerAdapter_Wrapper(handler, new RViewFocusListenerAdapter(*v), true);
          }

          // JS: new RViewFocusListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RViewFocusListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RViewFocusListenerAdapter is undefined. Use RViewFocusListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RViewFocusListenerAdapter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RViewFocusListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RViewFocusListenerAdapter(RJSApi& handler, const RViewFocusListenerAdapter& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RViewFocusListenerAdapter object:
          RViewFocusListenerAdapter_Wrapper* ret = new RViewFocusListenerAdapter_Wrapper(handler, new RViewFocusListenerAdapter(v), true);

          // JS: new RViewFocusListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RViewFocusListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RViewFocusListenerAdapter is undefined. Use RViewFocusListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RViewFocusListenerAdapter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RViewFocusListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RViewFocusListenerAdapter RJSHelper_qcad::js2cpp_RViewFocusListenerAdapter(RJSApi& handler, const QJSValue& v) {
          /*
          RViewFocusListenerAdapter_Wrapper* wrapper = getWrapper<RViewFocusListenerAdapter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RViewFocusListenerAdapter: no wrapper";
              Q_ASSERT(false);
              return RViewFocusListenerAdapter();
          }
          //return *(RViewFocusListenerAdapter*)wrapper->getWrappedVoid();
          RViewFocusListenerAdapter* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RViewFocusListenerAdapter: wrapped pointer is NULL";
              return RViewFocusListenerAdapter();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RViewFocusListenerAdapter: not a QObject";
              return RViewFocusListenerAdapter();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RViewFocusListenerAdapter_ptr: no wrapper";
              return RViewFocusListenerAdapter();
          }
          //RViewFocusListenerAdapter* ret = getWrapped_RViewFocusListenerAdapter(wrapper);
          RViewFocusListenerAdapter* ret = RViewFocusListenerAdapter_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RViewFocusListenerAdapter();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RViewFocusListenerAdapter(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RViewFocusListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RViewFocusListenerAdapter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RViewportData(RJSApi& handler, const RViewportData* v) {
          QJSEngine* engine = handler.getEngine();
          RViewportData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RViewportData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RViewportData object:
              ret = new RViewportData_Wrapper(handler, new RViewportData(*v), true);
          }

          // JS: new RViewportData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RViewportData");
          if (cl.isUndefined()) {
              qWarning() << "Class RViewportData is undefined. Use RViewportData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RViewportData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RViewportData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RViewportData(RJSApi& handler, const RViewportData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RViewportData object:
          RViewportData_Wrapper* ret = new RViewportData_Wrapper(handler, new RViewportData(v), true);

          // JS: new RViewportData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RViewportData");
          if (cl.isUndefined()) {
              qWarning() << "Class RViewportData is undefined. Use RViewportData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RViewportData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RViewportData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RViewportData RJSHelper_qcad::js2cpp_RViewportData(RJSApi& handler, const QJSValue& v) {
          /*
          RViewportData_Wrapper* wrapper = getWrapper<RViewportData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RViewportData: no wrapper";
              Q_ASSERT(false);
              return RViewportData();
          }
          //return *(RViewportData*)wrapper->getWrappedVoid();
          RViewportData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RViewportData: wrapped pointer is NULL";
              return RViewportData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RViewportData: not a QObject";
              return RViewportData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RViewportData_ptr: no wrapper";
              return RViewportData();
          }
          //RViewportData* ret = getWrapped_RViewportData(wrapper);
          RViewportData* ret = RViewportData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RViewportData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RViewportData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RViewportData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RViewportData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RXLine(RJSApi& handler, const RXLine* v) {
          QJSEngine* engine = handler.getEngine();
          RXLine_Wrapper* ret;

          if (v==nullptr) {
              ret = new RXLine_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RXLine object:
              ret = new RXLine_Wrapper(handler, new RXLine(*v), true);
          }

          // JS: new RXLine('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RXLine");
          if (cl.isUndefined()) {
              qWarning() << "Class RXLine is undefined. Use RXLine_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RXLine('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RXLine(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RXLine(RJSApi& handler, const RXLine& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RXLine object:
          RXLine_Wrapper* ret = new RXLine_Wrapper(handler, new RXLine(v), true);

          // JS: new RXLine('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RXLine");
          if (cl.isUndefined()) {
              qWarning() << "Class RXLine is undefined. Use RXLine_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RXLine('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RXLine(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RXLine RJSHelper_qcad::js2cpp_RXLine(RJSApi& handler, const QJSValue& v) {
          /*
          RXLine_Wrapper* wrapper = getWrapper<RXLine_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RXLine: no wrapper";
              Q_ASSERT(false);
              return RXLine();
          }
          //return *(RXLine*)wrapper->getWrappedVoid();
          RXLine* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RXLine: wrapped pointer is NULL";
              return RXLine();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RXLine: not a QObject";
              return RXLine();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RXLine_ptr: no wrapper";
              return RXLine();
          }
          //RXLine* ret = getWrapped_RXLine(wrapper);
          RXLine* ret = RXLine_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RXLine();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RXLine(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RXLine: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RXLine::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RXLineData(RJSApi& handler, const RXLineData* v) {
          QJSEngine* engine = handler.getEngine();
          RXLineData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RXLineData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RXLineData object:
              ret = new RXLineData_Wrapper(handler, new RXLineData(*v), true);
          }

          // JS: new RXLineData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RXLineData");
          if (cl.isUndefined()) {
              qWarning() << "Class RXLineData is undefined. Use RXLineData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RXLineData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RXLineData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RXLineData(RJSApi& handler, const RXLineData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RXLineData object:
          RXLineData_Wrapper* ret = new RXLineData_Wrapper(handler, new RXLineData(v), true);

          // JS: new RXLineData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RXLineData");
          if (cl.isUndefined()) {
              qWarning() << "Class RXLineData is undefined. Use RXLineData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RXLineData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RXLineData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RXLineData RJSHelper_qcad::js2cpp_RXLineData(RJSApi& handler, const QJSValue& v) {
          /*
          RXLineData_Wrapper* wrapper = getWrapper<RXLineData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RXLineData: no wrapper";
              Q_ASSERT(false);
              return RXLineData();
          }
          //return *(RXLineData*)wrapper->getWrappedVoid();
          RXLineData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RXLineData: wrapped pointer is NULL";
              return RXLineData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RXLineData: not a QObject";
              return RXLineData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RXLineData_ptr: no wrapper";
              return RXLineData();
          }
          //RXLineData* ret = getWrapped_RXLineData(wrapper);
          RXLineData* ret = RXLineData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RXLineData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RXLineData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RXLineData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RXLineData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RVector(RJSApi& handler, const RVector* v) {
          QJSEngine* engine = handler.getEngine();
          RVector_Wrapper* ret;

          if (v==nullptr) {
              ret = new RVector_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RVector object:
              ret = new RVector_Wrapper(handler, new RVector(*v), true);
          }

          // JS: new RVector('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RVector");
          if (cl.isUndefined()) {
              qWarning() << "Class RVector is undefined. Use RVector_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RVector('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RVector(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RVector(RJSApi& handler, const RVector& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RVector object:
          RVector_Wrapper* ret = new RVector_Wrapper(handler, new RVector(v), true);

          // JS: new RVector('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RVector");
          if (cl.isUndefined()) {
              qWarning() << "Class RVector is undefined. Use RVector_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RVector('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RVector(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RVector RJSHelper_qcad::js2cpp_RVector(RJSApi& handler, const QJSValue& v) {
          /*
          RVector_Wrapper* wrapper = getWrapper<RVector_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RVector: no wrapper";
              Q_ASSERT(false);
              return RVector();
          }
          //return *(RVector*)wrapper->getWrappedVoid();
          RVector* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RVector: wrapped pointer is NULL";
              return RVector();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RVector: not a QObject";
              return RVector();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RVector_ptr: no wrapper";
              return RVector();
          }
          //RVector* ret = getWrapped_RVector(wrapper);
          RVector* ret = RVector_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RVector();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RVector(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RVector: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RVector::getIdStatic())).toBool();
      }
    
  // ----------------------
  // wrapped pointer types:
  // ----------------------
  
      QJSValue RJSHelper_qcad::cpp2js_RPainterPathSource(RJSApi& handler, RPainterPathSource* v) {

          
            // downcast to RTextBasedData:
            {
                RTextBasedData* o = dynamic_cast<RTextBasedData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RTextBasedData(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RPainterPathSource_Wrapper* ret = new RPainterPathSource_Wrapper(handler, v, false);

          // JS: new RPainterPathSource('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPainterPathSource");
          if (cl.isUndefined()) {
              qWarning() << "Class RPainterPathSource is undefined. Use RPainterPathSource_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPainterPathSource('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPainterPathSource(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RPainterPathSource* RJSHelper_qcad::js2cpp_RPainterPathSource_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPainterPathSource: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPainterPathSource_Wrapper* wrapper = qobject_cast<RPainterPathSource_Wrapper*>(obj);
          //RPainterPathSource_Wrapper* wrapper = dynamic_cast<RPainterPathSource_Wrapper*>(obj);
          //RPainterPathSource_Wrapper* wrapper = (RPainterPathSource_Wrapper*)(obj);
          //RPainterPathSource_Wrapper* wrapper = getWrapper<RPainterPathSource_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPainterPathSource_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RPainterPathSource(wrapper);
          return RPainterPathSource_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPainterPathSource_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPainterPathSource: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RPainterPathSource::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RShape(RJSApi& handler, RShape* v) {

          
            // downcast to RArc:
            {
                RArc* o = dynamic_cast<RArc*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RArc(handler, o);
                }
            }
          
            // downcast to RCircle:
            {
                RCircle* o = dynamic_cast<RCircle*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RCircle(handler, o);
                }
            }
          
            // downcast to REllipse:
            {
                REllipse* o = dynamic_cast<REllipse*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_REllipse(handler, o);
                }
            }
          
            // downcast to RLine:
            {
                RLine* o = dynamic_cast<RLine*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RLine(handler, o);
                }
            }
          
            // downcast to RPoint:
            {
                RPoint* o = dynamic_cast<RPoint*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RPoint(handler, o);
                }
            }
          
            // downcast to RXLine:
            {
                RXLine* o = dynamic_cast<RXLine*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RXLine(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RShape_Wrapper* ret = new RShape_Wrapper(handler, v, false);

          // JS: new RShape('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RShape");
          if (cl.isUndefined()) {
              qWarning() << "Class RShape is undefined. Use RShape_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RShape('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RShape(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RShape* RJSHelper_qcad::js2cpp_RShape_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RShape: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RShape_Wrapper* wrapper = qobject_cast<RShape_Wrapper*>(obj);
          //RShape_Wrapper* wrapper = dynamic_cast<RShape_Wrapper*>(obj);
          //RShape_Wrapper* wrapper = (RShape_Wrapper*)(obj);
          //RShape_Wrapper* wrapper = getWrapper<RShape_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RShape_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RShape(wrapper);
          return RShape_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RShape_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RShape: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RShape::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RAction(RJSApi& handler, RAction* v) {

          
            // downcast to RActionAdapter:
            {
                RActionAdapter* o = dynamic_cast<RActionAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RActionAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RAction_Wrapper* ret = new RAction_Wrapper(handler, v, false);

          // JS: new RAction('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RAction");
          if (cl.isUndefined()) {
              qWarning() << "Class RAction is undefined. Use RAction_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RAction('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RAction(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RAction* RJSHelper_qcad::js2cpp_RAction_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RAction: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RAction_Wrapper* wrapper = qobject_cast<RAction_Wrapper*>(obj);
          //RAction_Wrapper* wrapper = dynamic_cast<RAction_Wrapper*>(obj);
          //RAction_Wrapper* wrapper = (RAction_Wrapper*)(obj);
          //RAction_Wrapper* wrapper = getWrapper<RAction_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RAction_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RAction(wrapper);
          return RAction_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RAction_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RAction: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RAction::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RActionAdapter(RJSApi& handler, RActionAdapter* v) {

          

          QJSEngine* engine = handler.getEngine();
          RActionAdapter_Wrapper* ret = new RActionAdapter_Wrapper(handler, v, false);

          // JS: new RActionAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RActionAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RActionAdapter is undefined. Use RActionAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RActionAdapter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RActionAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RActionAdapter* RJSHelper_qcad::js2cpp_RActionAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RActionAdapter: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RActionAdapter_Wrapper* wrapper = qobject_cast<RActionAdapter_Wrapper*>(obj);
          //RActionAdapter_Wrapper* wrapper = dynamic_cast<RActionAdapter_Wrapper*>(obj);
          //RActionAdapter_Wrapper* wrapper = (RActionAdapter_Wrapper*)(obj);
          //RActionAdapter_Wrapper* wrapper = getWrapper<RActionAdapter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RActionAdapter_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RActionAdapter(wrapper);
          return RActionAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RActionAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RActionAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RActionAdapter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RAddObjectOperation(RJSApi& handler, RAddObjectOperation* v) {

          
            // downcast to RModifyObjectOperation:
            {
                RModifyObjectOperation* o = dynamic_cast<RModifyObjectOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RModifyObjectOperation(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RAddObjectOperation_Wrapper* ret = new RAddObjectOperation_Wrapper(handler, v, false);

          // JS: new RAddObjectOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RAddObjectOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RAddObjectOperation is undefined. Use RAddObjectOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RAddObjectOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RAddObjectOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RAddObjectOperation* RJSHelper_qcad::js2cpp_RAddObjectOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RAddObjectOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RAddObjectOperation_Wrapper* wrapper = qobject_cast<RAddObjectOperation_Wrapper*>(obj);
          //RAddObjectOperation_Wrapper* wrapper = dynamic_cast<RAddObjectOperation_Wrapper*>(obj);
          //RAddObjectOperation_Wrapper* wrapper = (RAddObjectOperation_Wrapper*)(obj);
          //RAddObjectOperation_Wrapper* wrapper = getWrapper<RAddObjectOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RAddObjectOperation_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RAddObjectOperation(wrapper);
          return RAddObjectOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RAddObjectOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RAddObjectOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RAddObjectOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RAddObjectsOperation(RJSApi& handler, RAddObjectsOperation* v) {

          
            // downcast to RAddObjectOperation:
            {
                RAddObjectOperation* o = dynamic_cast<RAddObjectOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RAddObjectOperation(handler, o);
                }
            }
          
            // downcast to RModifyObjectsOperation:
            {
                RModifyObjectsOperation* o = dynamic_cast<RModifyObjectsOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RModifyObjectsOperation(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RAddObjectsOperation_Wrapper* ret = new RAddObjectsOperation_Wrapper(handler, v, false);

          // JS: new RAddObjectsOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RAddObjectsOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RAddObjectsOperation is undefined. Use RAddObjectsOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RAddObjectsOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RAddObjectsOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RAddObjectsOperation* RJSHelper_qcad::js2cpp_RAddObjectsOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RAddObjectsOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RAddObjectsOperation_Wrapper* wrapper = qobject_cast<RAddObjectsOperation_Wrapper*>(obj);
          //RAddObjectsOperation_Wrapper* wrapper = dynamic_cast<RAddObjectsOperation_Wrapper*>(obj);
          //RAddObjectsOperation_Wrapper* wrapper = (RAddObjectsOperation_Wrapper*)(obj);
          //RAddObjectsOperation_Wrapper* wrapper = getWrapper<RAddObjectsOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RAddObjectsOperation_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RAddObjectsOperation(wrapper);
          return RAddObjectsOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RAddObjectsOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RAddObjectsOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RAddObjectsOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RArcEntity(RJSApi& handler, RArcEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RArcEntity_Wrapper* ret = new RArcEntity_Wrapper(handler, v, false);

          // JS: new RArcEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RArcEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RArcEntity is undefined. Use RArcEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RArcEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RArcEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RArcEntity* RJSHelper_qcad::js2cpp_RArcEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RArcEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RArcEntity_Wrapper* wrapper = qobject_cast<RArcEntity_Wrapper*>(obj);
          //RArcEntity_Wrapper* wrapper = dynamic_cast<RArcEntity_Wrapper*>(obj);
          //RArcEntity_Wrapper* wrapper = (RArcEntity_Wrapper*)(obj);
          //RArcEntity_Wrapper* wrapper = getWrapper<RArcEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RArcEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RArcEntity(wrapper);
          return RArcEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RArcEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RArcEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RArcEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RAttributeDefinitionEntity(RJSApi& handler, RAttributeDefinitionEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RAttributeDefinitionEntity_Wrapper* ret = new RAttributeDefinitionEntity_Wrapper(handler, v, false);

          // JS: new RAttributeDefinitionEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RAttributeDefinitionEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RAttributeDefinitionEntity is undefined. Use RAttributeDefinitionEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RAttributeDefinitionEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RAttributeDefinitionEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RAttributeDefinitionEntity* RJSHelper_qcad::js2cpp_RAttributeDefinitionEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RAttributeDefinitionEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RAttributeDefinitionEntity_Wrapper* wrapper = qobject_cast<RAttributeDefinitionEntity_Wrapper*>(obj);
          //RAttributeDefinitionEntity_Wrapper* wrapper = dynamic_cast<RAttributeDefinitionEntity_Wrapper*>(obj);
          //RAttributeDefinitionEntity_Wrapper* wrapper = (RAttributeDefinitionEntity_Wrapper*)(obj);
          //RAttributeDefinitionEntity_Wrapper* wrapper = getWrapper<RAttributeDefinitionEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RAttributeDefinitionEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RAttributeDefinitionEntity(wrapper);
          return RAttributeDefinitionEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RAttributeDefinitionEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RAttributeDefinitionEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RAttributeDefinitionEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RAttributeEntity(RJSApi& handler, RAttributeEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RAttributeEntity_Wrapper* ret = new RAttributeEntity_Wrapper(handler, v, false);

          // JS: new RAttributeEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RAttributeEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RAttributeEntity is undefined. Use RAttributeEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RAttributeEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RAttributeEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RAttributeEntity* RJSHelper_qcad::js2cpp_RAttributeEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RAttributeEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RAttributeEntity_Wrapper* wrapper = qobject_cast<RAttributeEntity_Wrapper*>(obj);
          //RAttributeEntity_Wrapper* wrapper = dynamic_cast<RAttributeEntity_Wrapper*>(obj);
          //RAttributeEntity_Wrapper* wrapper = (RAttributeEntity_Wrapper*)(obj);
          //RAttributeEntity_Wrapper* wrapper = getWrapper<RAttributeEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RAttributeEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RAttributeEntity(wrapper);
          return RAttributeEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RAttributeEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RAttributeEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RAttributeEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RBlock(RJSApi& handler, RBlock* v) {

          

          QJSEngine* engine = handler.getEngine();
          RBlock_Wrapper* ret = new RBlock_Wrapper(handler, v, false);

          // JS: new RBlock('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RBlock");
          if (cl.isUndefined()) {
              qWarning() << "Class RBlock is undefined. Use RBlock_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RBlock('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RBlock(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RBlock* RJSHelper_qcad::js2cpp_RBlock_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RBlock: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RBlock_Wrapper* wrapper = qobject_cast<RBlock_Wrapper*>(obj);
          //RBlock_Wrapper* wrapper = dynamic_cast<RBlock_Wrapper*>(obj);
          //RBlock_Wrapper* wrapper = (RBlock_Wrapper*)(obj);
          //RBlock_Wrapper* wrapper = getWrapper<RBlock_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RBlock_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RBlock(wrapper);
          return RBlock_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RBlock_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RBlock: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RBlock::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RBlockListener(RJSApi& handler, RBlockListener* v) {

          
            // downcast to RBlockListenerAdapter:
            {
                RBlockListenerAdapter* o = dynamic_cast<RBlockListenerAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RBlockListenerAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RBlockListener_Wrapper* ret = new RBlockListener_Wrapper(handler, v, false);

          // JS: new RBlockListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RBlockListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RBlockListener is undefined. Use RBlockListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RBlockListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RBlockListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RBlockListener* RJSHelper_qcad::js2cpp_RBlockListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RBlockListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RBlockListener_Wrapper* wrapper = qobject_cast<RBlockListener_Wrapper*>(obj);
          //RBlockListener_Wrapper* wrapper = dynamic_cast<RBlockListener_Wrapper*>(obj);
          //RBlockListener_Wrapper* wrapper = (RBlockListener_Wrapper*)(obj);
          //RBlockListener_Wrapper* wrapper = getWrapper<RBlockListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RBlockListener_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RBlockListener(wrapper);
          return RBlockListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RBlockListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RBlockListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RBlockListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RBlockReferenceEntity(RJSApi& handler, RBlockReferenceEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RBlockReferenceEntity_Wrapper* ret = new RBlockReferenceEntity_Wrapper(handler, v, false);

          // JS: new RBlockReferenceEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RBlockReferenceEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RBlockReferenceEntity is undefined. Use RBlockReferenceEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RBlockReferenceEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RBlockReferenceEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RBlockReferenceEntity* RJSHelper_qcad::js2cpp_RBlockReferenceEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RBlockReferenceEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RBlockReferenceEntity_Wrapper* wrapper = qobject_cast<RBlockReferenceEntity_Wrapper*>(obj);
          //RBlockReferenceEntity_Wrapper* wrapper = dynamic_cast<RBlockReferenceEntity_Wrapper*>(obj);
          //RBlockReferenceEntity_Wrapper* wrapper = (RBlockReferenceEntity_Wrapper*)(obj);
          //RBlockReferenceEntity_Wrapper* wrapper = getWrapper<RBlockReferenceEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RBlockReferenceEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RBlockReferenceEntity(wrapper);
          return RBlockReferenceEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RBlockReferenceEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RBlockReferenceEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RBlockReferenceEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RChangePropertyOperation(RJSApi& handler, RChangePropertyOperation* v) {

          

          QJSEngine* engine = handler.getEngine();
          RChangePropertyOperation_Wrapper* ret = new RChangePropertyOperation_Wrapper(handler, v, false);

          // JS: new RChangePropertyOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RChangePropertyOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RChangePropertyOperation is undefined. Use RChangePropertyOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RChangePropertyOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RChangePropertyOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RChangePropertyOperation* RJSHelper_qcad::js2cpp_RChangePropertyOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RChangePropertyOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RChangePropertyOperation_Wrapper* wrapper = qobject_cast<RChangePropertyOperation_Wrapper*>(obj);
          //RChangePropertyOperation_Wrapper* wrapper = dynamic_cast<RChangePropertyOperation_Wrapper*>(obj);
          //RChangePropertyOperation_Wrapper* wrapper = (RChangePropertyOperation_Wrapper*)(obj);
          //RChangePropertyOperation_Wrapper* wrapper = getWrapper<RChangePropertyOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RChangePropertyOperation_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RChangePropertyOperation(wrapper);
          return RChangePropertyOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RChangePropertyOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RChangePropertyOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RChangePropertyOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RCircleEntity(RJSApi& handler, RCircleEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RCircleEntity_Wrapper* ret = new RCircleEntity_Wrapper(handler, v, false);

          // JS: new RCircleEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCircleEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RCircleEntity is undefined. Use RCircleEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCircleEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCircleEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RCircleEntity* RJSHelper_qcad::js2cpp_RCircleEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RCircleEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RCircleEntity_Wrapper* wrapper = qobject_cast<RCircleEntity_Wrapper*>(obj);
          //RCircleEntity_Wrapper* wrapper = dynamic_cast<RCircleEntity_Wrapper*>(obj);
          //RCircleEntity_Wrapper* wrapper = (RCircleEntity_Wrapper*)(obj);
          //RCircleEntity_Wrapper* wrapper = getWrapper<RCircleEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCircleEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RCircleEntity(wrapper);
          return RCircleEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RCircleEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RCircleEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RCircleEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RClickReferencePointOperation(RJSApi& handler, RClickReferencePointOperation* v) {

          

          QJSEngine* engine = handler.getEngine();
          RClickReferencePointOperation_Wrapper* ret = new RClickReferencePointOperation_Wrapper(handler, v, false);

          // JS: new RClickReferencePointOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RClickReferencePointOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RClickReferencePointOperation is undefined. Use RClickReferencePointOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RClickReferencePointOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RClickReferencePointOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RClickReferencePointOperation* RJSHelper_qcad::js2cpp_RClickReferencePointOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RClickReferencePointOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RClickReferencePointOperation_Wrapper* wrapper = qobject_cast<RClickReferencePointOperation_Wrapper*>(obj);
          //RClickReferencePointOperation_Wrapper* wrapper = dynamic_cast<RClickReferencePointOperation_Wrapper*>(obj);
          //RClickReferencePointOperation_Wrapper* wrapper = (RClickReferencePointOperation_Wrapper*)(obj);
          //RClickReferencePointOperation_Wrapper* wrapper = getWrapper<RClickReferencePointOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RClickReferencePointOperation_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RClickReferencePointOperation(wrapper);
          return RClickReferencePointOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RClickReferencePointOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RClickReferencePointOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RClickReferencePointOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RClipboardOperation(RJSApi& handler, RClipboardOperation* v) {

          
            // downcast to RCopyOperation:
            {
                RCopyOperation* o = dynamic_cast<RCopyOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RCopyOperation(handler, o);
                }
            }
          
            // downcast to RDeleteSelectionOperation:
            {
                RDeleteSelectionOperation* o = dynamic_cast<RDeleteSelectionOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDeleteSelectionOperation(handler, o);
                }
            }
          
            // downcast to RPasteOperation:
            {
                RPasteOperation* o = dynamic_cast<RPasteOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RPasteOperation(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RClipboardOperation_Wrapper* ret = new RClipboardOperation_Wrapper(handler, v, false);

          // JS: new RClipboardOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RClipboardOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RClipboardOperation is undefined. Use RClipboardOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RClipboardOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RClipboardOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RClipboardOperation* RJSHelper_qcad::js2cpp_RClipboardOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RClipboardOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RClipboardOperation_Wrapper* wrapper = qobject_cast<RClipboardOperation_Wrapper*>(obj);
          //RClipboardOperation_Wrapper* wrapper = dynamic_cast<RClipboardOperation_Wrapper*>(obj);
          //RClipboardOperation_Wrapper* wrapper = (RClipboardOperation_Wrapper*)(obj);
          //RClipboardOperation_Wrapper* wrapper = getWrapper<RClipboardOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RClipboardOperation_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RClipboardOperation(wrapper);
          return RClipboardOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RClipboardOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RClipboardOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RClipboardOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RCloseCurrentEvent(RJSApi& handler, RCloseCurrentEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          RCloseCurrentEvent_Wrapper* ret = new RCloseCurrentEvent_Wrapper(handler, v, false);

          // JS: new RCloseCurrentEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCloseCurrentEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class RCloseCurrentEvent is undefined. Use RCloseCurrentEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCloseCurrentEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCloseCurrentEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RCloseCurrentEvent* RJSHelper_qcad::js2cpp_RCloseCurrentEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RCloseCurrentEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RCloseCurrentEvent_Wrapper* wrapper = qobject_cast<RCloseCurrentEvent_Wrapper*>(obj);
          //RCloseCurrentEvent_Wrapper* wrapper = dynamic_cast<RCloseCurrentEvent_Wrapper*>(obj);
          //RCloseCurrentEvent_Wrapper* wrapper = (RCloseCurrentEvent_Wrapper*)(obj);
          //RCloseCurrentEvent_Wrapper* wrapper = getWrapper<RCloseCurrentEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCloseCurrentEvent_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RCloseCurrentEvent(wrapper);
          return RCloseCurrentEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RCloseCurrentEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RCloseCurrentEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RCloseCurrentEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RCommandEvent(RJSApi& handler, RCommandEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          RCommandEvent_Wrapper* ret = new RCommandEvent_Wrapper(handler, v, false);

          // JS: new RCommandEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCommandEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class RCommandEvent is undefined. Use RCommandEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCommandEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCommandEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RCommandEvent* RJSHelper_qcad::js2cpp_RCommandEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RCommandEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RCommandEvent_Wrapper* wrapper = qobject_cast<RCommandEvent_Wrapper*>(obj);
          //RCommandEvent_Wrapper* wrapper = dynamic_cast<RCommandEvent_Wrapper*>(obj);
          //RCommandEvent_Wrapper* wrapper = (RCommandEvent_Wrapper*)(obj);
          //RCommandEvent_Wrapper* wrapper = getWrapper<RCommandEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCommandEvent_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RCommandEvent(wrapper);
          return RCommandEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RCommandEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RCommandEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RCommandEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RCoordinateEvent(RJSApi& handler, RCoordinateEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          RCoordinateEvent_Wrapper* ret = new RCoordinateEvent_Wrapper(handler, v, false);

          // JS: new RCoordinateEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCoordinateEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class RCoordinateEvent is undefined. Use RCoordinateEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCoordinateEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCoordinateEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RCoordinateEvent* RJSHelper_qcad::js2cpp_RCoordinateEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RCoordinateEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RCoordinateEvent_Wrapper* wrapper = qobject_cast<RCoordinateEvent_Wrapper*>(obj);
          //RCoordinateEvent_Wrapper* wrapper = dynamic_cast<RCoordinateEvent_Wrapper*>(obj);
          //RCoordinateEvent_Wrapper* wrapper = (RCoordinateEvent_Wrapper*)(obj);
          //RCoordinateEvent_Wrapper* wrapper = getWrapper<RCoordinateEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCoordinateEvent_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RCoordinateEvent(wrapper);
          return RCoordinateEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RCoordinateEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RCoordinateEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RCoordinateEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RCoordinateListener(RJSApi& handler, RCoordinateListener* v) {

          
            // downcast to RCoordinateListenerAdapter:
            {
                RCoordinateListenerAdapter* o = dynamic_cast<RCoordinateListenerAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RCoordinateListenerAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RCoordinateListener_Wrapper* ret = new RCoordinateListener_Wrapper(handler, v, false);

          // JS: new RCoordinateListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCoordinateListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RCoordinateListener is undefined. Use RCoordinateListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCoordinateListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCoordinateListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RCoordinateListener* RJSHelper_qcad::js2cpp_RCoordinateListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RCoordinateListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RCoordinateListener_Wrapper* wrapper = qobject_cast<RCoordinateListener_Wrapper*>(obj);
          //RCoordinateListener_Wrapper* wrapper = dynamic_cast<RCoordinateListener_Wrapper*>(obj);
          //RCoordinateListener_Wrapper* wrapper = (RCoordinateListener_Wrapper*)(obj);
          //RCoordinateListener_Wrapper* wrapper = getWrapper<RCoordinateListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCoordinateListener_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RCoordinateListener(wrapper);
          return RCoordinateListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RCoordinateListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RCoordinateListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RCoordinateListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RCopyOperation(RJSApi& handler, RCopyOperation* v) {

          

          QJSEngine* engine = handler.getEngine();
          RCopyOperation_Wrapper* ret = new RCopyOperation_Wrapper(handler, v, false);

          // JS: new RCopyOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCopyOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RCopyOperation is undefined. Use RCopyOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCopyOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCopyOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RCopyOperation* RJSHelper_qcad::js2cpp_RCopyOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RCopyOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RCopyOperation_Wrapper* wrapper = qobject_cast<RCopyOperation_Wrapper*>(obj);
          //RCopyOperation_Wrapper* wrapper = dynamic_cast<RCopyOperation_Wrapper*>(obj);
          //RCopyOperation_Wrapper* wrapper = (RCopyOperation_Wrapper*)(obj);
          //RCopyOperation_Wrapper* wrapper = getWrapper<RCopyOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCopyOperation_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RCopyOperation(wrapper);
          return RCopyOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RCopyOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RCopyOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RCopyOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDeleteAllEntitiesOperation(RJSApi& handler, RDeleteAllEntitiesOperation* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDeleteAllEntitiesOperation_Wrapper* ret = new RDeleteAllEntitiesOperation_Wrapper(handler, v, false);

          // JS: new RDeleteAllEntitiesOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDeleteAllEntitiesOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RDeleteAllEntitiesOperation is undefined. Use RDeleteAllEntitiesOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDeleteAllEntitiesOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDeleteAllEntitiesOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDeleteAllEntitiesOperation* RJSHelper_qcad::js2cpp_RDeleteAllEntitiesOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDeleteAllEntitiesOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDeleteAllEntitiesOperation_Wrapper* wrapper = qobject_cast<RDeleteAllEntitiesOperation_Wrapper*>(obj);
          //RDeleteAllEntitiesOperation_Wrapper* wrapper = dynamic_cast<RDeleteAllEntitiesOperation_Wrapper*>(obj);
          //RDeleteAllEntitiesOperation_Wrapper* wrapper = (RDeleteAllEntitiesOperation_Wrapper*)(obj);
          //RDeleteAllEntitiesOperation_Wrapper* wrapper = getWrapper<RDeleteAllEntitiesOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDeleteAllEntitiesOperation_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RDeleteAllEntitiesOperation(wrapper);
          return RDeleteAllEntitiesOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDeleteAllEntitiesOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDeleteAllEntitiesOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDeleteAllEntitiesOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDeleteObjectOperation(RJSApi& handler, RDeleteObjectOperation* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDeleteObjectOperation_Wrapper* ret = new RDeleteObjectOperation_Wrapper(handler, v, false);

          // JS: new RDeleteObjectOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDeleteObjectOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RDeleteObjectOperation is undefined. Use RDeleteObjectOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDeleteObjectOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDeleteObjectOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDeleteObjectOperation* RJSHelper_qcad::js2cpp_RDeleteObjectOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDeleteObjectOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDeleteObjectOperation_Wrapper* wrapper = qobject_cast<RDeleteObjectOperation_Wrapper*>(obj);
          //RDeleteObjectOperation_Wrapper* wrapper = dynamic_cast<RDeleteObjectOperation_Wrapper*>(obj);
          //RDeleteObjectOperation_Wrapper* wrapper = (RDeleteObjectOperation_Wrapper*)(obj);
          //RDeleteObjectOperation_Wrapper* wrapper = getWrapper<RDeleteObjectOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDeleteObjectOperation_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RDeleteObjectOperation(wrapper);
          return RDeleteObjectOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDeleteObjectOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDeleteObjectOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDeleteObjectOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDeleteObjectsOperation(RJSApi& handler, RDeleteObjectsOperation* v) {

          
            // downcast to RDeleteObjectOperation:
            {
                RDeleteObjectOperation* o = dynamic_cast<RDeleteObjectOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDeleteObjectOperation(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RDeleteObjectsOperation_Wrapper* ret = new RDeleteObjectsOperation_Wrapper(handler, v, false);

          // JS: new RDeleteObjectsOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDeleteObjectsOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RDeleteObjectsOperation is undefined. Use RDeleteObjectsOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDeleteObjectsOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDeleteObjectsOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDeleteObjectsOperation* RJSHelper_qcad::js2cpp_RDeleteObjectsOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDeleteObjectsOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDeleteObjectsOperation_Wrapper* wrapper = qobject_cast<RDeleteObjectsOperation_Wrapper*>(obj);
          //RDeleteObjectsOperation_Wrapper* wrapper = dynamic_cast<RDeleteObjectsOperation_Wrapper*>(obj);
          //RDeleteObjectsOperation_Wrapper* wrapper = (RDeleteObjectsOperation_Wrapper*)(obj);
          //RDeleteObjectsOperation_Wrapper* wrapper = getWrapper<RDeleteObjectsOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDeleteObjectsOperation_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RDeleteObjectsOperation(wrapper);
          return RDeleteObjectsOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDeleteObjectsOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDeleteObjectsOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDeleteObjectsOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDeleteSelectionOperation(RJSApi& handler, RDeleteSelectionOperation* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDeleteSelectionOperation_Wrapper* ret = new RDeleteSelectionOperation_Wrapper(handler, v, false);

          // JS: new RDeleteSelectionOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDeleteSelectionOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RDeleteSelectionOperation is undefined. Use RDeleteSelectionOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDeleteSelectionOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDeleteSelectionOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDeleteSelectionOperation* RJSHelper_qcad::js2cpp_RDeleteSelectionOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDeleteSelectionOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDeleteSelectionOperation_Wrapper* wrapper = qobject_cast<RDeleteSelectionOperation_Wrapper*>(obj);
          //RDeleteSelectionOperation_Wrapper* wrapper = dynamic_cast<RDeleteSelectionOperation_Wrapper*>(obj);
          //RDeleteSelectionOperation_Wrapper* wrapper = (RDeleteSelectionOperation_Wrapper*)(obj);
          //RDeleteSelectionOperation_Wrapper* wrapper = getWrapper<RDeleteSelectionOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDeleteSelectionOperation_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RDeleteSelectionOperation(wrapper);
          return RDeleteSelectionOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDeleteSelectionOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDeleteSelectionOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDeleteSelectionOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimAlignedEntity(RJSApi& handler, RDimAlignedEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDimAlignedEntity_Wrapper* ret = new RDimAlignedEntity_Wrapper(handler, v, false);

          // JS: new RDimAlignedEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAlignedEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAlignedEntity is undefined. Use RDimAlignedEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimAlignedEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimAlignedEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimAlignedEntity* RJSHelper_qcad::js2cpp_RDimAlignedEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimAlignedEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimAlignedEntity_Wrapper* wrapper = qobject_cast<RDimAlignedEntity_Wrapper*>(obj);
          //RDimAlignedEntity_Wrapper* wrapper = dynamic_cast<RDimAlignedEntity_Wrapper*>(obj);
          //RDimAlignedEntity_Wrapper* wrapper = (RDimAlignedEntity_Wrapper*)(obj);
          //RDimAlignedEntity_Wrapper* wrapper = getWrapper<RDimAlignedEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimAlignedEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RDimAlignedEntity(wrapper);
          return RDimAlignedEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimAlignedEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimAlignedEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimAlignedEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimAngular2LEntity(RJSApi& handler, RDimAngular2LEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDimAngular2LEntity_Wrapper* ret = new RDimAngular2LEntity_Wrapper(handler, v, false);

          // JS: new RDimAngular2LEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAngular2LEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAngular2LEntity is undefined. Use RDimAngular2LEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimAngular2LEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimAngular2LEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimAngular2LEntity* RJSHelper_qcad::js2cpp_RDimAngular2LEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimAngular2LEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimAngular2LEntity_Wrapper* wrapper = qobject_cast<RDimAngular2LEntity_Wrapper*>(obj);
          //RDimAngular2LEntity_Wrapper* wrapper = dynamic_cast<RDimAngular2LEntity_Wrapper*>(obj);
          //RDimAngular2LEntity_Wrapper* wrapper = (RDimAngular2LEntity_Wrapper*)(obj);
          //RDimAngular2LEntity_Wrapper* wrapper = getWrapper<RDimAngular2LEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimAngular2LEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RDimAngular2LEntity(wrapper);
          return RDimAngular2LEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimAngular2LEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimAngular2LEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimAngular2LEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimAngular3PEntity(RJSApi& handler, RDimAngular3PEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDimAngular3PEntity_Wrapper* ret = new RDimAngular3PEntity_Wrapper(handler, v, false);

          // JS: new RDimAngular3PEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAngular3PEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAngular3PEntity is undefined. Use RDimAngular3PEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimAngular3PEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimAngular3PEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimAngular3PEntity* RJSHelper_qcad::js2cpp_RDimAngular3PEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimAngular3PEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimAngular3PEntity_Wrapper* wrapper = qobject_cast<RDimAngular3PEntity_Wrapper*>(obj);
          //RDimAngular3PEntity_Wrapper* wrapper = dynamic_cast<RDimAngular3PEntity_Wrapper*>(obj);
          //RDimAngular3PEntity_Wrapper* wrapper = (RDimAngular3PEntity_Wrapper*)(obj);
          //RDimAngular3PEntity_Wrapper* wrapper = getWrapper<RDimAngular3PEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimAngular3PEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RDimAngular3PEntity(wrapper);
          return RDimAngular3PEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimAngular3PEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimAngular3PEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimAngular3PEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimAngularData(RJSApi& handler, RDimAngularData* v) {

          
            // downcast to RDimAngular2LData:
            {
                RDimAngular2LData* o = dynamic_cast<RDimAngular2LData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimAngular2LData(handler, o);
                }
            }
          
            // downcast to RDimAngular3PData:
            {
                RDimAngular3PData* o = dynamic_cast<RDimAngular3PData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimAngular3PData(handler, o);
                }
            }
          
            // downcast to RDimArcLengthData:
            {
                RDimArcLengthData* o = dynamic_cast<RDimArcLengthData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimArcLengthData(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RDimAngularData_Wrapper* ret = new RDimAngularData_Wrapper(handler, v, false);

          // JS: new RDimAngularData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAngularData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAngularData is undefined. Use RDimAngularData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimAngularData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimAngularData(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimAngularData* RJSHelper_qcad::js2cpp_RDimAngularData_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimAngularData: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimAngularData_Wrapper* wrapper = qobject_cast<RDimAngularData_Wrapper*>(obj);
          //RDimAngularData_Wrapper* wrapper = dynamic_cast<RDimAngularData_Wrapper*>(obj);
          //RDimAngularData_Wrapper* wrapper = (RDimAngularData_Wrapper*)(obj);
          //RDimAngularData_Wrapper* wrapper = getWrapper<RDimAngularData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimAngularData_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RDimAngularData(wrapper);
          return RDimAngularData_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimAngularData_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimAngularData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimAngularData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimAngularEntity(RJSApi& handler, RDimAngularEntity* v) {

          
            // downcast to RDimAngular2LEntity:
            {
                RDimAngular2LEntity* o = dynamic_cast<RDimAngular2LEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimAngular2LEntity(handler, o);
                }
            }
          
            // downcast to RDimAngular3PEntity:
            {
                RDimAngular3PEntity* o = dynamic_cast<RDimAngular3PEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimAngular3PEntity(handler, o);
                }
            }
          
            // downcast to RDimArcLengthEntity:
            {
                RDimArcLengthEntity* o = dynamic_cast<RDimArcLengthEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimArcLengthEntity(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RDimAngularEntity_Wrapper* ret = new RDimAngularEntity_Wrapper(handler, v, false);

          // JS: new RDimAngularEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAngularEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAngularEntity is undefined. Use RDimAngularEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimAngularEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimAngularEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimAngularEntity* RJSHelper_qcad::js2cpp_RDimAngularEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimAngularEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimAngularEntity_Wrapper* wrapper = qobject_cast<RDimAngularEntity_Wrapper*>(obj);
          //RDimAngularEntity_Wrapper* wrapper = dynamic_cast<RDimAngularEntity_Wrapper*>(obj);
          //RDimAngularEntity_Wrapper* wrapper = (RDimAngularEntity_Wrapper*)(obj);
          //RDimAngularEntity_Wrapper* wrapper = getWrapper<RDimAngularEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimAngularEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RDimAngularEntity(wrapper);
          return RDimAngularEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimAngularEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimAngularEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimAngularEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimArcLengthEntity(RJSApi& handler, RDimArcLengthEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDimArcLengthEntity_Wrapper* ret = new RDimArcLengthEntity_Wrapper(handler, v, false);

          // JS: new RDimArcLengthEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimArcLengthEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimArcLengthEntity is undefined. Use RDimArcLengthEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimArcLengthEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimArcLengthEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimArcLengthEntity* RJSHelper_qcad::js2cpp_RDimArcLengthEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimArcLengthEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimArcLengthEntity_Wrapper* wrapper = qobject_cast<RDimArcLengthEntity_Wrapper*>(obj);
          //RDimArcLengthEntity_Wrapper* wrapper = dynamic_cast<RDimArcLengthEntity_Wrapper*>(obj);
          //RDimArcLengthEntity_Wrapper* wrapper = (RDimArcLengthEntity_Wrapper*)(obj);
          //RDimArcLengthEntity_Wrapper* wrapper = getWrapper<RDimArcLengthEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimArcLengthEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RDimArcLengthEntity(wrapper);
          return RDimArcLengthEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimArcLengthEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimArcLengthEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimArcLengthEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimDiametricEntity(RJSApi& handler, RDimDiametricEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDimDiametricEntity_Wrapper* ret = new RDimDiametricEntity_Wrapper(handler, v, false);

          // JS: new RDimDiametricEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimDiametricEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimDiametricEntity is undefined. Use RDimDiametricEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimDiametricEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimDiametricEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimDiametricEntity* RJSHelper_qcad::js2cpp_RDimDiametricEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimDiametricEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimDiametricEntity_Wrapper* wrapper = qobject_cast<RDimDiametricEntity_Wrapper*>(obj);
          //RDimDiametricEntity_Wrapper* wrapper = dynamic_cast<RDimDiametricEntity_Wrapper*>(obj);
          //RDimDiametricEntity_Wrapper* wrapper = (RDimDiametricEntity_Wrapper*)(obj);
          //RDimDiametricEntity_Wrapper* wrapper = getWrapper<RDimDiametricEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimDiametricEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RDimDiametricEntity(wrapper);
          return RDimDiametricEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimDiametricEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimDiametricEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimDiametricEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimLinearEntity(RJSApi& handler, RDimLinearEntity* v) {

          
            // downcast to RDimAlignedEntity:
            {
                RDimAlignedEntity* o = dynamic_cast<RDimAlignedEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimAlignedEntity(handler, o);
                }
            }
          
            // downcast to RDimRotatedEntity:
            {
                RDimRotatedEntity* o = dynamic_cast<RDimRotatedEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimRotatedEntity(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RDimLinearEntity_Wrapper* ret = new RDimLinearEntity_Wrapper(handler, v, false);

          // JS: new RDimLinearEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimLinearEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimLinearEntity is undefined. Use RDimLinearEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimLinearEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimLinearEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimLinearEntity* RJSHelper_qcad::js2cpp_RDimLinearEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimLinearEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimLinearEntity_Wrapper* wrapper = qobject_cast<RDimLinearEntity_Wrapper*>(obj);
          //RDimLinearEntity_Wrapper* wrapper = dynamic_cast<RDimLinearEntity_Wrapper*>(obj);
          //RDimLinearEntity_Wrapper* wrapper = (RDimLinearEntity_Wrapper*)(obj);
          //RDimLinearEntity_Wrapper* wrapper = getWrapper<RDimLinearEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimLinearEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RDimLinearEntity(wrapper);
          return RDimLinearEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimLinearEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimLinearEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimLinearEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimOrdinateEntity(RJSApi& handler, RDimOrdinateEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDimOrdinateEntity_Wrapper* ret = new RDimOrdinateEntity_Wrapper(handler, v, false);

          // JS: new RDimOrdinateEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimOrdinateEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimOrdinateEntity is undefined. Use RDimOrdinateEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimOrdinateEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimOrdinateEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimOrdinateEntity* RJSHelper_qcad::js2cpp_RDimOrdinateEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimOrdinateEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimOrdinateEntity_Wrapper* wrapper = qobject_cast<RDimOrdinateEntity_Wrapper*>(obj);
          //RDimOrdinateEntity_Wrapper* wrapper = dynamic_cast<RDimOrdinateEntity_Wrapper*>(obj);
          //RDimOrdinateEntity_Wrapper* wrapper = (RDimOrdinateEntity_Wrapper*)(obj);
          //RDimOrdinateEntity_Wrapper* wrapper = getWrapper<RDimOrdinateEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimOrdinateEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RDimOrdinateEntity(wrapper);
          return RDimOrdinateEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimOrdinateEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimOrdinateEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimOrdinateEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimRadialEntity(RJSApi& handler, RDimRadialEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDimRadialEntity_Wrapper* ret = new RDimRadialEntity_Wrapper(handler, v, false);

          // JS: new RDimRadialEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimRadialEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimRadialEntity is undefined. Use RDimRadialEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimRadialEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimRadialEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimRadialEntity* RJSHelper_qcad::js2cpp_RDimRadialEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimRadialEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimRadialEntity_Wrapper* wrapper = qobject_cast<RDimRadialEntity_Wrapper*>(obj);
          //RDimRadialEntity_Wrapper* wrapper = dynamic_cast<RDimRadialEntity_Wrapper*>(obj);
          //RDimRadialEntity_Wrapper* wrapper = (RDimRadialEntity_Wrapper*)(obj);
          //RDimRadialEntity_Wrapper* wrapper = getWrapper<RDimRadialEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimRadialEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RDimRadialEntity(wrapper);
          return RDimRadialEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimRadialEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimRadialEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimRadialEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimRotatedEntity(RJSApi& handler, RDimRotatedEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDimRotatedEntity_Wrapper* ret = new RDimRotatedEntity_Wrapper(handler, v, false);

          // JS: new RDimRotatedEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimRotatedEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimRotatedEntity is undefined. Use RDimRotatedEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimRotatedEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimRotatedEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimRotatedEntity* RJSHelper_qcad::js2cpp_RDimRotatedEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimRotatedEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimRotatedEntity_Wrapper* wrapper = qobject_cast<RDimRotatedEntity_Wrapper*>(obj);
          //RDimRotatedEntity_Wrapper* wrapper = dynamic_cast<RDimRotatedEntity_Wrapper*>(obj);
          //RDimRotatedEntity_Wrapper* wrapper = (RDimRotatedEntity_Wrapper*)(obj);
          //RDimRotatedEntity_Wrapper* wrapper = getWrapper<RDimRotatedEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimRotatedEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RDimRotatedEntity(wrapper);
          return RDimRotatedEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimRotatedEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimRotatedEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimRotatedEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimStyle(RJSApi& handler, RDimStyle* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDimStyle_Wrapper* ret = new RDimStyle_Wrapper(handler, v, false);

          // JS: new RDimStyle('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimStyle");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimStyle is undefined. Use RDimStyle_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimStyle('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimStyle(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimStyle* RJSHelper_qcad::js2cpp_RDimStyle_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimStyle: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimStyle_Wrapper* wrapper = qobject_cast<RDimStyle_Wrapper*>(obj);
          //RDimStyle_Wrapper* wrapper = dynamic_cast<RDimStyle_Wrapper*>(obj);
          //RDimStyle_Wrapper* wrapper = (RDimStyle_Wrapper*)(obj);
          //RDimStyle_Wrapper* wrapper = getWrapper<RDimStyle_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimStyle_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RDimStyle(wrapper);
          return RDimStyle_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimStyle_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimStyle: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimStyle::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimensionData(RJSApi& handler, RDimensionData* v) {

          
            // downcast to RDimAngularData:
            {
                RDimAngularData* o = dynamic_cast<RDimAngularData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimAngularData(handler, o);
                }
            }
          
            // downcast to RDimDiametricData:
            {
                RDimDiametricData* o = dynamic_cast<RDimDiametricData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimDiametricData(handler, o);
                }
            }
          
            // downcast to RDimLinearData:
            {
                RDimLinearData* o = dynamic_cast<RDimLinearData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimLinearData(handler, o);
                }
            }
          
            // downcast to RDimOrdinateData:
            {
                RDimOrdinateData* o = dynamic_cast<RDimOrdinateData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimOrdinateData(handler, o);
                }
            }
          
            // downcast to RDimRadialData:
            {
                RDimRadialData* o = dynamic_cast<RDimRadialData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimRadialData(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RDimensionData_Wrapper* ret = new RDimensionData_Wrapper(handler, v, false);

          // JS: new RDimensionData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimensionData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimensionData is undefined. Use RDimensionData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimensionData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimensionData(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimensionData* RJSHelper_qcad::js2cpp_RDimensionData_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimensionData: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimensionData_Wrapper* wrapper = qobject_cast<RDimensionData_Wrapper*>(obj);
          //RDimensionData_Wrapper* wrapper = dynamic_cast<RDimensionData_Wrapper*>(obj);
          //RDimensionData_Wrapper* wrapper = (RDimensionData_Wrapper*)(obj);
          //RDimensionData_Wrapper* wrapper = getWrapper<RDimensionData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimensionData_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RDimensionData(wrapper);
          return RDimensionData_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimensionData_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimensionData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimensionData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimensionEntity(RJSApi& handler, RDimensionEntity* v) {

          
            // downcast to RDimAngularEntity:
            {
                RDimAngularEntity* o = dynamic_cast<RDimAngularEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimAngularEntity(handler, o);
                }
            }
          
            // downcast to RDimDiametricEntity:
            {
                RDimDiametricEntity* o = dynamic_cast<RDimDiametricEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimDiametricEntity(handler, o);
                }
            }
          
            // downcast to RDimLinearEntity:
            {
                RDimLinearEntity* o = dynamic_cast<RDimLinearEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimLinearEntity(handler, o);
                }
            }
          
            // downcast to RDimOrdinateEntity:
            {
                RDimOrdinateEntity* o = dynamic_cast<RDimOrdinateEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimOrdinateEntity(handler, o);
                }
            }
          
            // downcast to RDimRadialEntity:
            {
                RDimRadialEntity* o = dynamic_cast<RDimRadialEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimRadialEntity(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RDimensionEntity_Wrapper* ret = new RDimensionEntity_Wrapper(handler, v, false);

          // JS: new RDimensionEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimensionEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimensionEntity is undefined. Use RDimensionEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimensionEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimensionEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimensionEntity* RJSHelper_qcad::js2cpp_RDimensionEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimensionEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimensionEntity_Wrapper* wrapper = qobject_cast<RDimensionEntity_Wrapper*>(obj);
          //RDimensionEntity_Wrapper* wrapper = dynamic_cast<RDimensionEntity_Wrapper*>(obj);
          //RDimensionEntity_Wrapper* wrapper = (RDimensionEntity_Wrapper*)(obj);
          //RDimensionEntity_Wrapper* wrapper = getWrapper<RDimensionEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimensionEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RDimensionEntity(wrapper);
          return RDimensionEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimensionEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimensionEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimensionEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDirected(RJSApi& handler, RDirected* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDirected_Wrapper* ret = new RDirected_Wrapper(handler, v, false);

          // JS: new RDirected('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDirected");
          if (cl.isUndefined()) {
              qWarning() << "Class RDirected is undefined. Use RDirected_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDirected('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDirected(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDirected* RJSHelper_qcad::js2cpp_RDirected_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDirected: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDirected_Wrapper* wrapper = qobject_cast<RDirected_Wrapper*>(obj);
          //RDirected_Wrapper* wrapper = dynamic_cast<RDirected_Wrapper*>(obj);
          //RDirected_Wrapper* wrapper = (RDirected_Wrapper*)(obj);
          //RDirected_Wrapper* wrapper = getWrapper<RDirected_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDirected_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RDirected(wrapper);
          return RDirected_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDirected_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDirected: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDirected::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDocument(RJSApi& handler, RDocument* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDocument_Wrapper* ret = new RDocument_Wrapper(handler, v, false);

          // JS: new RDocument('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDocument");
          if (cl.isUndefined()) {
              qWarning() << "Class RDocument is undefined. Use RDocument_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDocument('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDocument(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDocument* RJSHelper_qcad::js2cpp_RDocument_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDocument: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDocument_Wrapper* wrapper = qobject_cast<RDocument_Wrapper*>(obj);
          //RDocument_Wrapper* wrapper = dynamic_cast<RDocument_Wrapper*>(obj);
          //RDocument_Wrapper* wrapper = (RDocument_Wrapper*)(obj);
          //RDocument_Wrapper* wrapper = getWrapper<RDocument_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDocument_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RDocument(wrapper);
          return RDocument_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDocument_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDocument: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDocument::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDocumentInterface(RJSApi& handler, RDocumentInterface* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDocumentInterface_Wrapper* ret = new RDocumentInterface_Wrapper(handler, v, false);

          // JS: new RDocumentInterface('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDocumentInterface");
          if (cl.isUndefined()) {
              qWarning() << "Class RDocumentInterface is undefined. Use RDocumentInterface_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDocumentInterface('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDocumentInterface(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDocumentInterface* RJSHelper_qcad::js2cpp_RDocumentInterface_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDocumentInterface: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDocumentInterface_Wrapper* wrapper = qobject_cast<RDocumentInterface_Wrapper*>(obj);
          //RDocumentInterface_Wrapper* wrapper = dynamic_cast<RDocumentInterface_Wrapper*>(obj);
          //RDocumentInterface_Wrapper* wrapper = (RDocumentInterface_Wrapper*)(obj);
          //RDocumentInterface_Wrapper* wrapper = getWrapper<RDocumentInterface_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDocumentInterface_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RDocumentInterface(wrapper);
          return RDocumentInterface_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDocumentInterface_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDocumentInterface: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDocumentInterface::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDocumentVariables(RJSApi& handler, RDocumentVariables* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDocumentVariables_Wrapper* ret = new RDocumentVariables_Wrapper(handler, v, false);

          // JS: new RDocumentVariables('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDocumentVariables");
          if (cl.isUndefined()) {
              qWarning() << "Class RDocumentVariables is undefined. Use RDocumentVariables_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDocumentVariables('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDocumentVariables(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDocumentVariables* RJSHelper_qcad::js2cpp_RDocumentVariables_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDocumentVariables: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDocumentVariables_Wrapper* wrapper = qobject_cast<RDocumentVariables_Wrapper*>(obj);
          //RDocumentVariables_Wrapper* wrapper = dynamic_cast<RDocumentVariables_Wrapper*>(obj);
          //RDocumentVariables_Wrapper* wrapper = (RDocumentVariables_Wrapper*)(obj);
          //RDocumentVariables_Wrapper* wrapper = getWrapper<RDocumentVariables_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDocumentVariables_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RDocumentVariables(wrapper);
          return RDocumentVariables_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDocumentVariables_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDocumentVariables: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDocumentVariables::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_REllipseEntity(RJSApi& handler, REllipseEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          REllipseEntity_Wrapper* ret = new REllipseEntity_Wrapper(handler, v, false);

          // JS: new REllipseEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("REllipseEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class REllipseEntity is undefined. Use REllipseEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new REllipseEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new REllipseEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      REllipseEntity* RJSHelper_qcad::js2cpp_REllipseEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_REllipseEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //REllipseEntity_Wrapper* wrapper = qobject_cast<REllipseEntity_Wrapper*>(obj);
          //REllipseEntity_Wrapper* wrapper = dynamic_cast<REllipseEntity_Wrapper*>(obj);
          //REllipseEntity_Wrapper* wrapper = (REllipseEntity_Wrapper*)(obj);
          //REllipseEntity_Wrapper* wrapper = getWrapper<REllipseEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_REllipseEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_REllipseEntity(wrapper);
          return REllipseEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_REllipseEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_REllipseEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_REllipseEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_REntity(RJSApi& handler, REntity* v) {

          
            // downcast to RArcEntity:
            {
                RArcEntity* o = dynamic_cast<RArcEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RArcEntity(handler, o);
                }
            }
          
            // downcast to RBlockReferenceEntity:
            {
                RBlockReferenceEntity* o = dynamic_cast<RBlockReferenceEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RBlockReferenceEntity(handler, o);
                }
            }
          
            // downcast to RCircleEntity:
            {
                RCircleEntity* o = dynamic_cast<RCircleEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RCircleEntity(handler, o);
                }
            }
          
            // downcast to RDimensionEntity:
            {
                RDimensionEntity* o = dynamic_cast<RDimensionEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimensionEntity(handler, o);
                }
            }
          
            // downcast to REllipseEntity:
            {
                REllipseEntity* o = dynamic_cast<REllipseEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_REllipseEntity(handler, o);
                }
            }
          
            // downcast to RFaceEntity:
            {
                RFaceEntity* o = dynamic_cast<RFaceEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RFaceEntity(handler, o);
                }
            }
          
            // downcast to RHatchEntity:
            {
                RHatchEntity* o = dynamic_cast<RHatchEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RHatchEntity(handler, o);
                }
            }
          
            // downcast to RImageEntity:
            {
                RImageEntity* o = dynamic_cast<RImageEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RImageEntity(handler, o);
                }
            }
          
            // downcast to RLeaderEntity:
            {
                RLeaderEntity* o = dynamic_cast<RLeaderEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RLeaderEntity(handler, o);
                }
            }
          
            // downcast to RLineEntity:
            {
                RLineEntity* o = dynamic_cast<RLineEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RLineEntity(handler, o);
                }
            }
          
            // downcast to RPointEntity:
            {
                RPointEntity* o = dynamic_cast<RPointEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RPointEntity(handler, o);
                }
            }
          
            // downcast to RPolylineEntity:
            {
                RPolylineEntity* o = dynamic_cast<RPolylineEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RPolylineEntity(handler, o);
                }
            }
          
            // downcast to RRayEntity:
            {
                RRayEntity* o = dynamic_cast<RRayEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RRayEntity(handler, o);
                }
            }
          
            // downcast to RSolidEntity:
            {
                RSolidEntity* o = dynamic_cast<RSolidEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSolidEntity(handler, o);
                }
            }
          
            // downcast to RSplineEntity:
            {
                RSplineEntity* o = dynamic_cast<RSplineEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSplineEntity(handler, o);
                }
            }
          
            // downcast to RTextBasedEntity:
            {
                RTextBasedEntity* o = dynamic_cast<RTextBasedEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RTextBasedEntity(handler, o);
                }
            }
          
            // downcast to RToleranceEntity:
            {
                RToleranceEntity* o = dynamic_cast<RToleranceEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RToleranceEntity(handler, o);
                }
            }
          
            // downcast to RTraceEntity:
            {
                RTraceEntity* o = dynamic_cast<RTraceEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RTraceEntity(handler, o);
                }
            }
          
            // downcast to RViewportEntity:
            {
                RViewportEntity* o = dynamic_cast<RViewportEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RViewportEntity(handler, o);
                }
            }
          
            // downcast to RXLineEntity:
            {
                RXLineEntity* o = dynamic_cast<RXLineEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RXLineEntity(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          REntity_Wrapper* ret = new REntity_Wrapper(handler, v, false);

          // JS: new REntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("REntity");
          if (cl.isUndefined()) {
              qWarning() << "Class REntity is undefined. Use REntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new REntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new REntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      REntity* RJSHelper_qcad::js2cpp_REntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_REntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //REntity_Wrapper* wrapper = qobject_cast<REntity_Wrapper*>(obj);
          //REntity_Wrapper* wrapper = dynamic_cast<REntity_Wrapper*>(obj);
          //REntity_Wrapper* wrapper = (REntity_Wrapper*)(obj);
          //REntity_Wrapper* wrapper = getWrapper<REntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_REntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_REntity(wrapper);
          return REntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_REntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_REntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_REntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_REntityData(RJSApi& handler, REntityData* v) {

          
            // downcast to RBlockReferenceData:
            {
                RBlockReferenceData* o = dynamic_cast<RBlockReferenceData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RBlockReferenceData(handler, o);
                }
            }
          
            // downcast to RDimensionData:
            {
                RDimensionData* o = dynamic_cast<RDimensionData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimensionData(handler, o);
                }
            }
          
            // downcast to RHatchData:
            {
                RHatchData* o = dynamic_cast<RHatchData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RHatchData(handler, o);
                }
            }
          
            // downcast to RImageData:
            {
                RImageData* o = dynamic_cast<RImageData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RImageData(handler, o);
                }
            }
          
            // downcast to RToleranceData:
            {
                RToleranceData* o = dynamic_cast<RToleranceData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RToleranceData(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          REntityData_Wrapper* ret = new REntityData_Wrapper(handler, v, false);

          // JS: new REntityData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("REntityData");
          if (cl.isUndefined()) {
              qWarning() << "Class REntityData is undefined. Use REntityData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new REntityData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new REntityData(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      REntityData* RJSHelper_qcad::js2cpp_REntityData_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_REntityData: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //REntityData_Wrapper* wrapper = qobject_cast<REntityData_Wrapper*>(obj);
          //REntityData_Wrapper* wrapper = dynamic_cast<REntityData_Wrapper*>(obj);
          //REntityData_Wrapper* wrapper = (REntityData_Wrapper*)(obj);
          //REntityData_Wrapper* wrapper = getWrapper<REntityData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_REntityData_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_REntityData(wrapper);
          return REntityData_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_REntityData_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_REntityData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_REntityData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_REntityExportListener(RJSApi& handler, REntityExportListener* v) {

          

          QJSEngine* engine = handler.getEngine();
          REntityExportListener_Wrapper* ret = new REntityExportListener_Wrapper(handler, v, false);

          // JS: new REntityExportListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("REntityExportListener");
          if (cl.isUndefined()) {
              qWarning() << "Class REntityExportListener is undefined. Use REntityExportListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new REntityExportListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new REntityExportListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      REntityExportListener* RJSHelper_qcad::js2cpp_REntityExportListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_REntityExportListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //REntityExportListener_Wrapper* wrapper = qobject_cast<REntityExportListener_Wrapper*>(obj);
          //REntityExportListener_Wrapper* wrapper = dynamic_cast<REntityExportListener_Wrapper*>(obj);
          //REntityExportListener_Wrapper* wrapper = (REntityExportListener_Wrapper*)(obj);
          //REntityExportListener_Wrapper* wrapper = getWrapper<REntityExportListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_REntityExportListener_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_REntityExportListener(wrapper);
          return REntityExportListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_REntityExportListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_REntityExportListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_REntityExportListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_REntityPickEvent(RJSApi& handler, REntityPickEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          REntityPickEvent_Wrapper* ret = new REntityPickEvent_Wrapper(handler, v, false);

          // JS: new REntityPickEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("REntityPickEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class REntityPickEvent is undefined. Use REntityPickEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new REntityPickEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new REntityPickEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      REntityPickEvent* RJSHelper_qcad::js2cpp_REntityPickEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_REntityPickEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //REntityPickEvent_Wrapper* wrapper = qobject_cast<REntityPickEvent_Wrapper*>(obj);
          //REntityPickEvent_Wrapper* wrapper = dynamic_cast<REntityPickEvent_Wrapper*>(obj);
          //REntityPickEvent_Wrapper* wrapper = (REntityPickEvent_Wrapper*)(obj);
          //REntityPickEvent_Wrapper* wrapper = getWrapper<REntityPickEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_REntityPickEvent_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_REntityPickEvent(wrapper);
          return REntityPickEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_REntityPickEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_REntityPickEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_REntityPickEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RExplodable(RJSApi& handler, RExplodable* v) {

          
            // downcast to RPolyline:
            {
                RPolyline* o = dynamic_cast<RPolyline*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RPolyline(handler, o);
                }
            }
          
            // downcast to RSpline:
            {
                RSpline* o = dynamic_cast<RSpline*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSpline(handler, o);
                }
            }
          
            // downcast to RTriangle:
            {
                RTriangle* o = dynamic_cast<RTriangle*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RTriangle(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RExplodable_Wrapper* ret = new RExplodable_Wrapper(handler, v, false);

          // JS: new RExplodable('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RExplodable");
          if (cl.isUndefined()) {
              qWarning() << "Class RExplodable is undefined. Use RExplodable_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RExplodable('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RExplodable(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RExplodable* RJSHelper_qcad::js2cpp_RExplodable_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RExplodable: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RExplodable_Wrapper* wrapper = qobject_cast<RExplodable_Wrapper*>(obj);
          //RExplodable_Wrapper* wrapper = dynamic_cast<RExplodable_Wrapper*>(obj);
          //RExplodable_Wrapper* wrapper = (RExplodable_Wrapper*)(obj);
          //RExplodable_Wrapper* wrapper = getWrapper<RExplodable_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RExplodable_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RExplodable(wrapper);
          return RExplodable_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RExplodable_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RExplodable: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RExplodable::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RExportListener(RJSApi& handler, RExportListener* v) {

          

          QJSEngine* engine = handler.getEngine();
          RExportListener_Wrapper* ret = new RExportListener_Wrapper(handler, v, false);

          // JS: new RExportListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RExportListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RExportListener is undefined. Use RExportListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RExportListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RExportListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RExportListener* RJSHelper_qcad::js2cpp_RExportListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RExportListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RExportListener_Wrapper* wrapper = qobject_cast<RExportListener_Wrapper*>(obj);
          //RExportListener_Wrapper* wrapper = dynamic_cast<RExportListener_Wrapper*>(obj);
          //RExportListener_Wrapper* wrapper = (RExportListener_Wrapper*)(obj);
          //RExportListener_Wrapper* wrapper = getWrapper<RExportListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RExportListener_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RExportListener(wrapper);
          return RExportListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RExportListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RExportListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RExportListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RExporter(RJSApi& handler, RExporter* v) {

          
            // downcast to RFileExporter:
            {
                RFileExporter* o = dynamic_cast<RFileExporter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RFileExporter(handler, o);
                }
            }
          
            // downcast to RGraphicsScene:
            {
                RGraphicsScene* o = dynamic_cast<RGraphicsScene*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RGraphicsScene(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RExporter_Wrapper* ret = new RExporter_Wrapper(handler, v, false);

          // JS: new RExporter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RExporter");
          if (cl.isUndefined()) {
              qWarning() << "Class RExporter is undefined. Use RExporter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RExporter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RExporter(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RExporter* RJSHelper_qcad::js2cpp_RExporter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RExporter: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RExporter_Wrapper* wrapper = qobject_cast<RExporter_Wrapper*>(obj);
          //RExporter_Wrapper* wrapper = dynamic_cast<RExporter_Wrapper*>(obj);
          //RExporter_Wrapper* wrapper = (RExporter_Wrapper*)(obj);
          //RExporter_Wrapper* wrapper = getWrapper<RExporter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RExporter_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RExporter(wrapper);
          return RExporter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RExporter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RExporter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RExporter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFaceEntity(RJSApi& handler, RFaceEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RFaceEntity_Wrapper* ret = new RFaceEntity_Wrapper(handler, v, false);

          // JS: new RFaceEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFaceEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RFaceEntity is undefined. Use RFaceEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFaceEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFaceEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RFaceEntity* RJSHelper_qcad::js2cpp_RFaceEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFaceEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RFaceEntity_Wrapper* wrapper = qobject_cast<RFaceEntity_Wrapper*>(obj);
          //RFaceEntity_Wrapper* wrapper = dynamic_cast<RFaceEntity_Wrapper*>(obj);
          //RFaceEntity_Wrapper* wrapper = (RFaceEntity_Wrapper*)(obj);
          //RFaceEntity_Wrapper* wrapper = getWrapper<RFaceEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFaceEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RFaceEntity(wrapper);
          return RFaceEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RFaceEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFaceEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RFaceEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFileExporter(RJSApi& handler, RFileExporter* v) {

          
            // downcast to RFileExporterAdapter:
            {
                RFileExporterAdapter* o = dynamic_cast<RFileExporterAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RFileExporterAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RFileExporter_Wrapper* ret = new RFileExporter_Wrapper(handler, v, false);

          // JS: new RFileExporter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileExporter");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileExporter is undefined. Use RFileExporter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileExporter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileExporter(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RFileExporter* RJSHelper_qcad::js2cpp_RFileExporter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFileExporter: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RFileExporter_Wrapper* wrapper = qobject_cast<RFileExporter_Wrapper*>(obj);
          //RFileExporter_Wrapper* wrapper = dynamic_cast<RFileExporter_Wrapper*>(obj);
          //RFileExporter_Wrapper* wrapper = (RFileExporter_Wrapper*)(obj);
          //RFileExporter_Wrapper* wrapper = getWrapper<RFileExporter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileExporter_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RFileExporter(wrapper);
          return RFileExporter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RFileExporter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFileExporter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RFileExporter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFileExporterFactory(RJSApi& handler, RFileExporterFactory* v) {

          
            // downcast to RFileExporterFactoryAdapter:
            {
                RFileExporterFactoryAdapter* o = dynamic_cast<RFileExporterFactoryAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RFileExporterFactoryAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RFileExporterFactory_Wrapper* ret = new RFileExporterFactory_Wrapper(handler, v, false);

          // JS: new RFileExporterFactory('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileExporterFactory");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileExporterFactory is undefined. Use RFileExporterFactory_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileExporterFactory('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileExporterFactory(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RFileExporterFactory* RJSHelper_qcad::js2cpp_RFileExporterFactory_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFileExporterFactory: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RFileExporterFactory_Wrapper* wrapper = qobject_cast<RFileExporterFactory_Wrapper*>(obj);
          //RFileExporterFactory_Wrapper* wrapper = dynamic_cast<RFileExporterFactory_Wrapper*>(obj);
          //RFileExporterFactory_Wrapper* wrapper = (RFileExporterFactory_Wrapper*)(obj);
          //RFileExporterFactory_Wrapper* wrapper = getWrapper<RFileExporterFactory_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileExporterFactory_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RFileExporterFactory(wrapper);
          return RFileExporterFactory_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RFileExporterFactory_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFileExporterFactory: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RFileExporterFactory::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFileImporter(RJSApi& handler, RFileImporter* v) {

          
            // downcast to RFileImporterAdapter:
            {
                RFileImporterAdapter* o = dynamic_cast<RFileImporterAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RFileImporterAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RFileImporter_Wrapper* ret = new RFileImporter_Wrapper(handler, v, false);

          // JS: new RFileImporter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileImporter");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileImporter is undefined. Use RFileImporter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileImporter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileImporter(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RFileImporter* RJSHelper_qcad::js2cpp_RFileImporter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFileImporter: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RFileImporter_Wrapper* wrapper = qobject_cast<RFileImporter_Wrapper*>(obj);
          //RFileImporter_Wrapper* wrapper = dynamic_cast<RFileImporter_Wrapper*>(obj);
          //RFileImporter_Wrapper* wrapper = (RFileImporter_Wrapper*)(obj);
          //RFileImporter_Wrapper* wrapper = getWrapper<RFileImporter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileImporter_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RFileImporter(wrapper);
          return RFileImporter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RFileImporter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFileImporter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RFileImporter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFileImporterFactory(RJSApi& handler, RFileImporterFactory* v) {

          
            // downcast to RFileImporterFactoryAdapter:
            {
                RFileImporterFactoryAdapter* o = dynamic_cast<RFileImporterFactoryAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RFileImporterFactoryAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RFileImporterFactory_Wrapper* ret = new RFileImporterFactory_Wrapper(handler, v, false);

          // JS: new RFileImporterFactory('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileImporterFactory");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileImporterFactory is undefined. Use RFileImporterFactory_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileImporterFactory('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileImporterFactory(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RFileImporterFactory* RJSHelper_qcad::js2cpp_RFileImporterFactory_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFileImporterFactory: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RFileImporterFactory_Wrapper* wrapper = qobject_cast<RFileImporterFactory_Wrapper*>(obj);
          //RFileImporterFactory_Wrapper* wrapper = dynamic_cast<RFileImporterFactory_Wrapper*>(obj);
          //RFileImporterFactory_Wrapper* wrapper = (RFileImporterFactory_Wrapper*)(obj);
          //RFileImporterFactory_Wrapper* wrapper = getWrapper<RFileImporterFactory_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileImporterFactory_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RFileImporterFactory(wrapper);
          return RFileImporterFactory_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RFileImporterFactory_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFileImporterFactory: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RFileImporterFactory::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFocusListener(RJSApi& handler, RFocusListener* v) {

          
            // downcast to RFocusListenerAdapter:
            {
                RFocusListenerAdapter* o = dynamic_cast<RFocusListenerAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RFocusListenerAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RFocusListener_Wrapper* ret = new RFocusListener_Wrapper(handler, v, false);

          // JS: new RFocusListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFocusListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RFocusListener is undefined. Use RFocusListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFocusListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFocusListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RFocusListener* RJSHelper_qcad::js2cpp_RFocusListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFocusListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RFocusListener_Wrapper* wrapper = qobject_cast<RFocusListener_Wrapper*>(obj);
          //RFocusListener_Wrapper* wrapper = dynamic_cast<RFocusListener_Wrapper*>(obj);
          //RFocusListener_Wrapper* wrapper = (RFocusListener_Wrapper*)(obj);
          //RFocusListener_Wrapper* wrapper = getWrapper<RFocusListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFocusListener_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RFocusListener(wrapper);
          return RFocusListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RFocusListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFocusListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RFocusListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RGraphicsScene(RJSApi& handler, RGraphicsScene* v) {

          
            // downcast to RGraphicsSceneQt:
            {
                RGraphicsSceneQt* o = dynamic_cast<RGraphicsSceneQt*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RGraphicsSceneQt(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RGraphicsScene_Wrapper* ret = new RGraphicsScene_Wrapper(handler, v, false);

          // JS: new RGraphicsScene('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RGraphicsScene");
          if (cl.isUndefined()) {
              qWarning() << "Class RGraphicsScene is undefined. Use RGraphicsScene_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RGraphicsScene('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RGraphicsScene(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RGraphicsScene* RJSHelper_qcad::js2cpp_RGraphicsScene_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RGraphicsScene: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RGraphicsScene_Wrapper* wrapper = qobject_cast<RGraphicsScene_Wrapper*>(obj);
          //RGraphicsScene_Wrapper* wrapper = dynamic_cast<RGraphicsScene_Wrapper*>(obj);
          //RGraphicsScene_Wrapper* wrapper = (RGraphicsScene_Wrapper*)(obj);
          //RGraphicsScene_Wrapper* wrapper = getWrapper<RGraphicsScene_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RGraphicsScene_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RGraphicsScene(wrapper);
          return RGraphicsScene_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RGraphicsScene_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RGraphicsScene: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RGraphicsScene::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RGraphicsSceneQt(RJSApi& handler, RGraphicsSceneQt* v) {

          

          QJSEngine* engine = handler.getEngine();
          RGraphicsSceneQt_Wrapper* ret = new RGraphicsSceneQt_Wrapper(handler, v, false);

          // JS: new RGraphicsSceneQt('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RGraphicsSceneQt");
          if (cl.isUndefined()) {
              qWarning() << "Class RGraphicsSceneQt is undefined. Use RGraphicsSceneQt_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RGraphicsSceneQt('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RGraphicsSceneQt(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RGraphicsSceneQt* RJSHelper_qcad::js2cpp_RGraphicsSceneQt_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RGraphicsSceneQt: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RGraphicsSceneQt_Wrapper* wrapper = qobject_cast<RGraphicsSceneQt_Wrapper*>(obj);
          //RGraphicsSceneQt_Wrapper* wrapper = dynamic_cast<RGraphicsSceneQt_Wrapper*>(obj);
          //RGraphicsSceneQt_Wrapper* wrapper = (RGraphicsSceneQt_Wrapper*)(obj);
          //RGraphicsSceneQt_Wrapper* wrapper = getWrapper<RGraphicsSceneQt_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RGraphicsSceneQt_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RGraphicsSceneQt(wrapper);
          return RGraphicsSceneQt_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RGraphicsSceneQt_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RGraphicsSceneQt: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RGraphicsSceneQt::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RGraphicsView(RJSApi& handler, RGraphicsView* v) {

          
            // downcast to RGraphicsViewImage:
            {
                RGraphicsViewImage* o = dynamic_cast<RGraphicsViewImage*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RGraphicsViewImage(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RGraphicsView_Wrapper* ret = new RGraphicsView_Wrapper(handler, v, false);

          // JS: new RGraphicsView('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RGraphicsView");
          if (cl.isUndefined()) {
              qWarning() << "Class RGraphicsView is undefined. Use RGraphicsView_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RGraphicsView('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RGraphicsView(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RGraphicsView* RJSHelper_qcad::js2cpp_RGraphicsView_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RGraphicsView: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RGraphicsView_Wrapper* wrapper = qobject_cast<RGraphicsView_Wrapper*>(obj);
          //RGraphicsView_Wrapper* wrapper = dynamic_cast<RGraphicsView_Wrapper*>(obj);
          //RGraphicsView_Wrapper* wrapper = (RGraphicsView_Wrapper*)(obj);
          //RGraphicsView_Wrapper* wrapper = getWrapper<RGraphicsView_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RGraphicsView_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RGraphicsView(wrapper);
          return RGraphicsView_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RGraphicsView_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RGraphicsView: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RGraphicsView::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RGrid(RJSApi& handler, RGrid* v) {

          
            // downcast to ROrthoGrid:
            {
                ROrthoGrid* o = dynamic_cast<ROrthoGrid*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_ROrthoGrid(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RGrid_Wrapper* ret = new RGrid_Wrapper(handler, v, false);

          // JS: new RGrid('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RGrid");
          if (cl.isUndefined()) {
              qWarning() << "Class RGrid is undefined. Use RGrid_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RGrid('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RGrid(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RGrid* RJSHelper_qcad::js2cpp_RGrid_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RGrid: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RGrid_Wrapper* wrapper = qobject_cast<RGrid_Wrapper*>(obj);
          //RGrid_Wrapper* wrapper = dynamic_cast<RGrid_Wrapper*>(obj);
          //RGrid_Wrapper* wrapper = (RGrid_Wrapper*)(obj);
          //RGrid_Wrapper* wrapper = getWrapper<RGrid_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RGrid_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RGrid(wrapper);
          return RGrid_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RGrid_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RGrid: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RGrid::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RHatchEntity(RJSApi& handler, RHatchEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RHatchEntity_Wrapper* ret = new RHatchEntity_Wrapper(handler, v, false);

          // JS: new RHatchEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RHatchEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RHatchEntity is undefined. Use RHatchEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RHatchEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RHatchEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RHatchEntity* RJSHelper_qcad::js2cpp_RHatchEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RHatchEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RHatchEntity_Wrapper* wrapper = qobject_cast<RHatchEntity_Wrapper*>(obj);
          //RHatchEntity_Wrapper* wrapper = dynamic_cast<RHatchEntity_Wrapper*>(obj);
          //RHatchEntity_Wrapper* wrapper = (RHatchEntity_Wrapper*)(obj);
          //RHatchEntity_Wrapper* wrapper = getWrapper<RHatchEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RHatchEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RHatchEntity(wrapper);
          return RHatchEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RHatchEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RHatchEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RHatchEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RImageEntity(RJSApi& handler, RImageEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RImageEntity_Wrapper* ret = new RImageEntity_Wrapper(handler, v, false);

          // JS: new RImageEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RImageEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RImageEntity is undefined. Use RImageEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RImageEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RImageEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RImageEntity* RJSHelper_qcad::js2cpp_RImageEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RImageEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RImageEntity_Wrapper* wrapper = qobject_cast<RImageEntity_Wrapper*>(obj);
          //RImageEntity_Wrapper* wrapper = dynamic_cast<RImageEntity_Wrapper*>(obj);
          //RImageEntity_Wrapper* wrapper = (RImageEntity_Wrapper*)(obj);
          //RImageEntity_Wrapper* wrapper = getWrapper<RImageEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RImageEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RImageEntity(wrapper);
          return RImageEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RImageEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RImageEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RImageEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RImportListener(RJSApi& handler, RImportListener* v) {

          

          QJSEngine* engine = handler.getEngine();
          RImportListener_Wrapper* ret = new RImportListener_Wrapper(handler, v, false);

          // JS: new RImportListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RImportListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RImportListener is undefined. Use RImportListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RImportListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RImportListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RImportListener* RJSHelper_qcad::js2cpp_RImportListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RImportListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RImportListener_Wrapper* wrapper = qobject_cast<RImportListener_Wrapper*>(obj);
          //RImportListener_Wrapper* wrapper = dynamic_cast<RImportListener_Wrapper*>(obj);
          //RImportListener_Wrapper* wrapper = (RImportListener_Wrapper*)(obj);
          //RImportListener_Wrapper* wrapper = getWrapper<RImportListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RImportListener_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RImportListener(wrapper);
          return RImportListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RImportListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RImportListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RImportListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RImporter(RJSApi& handler, RImporter* v) {

          
            // downcast to RFileImporter:
            {
                RFileImporter* o = dynamic_cast<RFileImporter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RFileImporter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RImporter_Wrapper* ret = new RImporter_Wrapper(handler, v, false);

          // JS: new RImporter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RImporter");
          if (cl.isUndefined()) {
              qWarning() << "Class RImporter is undefined. Use RImporter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RImporter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RImporter(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RImporter* RJSHelper_qcad::js2cpp_RImporter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RImporter: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RImporter_Wrapper* wrapper = qobject_cast<RImporter_Wrapper*>(obj);
          //RImporter_Wrapper* wrapper = dynamic_cast<RImporter_Wrapper*>(obj);
          //RImporter_Wrapper* wrapper = (RImporter_Wrapper*)(obj);
          //RImporter_Wrapper* wrapper = getWrapper<RImporter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RImporter_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RImporter(wrapper);
          return RImporter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RImporter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RImporter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RImporter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RInputEvent(RJSApi& handler, RInputEvent* v) {

          
            // downcast to RCoordinateEvent:
            {
                RCoordinateEvent* o = dynamic_cast<RCoordinateEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RCoordinateEvent(handler, o);
                }
            }
          
            // downcast to REntityPickEvent:
            {
                REntityPickEvent* o = dynamic_cast<REntityPickEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_REntityPickEvent(handler, o);
                }
            }
          
            // downcast to RMouseEvent:
            {
                RMouseEvent* o = dynamic_cast<RMouseEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RMouseEvent(handler, o);
                }
            }
          
            // downcast to RWheelEvent:
            {
                RWheelEvent* o = dynamic_cast<RWheelEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RWheelEvent(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RInputEvent_Wrapper* ret = new RInputEvent_Wrapper(handler, v, false);

          // JS: new RInputEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RInputEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class RInputEvent is undefined. Use RInputEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RInputEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RInputEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RInputEvent* RJSHelper_qcad::js2cpp_RInputEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RInputEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RInputEvent_Wrapper* wrapper = qobject_cast<RInputEvent_Wrapper*>(obj);
          //RInputEvent_Wrapper* wrapper = dynamic_cast<RInputEvent_Wrapper*>(obj);
          //RInputEvent_Wrapper* wrapper = (RInputEvent_Wrapper*)(obj);
          //RInputEvent_Wrapper* wrapper = getWrapper<RInputEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RInputEvent_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RInputEvent(wrapper);
          return RInputEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RInputEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RInputEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RInputEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RInterTransactionListener(RJSApi& handler, RInterTransactionListener* v) {

          
            // downcast to RInterTransactionListenerAdapter:
            {
                RInterTransactionListenerAdapter* o = dynamic_cast<RInterTransactionListenerAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RInterTransactionListenerAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RInterTransactionListener_Wrapper* ret = new RInterTransactionListener_Wrapper(handler, v, false);

          // JS: new RInterTransactionListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RInterTransactionListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RInterTransactionListener is undefined. Use RInterTransactionListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RInterTransactionListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RInterTransactionListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RInterTransactionListener* RJSHelper_qcad::js2cpp_RInterTransactionListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RInterTransactionListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RInterTransactionListener_Wrapper* wrapper = qobject_cast<RInterTransactionListener_Wrapper*>(obj);
          //RInterTransactionListener_Wrapper* wrapper = dynamic_cast<RInterTransactionListener_Wrapper*>(obj);
          //RInterTransactionListener_Wrapper* wrapper = (RInterTransactionListener_Wrapper*)(obj);
          //RInterTransactionListener_Wrapper* wrapper = getWrapper<RInterTransactionListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RInterTransactionListener_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RInterTransactionListener(wrapper);
          return RInterTransactionListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RInterTransactionListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RInterTransactionListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RInterTransactionListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RKeyListener(RJSApi& handler, RKeyListener* v) {

          
            // downcast to RKeyListenerAdapter:
            {
                RKeyListenerAdapter* o = dynamic_cast<RKeyListenerAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RKeyListenerAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RKeyListener_Wrapper* ret = new RKeyListener_Wrapper(handler, v, false);

          // JS: new RKeyListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RKeyListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RKeyListener is undefined. Use RKeyListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RKeyListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RKeyListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RKeyListener* RJSHelper_qcad::js2cpp_RKeyListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RKeyListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RKeyListener_Wrapper* wrapper = qobject_cast<RKeyListener_Wrapper*>(obj);
          //RKeyListener_Wrapper* wrapper = dynamic_cast<RKeyListener_Wrapper*>(obj);
          //RKeyListener_Wrapper* wrapper = (RKeyListener_Wrapper*)(obj);
          //RKeyListener_Wrapper* wrapper = getWrapper<RKeyListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RKeyListener_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RKeyListener(wrapper);
          return RKeyListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RKeyListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RKeyListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RKeyListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLayer(RJSApi& handler, RLayer* v) {

          

          QJSEngine* engine = handler.getEngine();
          RLayer_Wrapper* ret = new RLayer_Wrapper(handler, v, false);

          // JS: new RLayer('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLayer");
          if (cl.isUndefined()) {
              qWarning() << "Class RLayer is undefined. Use RLayer_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLayer('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLayer(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RLayer* RJSHelper_qcad::js2cpp_RLayer_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLayer: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RLayer_Wrapper* wrapper = qobject_cast<RLayer_Wrapper*>(obj);
          //RLayer_Wrapper* wrapper = dynamic_cast<RLayer_Wrapper*>(obj);
          //RLayer_Wrapper* wrapper = (RLayer_Wrapper*)(obj);
          //RLayer_Wrapper* wrapper = getWrapper<RLayer_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLayer_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RLayer(wrapper);
          return RLayer_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RLayer_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLayer: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RLayer::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLayerListener(RJSApi& handler, RLayerListener* v) {

          
            // downcast to RLayerListenerAdapter:
            {
                RLayerListenerAdapter* o = dynamic_cast<RLayerListenerAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RLayerListenerAdapter(handler, o);
                }
            }
          
            // downcast to RPropertyEditor:
            {
                RPropertyEditor* o = dynamic_cast<RPropertyEditor*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RPropertyEditor(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RLayerListener_Wrapper* ret = new RLayerListener_Wrapper(handler, v, false);

          // JS: new RLayerListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLayerListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RLayerListener is undefined. Use RLayerListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLayerListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLayerListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RLayerListener* RJSHelper_qcad::js2cpp_RLayerListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLayerListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RLayerListener_Wrapper* wrapper = qobject_cast<RLayerListener_Wrapper*>(obj);
          //RLayerListener_Wrapper* wrapper = dynamic_cast<RLayerListener_Wrapper*>(obj);
          //RLayerListener_Wrapper* wrapper = (RLayerListener_Wrapper*)(obj);
          //RLayerListener_Wrapper* wrapper = getWrapper<RLayerListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLayerListener_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RLayerListener(wrapper);
          return RLayerListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RLayerListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLayerListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RLayerListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLayerState(RJSApi& handler, RLayerState* v) {

          

          QJSEngine* engine = handler.getEngine();
          RLayerState_Wrapper* ret = new RLayerState_Wrapper(handler, v, false);

          // JS: new RLayerState('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLayerState");
          if (cl.isUndefined()) {
              qWarning() << "Class RLayerState is undefined. Use RLayerState_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLayerState('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLayerState(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RLayerState* RJSHelper_qcad::js2cpp_RLayerState_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLayerState: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RLayerState_Wrapper* wrapper = qobject_cast<RLayerState_Wrapper*>(obj);
          //RLayerState_Wrapper* wrapper = dynamic_cast<RLayerState_Wrapper*>(obj);
          //RLayerState_Wrapper* wrapper = (RLayerState_Wrapper*)(obj);
          //RLayerState_Wrapper* wrapper = getWrapper<RLayerState_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLayerState_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RLayerState(wrapper);
          return RLayerState_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RLayerState_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLayerState: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RLayerState::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLayout(RJSApi& handler, RLayout* v) {

          

          QJSEngine* engine = handler.getEngine();
          RLayout_Wrapper* ret = new RLayout_Wrapper(handler, v, false);

          // JS: new RLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class RLayout is undefined. Use RLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLayout('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLayout(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RLayout* RJSHelper_qcad::js2cpp_RLayout_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLayout: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RLayout_Wrapper* wrapper = qobject_cast<RLayout_Wrapper*>(obj);
          //RLayout_Wrapper* wrapper = dynamic_cast<RLayout_Wrapper*>(obj);
          //RLayout_Wrapper* wrapper = (RLayout_Wrapper*)(obj);
          //RLayout_Wrapper* wrapper = getWrapper<RLayout_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLayout_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RLayout(wrapper);
          return RLayout_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RLayout_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLayout: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RLayout::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLeaderEntity(RJSApi& handler, RLeaderEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RLeaderEntity_Wrapper* ret = new RLeaderEntity_Wrapper(handler, v, false);

          // JS: new RLeaderEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLeaderEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RLeaderEntity is undefined. Use RLeaderEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLeaderEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLeaderEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RLeaderEntity* RJSHelper_qcad::js2cpp_RLeaderEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLeaderEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RLeaderEntity_Wrapper* wrapper = qobject_cast<RLeaderEntity_Wrapper*>(obj);
          //RLeaderEntity_Wrapper* wrapper = dynamic_cast<RLeaderEntity_Wrapper*>(obj);
          //RLeaderEntity_Wrapper* wrapper = (RLeaderEntity_Wrapper*)(obj);
          //RLeaderEntity_Wrapper* wrapper = getWrapper<RLeaderEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLeaderEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RLeaderEntity(wrapper);
          return RLeaderEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RLeaderEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLeaderEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RLeaderEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLineEntity(RJSApi& handler, RLineEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RLineEntity_Wrapper* ret = new RLineEntity_Wrapper(handler, v, false);

          // JS: new RLineEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLineEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RLineEntity is undefined. Use RLineEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLineEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLineEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RLineEntity* RJSHelper_qcad::js2cpp_RLineEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLineEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RLineEntity_Wrapper* wrapper = qobject_cast<RLineEntity_Wrapper*>(obj);
          //RLineEntity_Wrapper* wrapper = dynamic_cast<RLineEntity_Wrapper*>(obj);
          //RLineEntity_Wrapper* wrapper = (RLineEntity_Wrapper*)(obj);
          //RLineEntity_Wrapper* wrapper = getWrapper<RLineEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLineEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RLineEntity(wrapper);
          return RLineEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RLineEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLineEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RLineEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLinetype(RJSApi& handler, RLinetype* v) {

          

          QJSEngine* engine = handler.getEngine();
          RLinetype_Wrapper* ret = new RLinetype_Wrapper(handler, v, false);

          // JS: new RLinetype('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLinetype");
          if (cl.isUndefined()) {
              qWarning() << "Class RLinetype is undefined. Use RLinetype_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLinetype('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLinetype(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RLinetype* RJSHelper_qcad::js2cpp_RLinetype_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLinetype: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RLinetype_Wrapper* wrapper = qobject_cast<RLinetype_Wrapper*>(obj);
          //RLinetype_Wrapper* wrapper = dynamic_cast<RLinetype_Wrapper*>(obj);
          //RLinetype_Wrapper* wrapper = (RLinetype_Wrapper*)(obj);
          //RLinetype_Wrapper* wrapper = getWrapper<RLinetype_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLinetype_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RLinetype(wrapper);
          return RLinetype_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RLinetype_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLinetype: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RLinetype::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RMainWindow(RJSApi& handler, RMainWindow* v) {

          
            // downcast to RMainWindowQt:
            {
                RMainWindowQt* o = dynamic_cast<RMainWindowQt*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RMainWindowQt(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RMainWindow_Wrapper* ret = new RMainWindow_Wrapper(handler, v, false);

          // JS: new RMainWindow('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMainWindow");
          if (cl.isUndefined()) {
              qWarning() << "Class RMainWindow is undefined. Use RMainWindow_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMainWindow('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMainWindow(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RMainWindow* RJSHelper_qcad::js2cpp_RMainWindow_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RMainWindow: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RMainWindow_Wrapper* wrapper = qobject_cast<RMainWindow_Wrapper*>(obj);
          //RMainWindow_Wrapper* wrapper = dynamic_cast<RMainWindow_Wrapper*>(obj);
          //RMainWindow_Wrapper* wrapper = (RMainWindow_Wrapper*)(obj);
          //RMainWindow_Wrapper* wrapper = getWrapper<RMainWindow_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMainWindow_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RMainWindow(wrapper);
          return RMainWindow_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RMainWindow_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RMainWindow: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RMainWindow::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RMemoryStorage(RJSApi& handler, RMemoryStorage* v) {

          

          QJSEngine* engine = handler.getEngine();
          RMemoryStorage_Wrapper* ret = new RMemoryStorage_Wrapper(handler, v, false);

          // JS: new RMemoryStorage('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMemoryStorage");
          if (cl.isUndefined()) {
              qWarning() << "Class RMemoryStorage is undefined. Use RMemoryStorage_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMemoryStorage('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMemoryStorage(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RMemoryStorage* RJSHelper_qcad::js2cpp_RMemoryStorage_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RMemoryStorage: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RMemoryStorage_Wrapper* wrapper = qobject_cast<RMemoryStorage_Wrapper*>(obj);
          //RMemoryStorage_Wrapper* wrapper = dynamic_cast<RMemoryStorage_Wrapper*>(obj);
          //RMemoryStorage_Wrapper* wrapper = (RMemoryStorage_Wrapper*)(obj);
          //RMemoryStorage_Wrapper* wrapper = getWrapper<RMemoryStorage_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMemoryStorage_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RMemoryStorage(wrapper);
          return RMemoryStorage_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RMemoryStorage_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RMemoryStorage: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RMemoryStorage::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RMessageHandler(RJSApi& handler, RMessageHandler* v) {

          

          QJSEngine* engine = handler.getEngine();
          RMessageHandler_Wrapper* ret = new RMessageHandler_Wrapper(handler, v, false);

          // JS: new RMessageHandler('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMessageHandler");
          if (cl.isUndefined()) {
              qWarning() << "Class RMessageHandler is undefined. Use RMessageHandler_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMessageHandler('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMessageHandler(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RMessageHandler* RJSHelper_qcad::js2cpp_RMessageHandler_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RMessageHandler: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RMessageHandler_Wrapper* wrapper = qobject_cast<RMessageHandler_Wrapper*>(obj);
          //RMessageHandler_Wrapper* wrapper = dynamic_cast<RMessageHandler_Wrapper*>(obj);
          //RMessageHandler_Wrapper* wrapper = (RMessageHandler_Wrapper*)(obj);
          //RMessageHandler_Wrapper* wrapper = getWrapper<RMessageHandler_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMessageHandler_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RMessageHandler(wrapper);
          return RMessageHandler_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RMessageHandler_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RMessageHandler: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RMessageHandler::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RMixedOperation(RJSApi& handler, RMixedOperation* v) {

          

          QJSEngine* engine = handler.getEngine();
          RMixedOperation_Wrapper* ret = new RMixedOperation_Wrapper(handler, v, false);

          // JS: new RMixedOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMixedOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RMixedOperation is undefined. Use RMixedOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMixedOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMixedOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RMixedOperation* RJSHelper_qcad::js2cpp_RMixedOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RMixedOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RMixedOperation_Wrapper* wrapper = qobject_cast<RMixedOperation_Wrapper*>(obj);
          //RMixedOperation_Wrapper* wrapper = dynamic_cast<RMixedOperation_Wrapper*>(obj);
          //RMixedOperation_Wrapper* wrapper = (RMixedOperation_Wrapper*)(obj);
          //RMixedOperation_Wrapper* wrapper = getWrapper<RMixedOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMixedOperation_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RMixedOperation(wrapper);
          return RMixedOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RMixedOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RMixedOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RMixedOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RModifiedListener(RJSApi& handler, RModifiedListener* v) {

          

          QJSEngine* engine = handler.getEngine();
          RModifiedListener_Wrapper* ret = new RModifiedListener_Wrapper(handler, v, false);

          // JS: new RModifiedListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RModifiedListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RModifiedListener is undefined. Use RModifiedListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RModifiedListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RModifiedListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RModifiedListener* RJSHelper_qcad::js2cpp_RModifiedListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RModifiedListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RModifiedListener_Wrapper* wrapper = qobject_cast<RModifiedListener_Wrapper*>(obj);
          //RModifiedListener_Wrapper* wrapper = dynamic_cast<RModifiedListener_Wrapper*>(obj);
          //RModifiedListener_Wrapper* wrapper = (RModifiedListener_Wrapper*)(obj);
          //RModifiedListener_Wrapper* wrapper = getWrapper<RModifiedListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RModifiedListener_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RModifiedListener(wrapper);
          return RModifiedListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RModifiedListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RModifiedListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RModifiedListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RModifyObjectOperation(RJSApi& handler, RModifyObjectOperation* v) {

          

          QJSEngine* engine = handler.getEngine();
          RModifyObjectOperation_Wrapper* ret = new RModifyObjectOperation_Wrapper(handler, v, false);

          // JS: new RModifyObjectOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RModifyObjectOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RModifyObjectOperation is undefined. Use RModifyObjectOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RModifyObjectOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RModifyObjectOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RModifyObjectOperation* RJSHelper_qcad::js2cpp_RModifyObjectOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RModifyObjectOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RModifyObjectOperation_Wrapper* wrapper = qobject_cast<RModifyObjectOperation_Wrapper*>(obj);
          //RModifyObjectOperation_Wrapper* wrapper = dynamic_cast<RModifyObjectOperation_Wrapper*>(obj);
          //RModifyObjectOperation_Wrapper* wrapper = (RModifyObjectOperation_Wrapper*)(obj);
          //RModifyObjectOperation_Wrapper* wrapper = getWrapper<RModifyObjectOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RModifyObjectOperation_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RModifyObjectOperation(wrapper);
          return RModifyObjectOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RModifyObjectOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RModifyObjectOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RModifyObjectOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RModifyObjectsOperation(RJSApi& handler, RModifyObjectsOperation* v) {

          

          QJSEngine* engine = handler.getEngine();
          RModifyObjectsOperation_Wrapper* ret = new RModifyObjectsOperation_Wrapper(handler, v, false);

          // JS: new RModifyObjectsOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RModifyObjectsOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RModifyObjectsOperation is undefined. Use RModifyObjectsOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RModifyObjectsOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RModifyObjectsOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RModifyObjectsOperation* RJSHelper_qcad::js2cpp_RModifyObjectsOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RModifyObjectsOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RModifyObjectsOperation_Wrapper* wrapper = qobject_cast<RModifyObjectsOperation_Wrapper*>(obj);
          //RModifyObjectsOperation_Wrapper* wrapper = dynamic_cast<RModifyObjectsOperation_Wrapper*>(obj);
          //RModifyObjectsOperation_Wrapper* wrapper = (RModifyObjectsOperation_Wrapper*)(obj);
          //RModifyObjectsOperation_Wrapper* wrapper = getWrapper<RModifyObjectsOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RModifyObjectsOperation_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RModifyObjectsOperation(wrapper);
          return RModifyObjectsOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RModifyObjectsOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RModifyObjectsOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RModifyObjectsOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RMouseEvent(RJSApi& handler, RMouseEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          RMouseEvent_Wrapper* ret = new RMouseEvent_Wrapper(handler, v, false);

          // JS: new RMouseEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMouseEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class RMouseEvent is undefined. Use RMouseEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMouseEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMouseEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RMouseEvent* RJSHelper_qcad::js2cpp_RMouseEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RMouseEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RMouseEvent_Wrapper* wrapper = qobject_cast<RMouseEvent_Wrapper*>(obj);
          //RMouseEvent_Wrapper* wrapper = dynamic_cast<RMouseEvent_Wrapper*>(obj);
          //RMouseEvent_Wrapper* wrapper = (RMouseEvent_Wrapper*)(obj);
          //RMouseEvent_Wrapper* wrapper = getWrapper<RMouseEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMouseEvent_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RMouseEvent(wrapper);
          return RMouseEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RMouseEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RMouseEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RMouseEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RMoveReferencePointOperation(RJSApi& handler, RMoveReferencePointOperation* v) {

          

          QJSEngine* engine = handler.getEngine();
          RMoveReferencePointOperation_Wrapper* ret = new RMoveReferencePointOperation_Wrapper(handler, v, false);

          // JS: new RMoveReferencePointOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMoveReferencePointOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RMoveReferencePointOperation is undefined. Use RMoveReferencePointOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMoveReferencePointOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMoveReferencePointOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RMoveReferencePointOperation* RJSHelper_qcad::js2cpp_RMoveReferencePointOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RMoveReferencePointOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RMoveReferencePointOperation_Wrapper* wrapper = qobject_cast<RMoveReferencePointOperation_Wrapper*>(obj);
          //RMoveReferencePointOperation_Wrapper* wrapper = dynamic_cast<RMoveReferencePointOperation_Wrapper*>(obj);
          //RMoveReferencePointOperation_Wrapper* wrapper = (RMoveReferencePointOperation_Wrapper*)(obj);
          //RMoveReferencePointOperation_Wrapper* wrapper = getWrapper<RMoveReferencePointOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMoveReferencePointOperation_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RMoveReferencePointOperation(wrapper);
          return RMoveReferencePointOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RMoveReferencePointOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RMoveReferencePointOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RMoveReferencePointOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RMoveSelectionOperation(RJSApi& handler, RMoveSelectionOperation* v) {

          

          QJSEngine* engine = handler.getEngine();
          RMoveSelectionOperation_Wrapper* ret = new RMoveSelectionOperation_Wrapper(handler, v, false);

          // JS: new RMoveSelectionOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMoveSelectionOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RMoveSelectionOperation is undefined. Use RMoveSelectionOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMoveSelectionOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMoveSelectionOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RMoveSelectionOperation* RJSHelper_qcad::js2cpp_RMoveSelectionOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RMoveSelectionOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RMoveSelectionOperation_Wrapper* wrapper = qobject_cast<RMoveSelectionOperation_Wrapper*>(obj);
          //RMoveSelectionOperation_Wrapper* wrapper = dynamic_cast<RMoveSelectionOperation_Wrapper*>(obj);
          //RMoveSelectionOperation_Wrapper* wrapper = (RMoveSelectionOperation_Wrapper*)(obj);
          //RMoveSelectionOperation_Wrapper* wrapper = getWrapper<RMoveSelectionOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMoveSelectionOperation_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RMoveSelectionOperation(wrapper);
          return RMoveSelectionOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RMoveSelectionOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RMoveSelectionOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RMoveSelectionOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RNewDocumentListener(RJSApi& handler, RNewDocumentListener* v) {

          

          QJSEngine* engine = handler.getEngine();
          RNewDocumentListener_Wrapper* ret = new RNewDocumentListener_Wrapper(handler, v, false);

          // JS: new RNewDocumentListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RNewDocumentListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RNewDocumentListener is undefined. Use RNewDocumentListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RNewDocumentListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RNewDocumentListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RNewDocumentListener* RJSHelper_qcad::js2cpp_RNewDocumentListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RNewDocumentListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RNewDocumentListener_Wrapper* wrapper = qobject_cast<RNewDocumentListener_Wrapper*>(obj);
          //RNewDocumentListener_Wrapper* wrapper = dynamic_cast<RNewDocumentListener_Wrapper*>(obj);
          //RNewDocumentListener_Wrapper* wrapper = (RNewDocumentListener_Wrapper*)(obj);
          //RNewDocumentListener_Wrapper* wrapper = getWrapper<RNewDocumentListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RNewDocumentListener_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RNewDocumentListener(wrapper);
          return RNewDocumentListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RNewDocumentListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RNewDocumentListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RNewDocumentListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RObject(RJSApi& handler, RObject* v) {

          
            // downcast to RBlock:
            {
                RBlock* o = dynamic_cast<RBlock*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RBlock(handler, o);
                }
            }
          
            // downcast to RDocumentVariables:
            {
                RDocumentVariables* o = dynamic_cast<RDocumentVariables*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDocumentVariables(handler, o);
                }
            }
          
            // downcast to REntity:
            {
                REntity* o = dynamic_cast<REntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_REntity(handler, o);
                }
            }
          
            // downcast to RLayer:
            {
                RLayer* o = dynamic_cast<RLayer*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RLayer(handler, o);
                }
            }
          
            // downcast to RLayerState:
            {
                RLayerState* o = dynamic_cast<RLayerState*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RLayerState(handler, o);
                }
            }
          
            // downcast to RLayout:
            {
                RLayout* o = dynamic_cast<RLayout*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RLayout(handler, o);
                }
            }
          
            // downcast to RLinetype:
            {
                RLinetype* o = dynamic_cast<RLinetype*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RLinetype(handler, o);
                }
            }
          
            // downcast to RUcs:
            {
                RUcs* o = dynamic_cast<RUcs*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RUcs(handler, o);
                }
            }
          
            // downcast to RView:
            {
                RView* o = dynamic_cast<RView*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RView(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RObject_Wrapper* ret = new RObject_Wrapper(handler, v, false);

          // JS: new RObject('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RObject");
          if (cl.isUndefined()) {
              qWarning() << "Class RObject is undefined. Use RObject_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RObject('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RObject(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RObject* RJSHelper_qcad::js2cpp_RObject_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RObject: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RObject_Wrapper* wrapper = qobject_cast<RObject_Wrapper*>(obj);
          //RObject_Wrapper* wrapper = dynamic_cast<RObject_Wrapper*>(obj);
          //RObject_Wrapper* wrapper = (RObject_Wrapper*)(obj);
          //RObject_Wrapper* wrapper = getWrapper<RObject_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RObject_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RObject(wrapper);
          return RObject_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RObject_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RObject: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RObject::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_ROperation(RJSApi& handler, ROperation* v) {

          
            // downcast to RAddObjectsOperation:
            {
                RAddObjectsOperation* o = dynamic_cast<RAddObjectsOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RAddObjectsOperation(handler, o);
                }
            }
          
            // downcast to RChangePropertyOperation:
            {
                RChangePropertyOperation* o = dynamic_cast<RChangePropertyOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RChangePropertyOperation(handler, o);
                }
            }
          
            // downcast to RClickReferencePointOperation:
            {
                RClickReferencePointOperation* o = dynamic_cast<RClickReferencePointOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RClickReferencePointOperation(handler, o);
                }
            }
          
            // downcast to RClipboardOperation:
            {
                RClipboardOperation* o = dynamic_cast<RClipboardOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RClipboardOperation(handler, o);
                }
            }
          
            // downcast to RDeleteAllEntitiesOperation:
            {
                RDeleteAllEntitiesOperation* o = dynamic_cast<RDeleteAllEntitiesOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDeleteAllEntitiesOperation(handler, o);
                }
            }
          
            // downcast to RDeleteObjectsOperation:
            {
                RDeleteObjectsOperation* o = dynamic_cast<RDeleteObjectsOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDeleteObjectsOperation(handler, o);
                }
            }
          
            // downcast to RMixedOperation:
            {
                RMixedOperation* o = dynamic_cast<RMixedOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RMixedOperation(handler, o);
                }
            }
          
            // downcast to RMoveReferencePointOperation:
            {
                RMoveReferencePointOperation* o = dynamic_cast<RMoveReferencePointOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RMoveReferencePointOperation(handler, o);
                }
            }
          
            // downcast to RMoveSelectionOperation:
            {
                RMoveSelectionOperation* o = dynamic_cast<RMoveSelectionOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RMoveSelectionOperation(handler, o);
                }
            }
          
            // downcast to RScaleSelectionOperation:
            {
                RScaleSelectionOperation* o = dynamic_cast<RScaleSelectionOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RScaleSelectionOperation(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          ROperation_Wrapper* ret = new ROperation_Wrapper(handler, v, false);

          // JS: new ROperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("ROperation");
          if (cl.isUndefined()) {
              qWarning() << "Class ROperation is undefined. Use ROperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new ROperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new ROperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      ROperation* RJSHelper_qcad::js2cpp_ROperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_ROperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //ROperation_Wrapper* wrapper = qobject_cast<ROperation_Wrapper*>(obj);
          //ROperation_Wrapper* wrapper = dynamic_cast<ROperation_Wrapper*>(obj);
          //ROperation_Wrapper* wrapper = (ROperation_Wrapper*)(obj);
          //ROperation_Wrapper* wrapper = getWrapper<ROperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_ROperation_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_ROperation(wrapper);
          return ROperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_ROperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_ROperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_ROperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_ROperationUtils(RJSApi& handler, ROperationUtils* v) {

          

          QJSEngine* engine = handler.getEngine();
          ROperationUtils_Wrapper* ret = new ROperationUtils_Wrapper(handler, v, false);

          // JS: new ROperationUtils('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("ROperationUtils");
          if (cl.isUndefined()) {
              qWarning() << "Class ROperationUtils is undefined. Use ROperationUtils_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new ROperationUtils('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new ROperationUtils(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      ROperationUtils* RJSHelper_qcad::js2cpp_ROperationUtils_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_ROperationUtils: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //ROperationUtils_Wrapper* wrapper = qobject_cast<ROperationUtils_Wrapper*>(obj);
          //ROperationUtils_Wrapper* wrapper = dynamic_cast<ROperationUtils_Wrapper*>(obj);
          //ROperationUtils_Wrapper* wrapper = (ROperationUtils_Wrapper*)(obj);
          //ROperationUtils_Wrapper* wrapper = getWrapper<ROperationUtils_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_ROperationUtils_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_ROperationUtils(wrapper);
          return ROperationUtils_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_ROperationUtils_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_ROperationUtils: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_ROperationUtils::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_ROrthoGrid(RJSApi& handler, ROrthoGrid* v) {

          

          QJSEngine* engine = handler.getEngine();
          ROrthoGrid_Wrapper* ret = new ROrthoGrid_Wrapper(handler, v, false);

          // JS: new ROrthoGrid('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("ROrthoGrid");
          if (cl.isUndefined()) {
              qWarning() << "Class ROrthoGrid is undefined. Use ROrthoGrid_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new ROrthoGrid('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new ROrthoGrid(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      ROrthoGrid* RJSHelper_qcad::js2cpp_ROrthoGrid_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_ROrthoGrid: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //ROrthoGrid_Wrapper* wrapper = qobject_cast<ROrthoGrid_Wrapper*>(obj);
          //ROrthoGrid_Wrapper* wrapper = dynamic_cast<ROrthoGrid_Wrapper*>(obj);
          //ROrthoGrid_Wrapper* wrapper = (ROrthoGrid_Wrapper*)(obj);
          //ROrthoGrid_Wrapper* wrapper = getWrapper<ROrthoGrid_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_ROrthoGrid_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_ROrthoGrid(wrapper);
          return ROrthoGrid_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_ROrthoGrid_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_ROrthoGrid: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_ROrthoGrid::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPaletteListener(RJSApi& handler, RPaletteListener* v) {

          
            // downcast to RPaletteListenerAdapter:
            {
                RPaletteListenerAdapter* o = dynamic_cast<RPaletteListenerAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RPaletteListenerAdapter(handler, o);
                }
            }
          
            // downcast to RRulerQt:
            {
                RRulerQt* o = dynamic_cast<RRulerQt*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RRulerQt(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RPaletteListener_Wrapper* ret = new RPaletteListener_Wrapper(handler, v, false);

          // JS: new RPaletteListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPaletteListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RPaletteListener is undefined. Use RPaletteListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPaletteListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPaletteListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RPaletteListener* RJSHelper_qcad::js2cpp_RPaletteListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPaletteListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPaletteListener_Wrapper* wrapper = qobject_cast<RPaletteListener_Wrapper*>(obj);
          //RPaletteListener_Wrapper* wrapper = dynamic_cast<RPaletteListener_Wrapper*>(obj);
          //RPaletteListener_Wrapper* wrapper = (RPaletteListener_Wrapper*)(obj);
          //RPaletteListener_Wrapper* wrapper = getWrapper<RPaletteListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPaletteListener_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RPaletteListener(wrapper);
          return RPaletteListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPaletteListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPaletteListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RPaletteListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPasteOperation(RJSApi& handler, RPasteOperation* v) {

          

          QJSEngine* engine = handler.getEngine();
          RPasteOperation_Wrapper* ret = new RPasteOperation_Wrapper(handler, v, false);

          // JS: new RPasteOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPasteOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RPasteOperation is undefined. Use RPasteOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPasteOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPasteOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RPasteOperation* RJSHelper_qcad::js2cpp_RPasteOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPasteOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPasteOperation_Wrapper* wrapper = qobject_cast<RPasteOperation_Wrapper*>(obj);
          //RPasteOperation_Wrapper* wrapper = dynamic_cast<RPasteOperation_Wrapper*>(obj);
          //RPasteOperation_Wrapper* wrapper = (RPasteOperation_Wrapper*)(obj);
          //RPasteOperation_Wrapper* wrapper = getWrapper<RPasteOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPasteOperation_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RPasteOperation(wrapper);
          return RPasteOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPasteOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPasteOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RPasteOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPenListener(RJSApi& handler, RPenListener* v) {

          
            // downcast to RPenListenerAdapter:
            {
                RPenListenerAdapter* o = dynamic_cast<RPenListenerAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RPenListenerAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RPenListener_Wrapper* ret = new RPenListener_Wrapper(handler, v, false);

          // JS: new RPenListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPenListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RPenListener is undefined. Use RPenListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPenListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPenListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RPenListener* RJSHelper_qcad::js2cpp_RPenListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPenListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPenListener_Wrapper* wrapper = qobject_cast<RPenListener_Wrapper*>(obj);
          //RPenListener_Wrapper* wrapper = dynamic_cast<RPenListener_Wrapper*>(obj);
          //RPenListener_Wrapper* wrapper = (RPenListener_Wrapper*)(obj);
          //RPenListener_Wrapper* wrapper = getWrapper<RPenListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPenListener_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RPenListener(wrapper);
          return RPenListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPenListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPenListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RPenListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPluginInterface(RJSApi& handler, RPluginInterface* v) {

          

          QJSEngine* engine = handler.getEngine();
          RPluginInterface_Wrapper* ret = new RPluginInterface_Wrapper(handler, v, false);

          // JS: new RPluginInterface('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPluginInterface");
          if (cl.isUndefined()) {
              qWarning() << "Class RPluginInterface is undefined. Use RPluginInterface_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPluginInterface('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPluginInterface(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RPluginInterface* RJSHelper_qcad::js2cpp_RPluginInterface_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPluginInterface: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPluginInterface_Wrapper* wrapper = qobject_cast<RPluginInterface_Wrapper*>(obj);
          //RPluginInterface_Wrapper* wrapper = dynamic_cast<RPluginInterface_Wrapper*>(obj);
          //RPluginInterface_Wrapper* wrapper = (RPluginInterface_Wrapper*)(obj);
          //RPluginInterface_Wrapper* wrapper = getWrapper<RPluginInterface_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPluginInterface_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RPluginInterface(wrapper);
          return RPluginInterface_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPluginInterface_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPluginInterface: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RPluginInterface::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPointEntity(RJSApi& handler, RPointEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RPointEntity_Wrapper* ret = new RPointEntity_Wrapper(handler, v, false);

          // JS: new RPointEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPointEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RPointEntity is undefined. Use RPointEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPointEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPointEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RPointEntity* RJSHelper_qcad::js2cpp_RPointEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPointEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPointEntity_Wrapper* wrapper = qobject_cast<RPointEntity_Wrapper*>(obj);
          //RPointEntity_Wrapper* wrapper = dynamic_cast<RPointEntity_Wrapper*>(obj);
          //RPointEntity_Wrapper* wrapper = (RPointEntity_Wrapper*)(obj);
          //RPointEntity_Wrapper* wrapper = getWrapper<RPointEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPointEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RPointEntity(wrapper);
          return RPointEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPointEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPointEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RPointEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPolylineEntity(RJSApi& handler, RPolylineEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RPolylineEntity_Wrapper* ret = new RPolylineEntity_Wrapper(handler, v, false);

          // JS: new RPolylineEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPolylineEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RPolylineEntity is undefined. Use RPolylineEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPolylineEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPolylineEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RPolylineEntity* RJSHelper_qcad::js2cpp_RPolylineEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPolylineEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPolylineEntity_Wrapper* wrapper = qobject_cast<RPolylineEntity_Wrapper*>(obj);
          //RPolylineEntity_Wrapper* wrapper = dynamic_cast<RPolylineEntity_Wrapper*>(obj);
          //RPolylineEntity_Wrapper* wrapper = (RPolylineEntity_Wrapper*)(obj);
          //RPolylineEntity_Wrapper* wrapper = getWrapper<RPolylineEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPolylineEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RPolylineEntity(wrapper);
          return RPolylineEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPolylineEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPolylineEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RPolylineEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPreferencesListener(RJSApi& handler, RPreferencesListener* v) {

          
            // downcast to RPreferencesListenerAdapter:
            {
                RPreferencesListenerAdapter* o = dynamic_cast<RPreferencesListenerAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RPreferencesListenerAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RPreferencesListener_Wrapper* ret = new RPreferencesListener_Wrapper(handler, v, false);

          // JS: new RPreferencesListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPreferencesListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RPreferencesListener is undefined. Use RPreferencesListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPreferencesListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPreferencesListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RPreferencesListener* RJSHelper_qcad::js2cpp_RPreferencesListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPreferencesListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPreferencesListener_Wrapper* wrapper = qobject_cast<RPreferencesListener_Wrapper*>(obj);
          //RPreferencesListener_Wrapper* wrapper = dynamic_cast<RPreferencesListener_Wrapper*>(obj);
          //RPreferencesListener_Wrapper* wrapper = (RPreferencesListener_Wrapper*)(obj);
          //RPreferencesListener_Wrapper* wrapper = getWrapper<RPreferencesListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPreferencesListener_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RPreferencesListener(wrapper);
          return RPreferencesListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPreferencesListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPreferencesListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RPreferencesListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RProgressHandler(RJSApi& handler, RProgressHandler* v) {

          

          QJSEngine* engine = handler.getEngine();
          RProgressHandler_Wrapper* ret = new RProgressHandler_Wrapper(handler, v, false);

          // JS: new RProgressHandler('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RProgressHandler");
          if (cl.isUndefined()) {
              qWarning() << "Class RProgressHandler is undefined. Use RProgressHandler_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RProgressHandler('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RProgressHandler(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RProgressHandler* RJSHelper_qcad::js2cpp_RProgressHandler_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RProgressHandler: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RProgressHandler_Wrapper* wrapper = qobject_cast<RProgressHandler_Wrapper*>(obj);
          //RProgressHandler_Wrapper* wrapper = dynamic_cast<RProgressHandler_Wrapper*>(obj);
          //RProgressHandler_Wrapper* wrapper = (RProgressHandler_Wrapper*)(obj);
          //RProgressHandler_Wrapper* wrapper = getWrapper<RProgressHandler_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RProgressHandler_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RProgressHandler(wrapper);
          return RProgressHandler_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RProgressHandler_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RProgressHandler: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RProgressHandler::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPropertyEditor(RJSApi& handler, RPropertyEditor* v) {

          

          QJSEngine* engine = handler.getEngine();
          RPropertyEditor_Wrapper* ret = new RPropertyEditor_Wrapper(handler, v, false);

          // JS: new RPropertyEditor('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPropertyEditor");
          if (cl.isUndefined()) {
              qWarning() << "Class RPropertyEditor is undefined. Use RPropertyEditor_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPropertyEditor('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPropertyEditor(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RPropertyEditor* RJSHelper_qcad::js2cpp_RPropertyEditor_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPropertyEditor: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPropertyEditor_Wrapper* wrapper = qobject_cast<RPropertyEditor_Wrapper*>(obj);
          //RPropertyEditor_Wrapper* wrapper = dynamic_cast<RPropertyEditor_Wrapper*>(obj);
          //RPropertyEditor_Wrapper* wrapper = (RPropertyEditor_Wrapper*)(obj);
          //RPropertyEditor_Wrapper* wrapper = getWrapper<RPropertyEditor_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPropertyEditor_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RPropertyEditor(wrapper);
          return RPropertyEditor_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPropertyEditor_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPropertyEditor: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RPropertyEditor::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPropertyEvent(RJSApi& handler, RPropertyEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          RPropertyEvent_Wrapper* ret = new RPropertyEvent_Wrapper(handler, v, false);

          // JS: new RPropertyEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPropertyEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class RPropertyEvent is undefined. Use RPropertyEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPropertyEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPropertyEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RPropertyEvent* RJSHelper_qcad::js2cpp_RPropertyEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPropertyEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPropertyEvent_Wrapper* wrapper = qobject_cast<RPropertyEvent_Wrapper*>(obj);
          //RPropertyEvent_Wrapper* wrapper = dynamic_cast<RPropertyEvent_Wrapper*>(obj);
          //RPropertyEvent_Wrapper* wrapper = (RPropertyEvent_Wrapper*)(obj);
          //RPropertyEvent_Wrapper* wrapper = getWrapper<RPropertyEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPropertyEvent_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RPropertyEvent(wrapper);
          return RPropertyEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPropertyEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPropertyEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RPropertyEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPropertyListener(RJSApi& handler, RPropertyListener* v) {

          
            // downcast to RPropertyListenerAdapter:
            {
                RPropertyListenerAdapter* o = dynamic_cast<RPropertyListenerAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RPropertyListenerAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RPropertyListener_Wrapper* ret = new RPropertyListener_Wrapper(handler, v, false);

          // JS: new RPropertyListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPropertyListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RPropertyListener is undefined. Use RPropertyListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPropertyListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPropertyListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RPropertyListener* RJSHelper_qcad::js2cpp_RPropertyListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPropertyListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPropertyListener_Wrapper* wrapper = qobject_cast<RPropertyListener_Wrapper*>(obj);
          //RPropertyListener_Wrapper* wrapper = dynamic_cast<RPropertyListener_Wrapper*>(obj);
          //RPropertyListener_Wrapper* wrapper = (RPropertyListener_Wrapper*)(obj);
          //RPropertyListener_Wrapper* wrapper = getWrapper<RPropertyListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPropertyListener_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RPropertyListener(wrapper);
          return RPropertyListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPropertyListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPropertyListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RPropertyListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RRayEntity(RJSApi& handler, RRayEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RRayEntity_Wrapper* ret = new RRayEntity_Wrapper(handler, v, false);

          // JS: new RRayEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRayEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RRayEntity is undefined. Use RRayEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RRayEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RRayEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RRayEntity* RJSHelper_qcad::js2cpp_RRayEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RRayEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RRayEntity_Wrapper* wrapper = qobject_cast<RRayEntity_Wrapper*>(obj);
          //RRayEntity_Wrapper* wrapper = dynamic_cast<RRayEntity_Wrapper*>(obj);
          //RRayEntity_Wrapper* wrapper = (RRayEntity_Wrapper*)(obj);
          //RRayEntity_Wrapper* wrapper = getWrapper<RRayEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RRayEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RRayEntity(wrapper);
          return RRayEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RRayEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RRayEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RRayEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RRestrictAngleLength(RJSApi& handler, RRestrictAngleLength* v) {

          

          QJSEngine* engine = handler.getEngine();
          RRestrictAngleLength_Wrapper* ret = new RRestrictAngleLength_Wrapper(handler, v, false);

          // JS: new RRestrictAngleLength('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRestrictAngleLength");
          if (cl.isUndefined()) {
              qWarning() << "Class RRestrictAngleLength is undefined. Use RRestrictAngleLength_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RRestrictAngleLength('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RRestrictAngleLength(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RRestrictAngleLength* RJSHelper_qcad::js2cpp_RRestrictAngleLength_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RRestrictAngleLength: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RRestrictAngleLength_Wrapper* wrapper = qobject_cast<RRestrictAngleLength_Wrapper*>(obj);
          //RRestrictAngleLength_Wrapper* wrapper = dynamic_cast<RRestrictAngleLength_Wrapper*>(obj);
          //RRestrictAngleLength_Wrapper* wrapper = (RRestrictAngleLength_Wrapper*)(obj);
          //RRestrictAngleLength_Wrapper* wrapper = getWrapper<RRestrictAngleLength_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RRestrictAngleLength_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RRestrictAngleLength(wrapper);
          return RRestrictAngleLength_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RRestrictAngleLength_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RRestrictAngleLength: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RRestrictAngleLength::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RRestrictHorizontal(RJSApi& handler, RRestrictHorizontal* v) {

          

          QJSEngine* engine = handler.getEngine();
          RRestrictHorizontal_Wrapper* ret = new RRestrictHorizontal_Wrapper(handler, v, false);

          // JS: new RRestrictHorizontal('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRestrictHorizontal");
          if (cl.isUndefined()) {
              qWarning() << "Class RRestrictHorizontal is undefined. Use RRestrictHorizontal_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RRestrictHorizontal('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RRestrictHorizontal(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RRestrictHorizontal* RJSHelper_qcad::js2cpp_RRestrictHorizontal_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RRestrictHorizontal: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RRestrictHorizontal_Wrapper* wrapper = qobject_cast<RRestrictHorizontal_Wrapper*>(obj);
          //RRestrictHorizontal_Wrapper* wrapper = dynamic_cast<RRestrictHorizontal_Wrapper*>(obj);
          //RRestrictHorizontal_Wrapper* wrapper = (RRestrictHorizontal_Wrapper*)(obj);
          //RRestrictHorizontal_Wrapper* wrapper = getWrapper<RRestrictHorizontal_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RRestrictHorizontal_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RRestrictHorizontal(wrapper);
          return RRestrictHorizontal_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RRestrictHorizontal_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RRestrictHorizontal: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RRestrictHorizontal::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RRestrictOff(RJSApi& handler, RRestrictOff* v) {

          

          QJSEngine* engine = handler.getEngine();
          RRestrictOff_Wrapper* ret = new RRestrictOff_Wrapper(handler, v, false);

          // JS: new RRestrictOff('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRestrictOff");
          if (cl.isUndefined()) {
              qWarning() << "Class RRestrictOff is undefined. Use RRestrictOff_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RRestrictOff('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RRestrictOff(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RRestrictOff* RJSHelper_qcad::js2cpp_RRestrictOff_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RRestrictOff: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RRestrictOff_Wrapper* wrapper = qobject_cast<RRestrictOff_Wrapper*>(obj);
          //RRestrictOff_Wrapper* wrapper = dynamic_cast<RRestrictOff_Wrapper*>(obj);
          //RRestrictOff_Wrapper* wrapper = (RRestrictOff_Wrapper*)(obj);
          //RRestrictOff_Wrapper* wrapper = getWrapper<RRestrictOff_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RRestrictOff_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RRestrictOff(wrapper);
          return RRestrictOff_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RRestrictOff_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RRestrictOff: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RRestrictOff::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RRestrictOrthogonal(RJSApi& handler, RRestrictOrthogonal* v) {

          
            // downcast to RRestrictHorizontal:
            {
                RRestrictHorizontal* o = dynamic_cast<RRestrictHorizontal*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RRestrictHorizontal(handler, o);
                }
            }
          
            // downcast to RRestrictVertical:
            {
                RRestrictVertical* o = dynamic_cast<RRestrictVertical*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RRestrictVertical(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RRestrictOrthogonal_Wrapper* ret = new RRestrictOrthogonal_Wrapper(handler, v, false);

          // JS: new RRestrictOrthogonal('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRestrictOrthogonal");
          if (cl.isUndefined()) {
              qWarning() << "Class RRestrictOrthogonal is undefined. Use RRestrictOrthogonal_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RRestrictOrthogonal('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RRestrictOrthogonal(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RRestrictOrthogonal* RJSHelper_qcad::js2cpp_RRestrictOrthogonal_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RRestrictOrthogonal: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RRestrictOrthogonal_Wrapper* wrapper = qobject_cast<RRestrictOrthogonal_Wrapper*>(obj);
          //RRestrictOrthogonal_Wrapper* wrapper = dynamic_cast<RRestrictOrthogonal_Wrapper*>(obj);
          //RRestrictOrthogonal_Wrapper* wrapper = (RRestrictOrthogonal_Wrapper*)(obj);
          //RRestrictOrthogonal_Wrapper* wrapper = getWrapper<RRestrictOrthogonal_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RRestrictOrthogonal_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RRestrictOrthogonal(wrapper);
          return RRestrictOrthogonal_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RRestrictOrthogonal_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RRestrictOrthogonal: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RRestrictOrthogonal::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RRestrictVertical(RJSApi& handler, RRestrictVertical* v) {

          

          QJSEngine* engine = handler.getEngine();
          RRestrictVertical_Wrapper* ret = new RRestrictVertical_Wrapper(handler, v, false);

          // JS: new RRestrictVertical('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRestrictVertical");
          if (cl.isUndefined()) {
              qWarning() << "Class RRestrictVertical is undefined. Use RRestrictVertical_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RRestrictVertical('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RRestrictVertical(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RRestrictVertical* RJSHelper_qcad::js2cpp_RRestrictVertical_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RRestrictVertical: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RRestrictVertical_Wrapper* wrapper = qobject_cast<RRestrictVertical_Wrapper*>(obj);
          //RRestrictVertical_Wrapper* wrapper = dynamic_cast<RRestrictVertical_Wrapper*>(obj);
          //RRestrictVertical_Wrapper* wrapper = (RRestrictVertical_Wrapper*)(obj);
          //RRestrictVertical_Wrapper* wrapper = getWrapper<RRestrictVertical_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RRestrictVertical_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RRestrictVertical(wrapper);
          return RRestrictVertical_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RRestrictVertical_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RRestrictVertical: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RRestrictVertical::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RRuler(RJSApi& handler, RRuler* v) {

          

          QJSEngine* engine = handler.getEngine();
          RRuler_Wrapper* ret = new RRuler_Wrapper(handler, v, false);

          // JS: new RRuler('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRuler");
          if (cl.isUndefined()) {
              qWarning() << "Class RRuler is undefined. Use RRuler_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RRuler('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RRuler(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RRuler* RJSHelper_qcad::js2cpp_RRuler_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RRuler: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RRuler_Wrapper* wrapper = qobject_cast<RRuler_Wrapper*>(obj);
          //RRuler_Wrapper* wrapper = dynamic_cast<RRuler_Wrapper*>(obj);
          //RRuler_Wrapper* wrapper = (RRuler_Wrapper*)(obj);
          //RRuler_Wrapper* wrapper = getWrapper<RRuler_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RRuler_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RRuler(wrapper);
          return RRuler_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RRuler_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RRuler: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RRuler::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RScaleSelectionOperation(RJSApi& handler, RScaleSelectionOperation* v) {

          

          QJSEngine* engine = handler.getEngine();
          RScaleSelectionOperation_Wrapper* ret = new RScaleSelectionOperation_Wrapper(handler, v, false);

          // JS: new RScaleSelectionOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RScaleSelectionOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RScaleSelectionOperation is undefined. Use RScaleSelectionOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RScaleSelectionOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RScaleSelectionOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RScaleSelectionOperation* RJSHelper_qcad::js2cpp_RScaleSelectionOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RScaleSelectionOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RScaleSelectionOperation_Wrapper* wrapper = qobject_cast<RScaleSelectionOperation_Wrapper*>(obj);
          //RScaleSelectionOperation_Wrapper* wrapper = dynamic_cast<RScaleSelectionOperation_Wrapper*>(obj);
          //RScaleSelectionOperation_Wrapper* wrapper = (RScaleSelectionOperation_Wrapper*)(obj);
          //RScaleSelectionOperation_Wrapper* wrapper = getWrapper<RScaleSelectionOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RScaleSelectionOperation_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RScaleSelectionOperation(wrapper);
          return RScaleSelectionOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RScaleSelectionOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RScaleSelectionOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RScaleSelectionOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSelectionListener(RJSApi& handler, RSelectionListener* v) {

          
            // downcast to RSelectionListenerAdapter:
            {
                RSelectionListenerAdapter* o = dynamic_cast<RSelectionListenerAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSelectionListenerAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RSelectionListener_Wrapper* ret = new RSelectionListener_Wrapper(handler, v, false);

          // JS: new RSelectionListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSelectionListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RSelectionListener is undefined. Use RSelectionListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSelectionListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSelectionListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSelectionListener* RJSHelper_qcad::js2cpp_RSelectionListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSelectionListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSelectionListener_Wrapper* wrapper = qobject_cast<RSelectionListener_Wrapper*>(obj);
          //RSelectionListener_Wrapper* wrapper = dynamic_cast<RSelectionListener_Wrapper*>(obj);
          //RSelectionListener_Wrapper* wrapper = (RSelectionListener_Wrapper*)(obj);
          //RSelectionListener_Wrapper* wrapper = getWrapper<RSelectionListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSelectionListener_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RSelectionListener(wrapper);
          return RSelectionListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSelectionListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSelectionListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSelectionListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnap(RJSApi& handler, RSnap* v) {

          
            // downcast to RSnapAuto:
            {
                RSnapAuto* o = dynamic_cast<RSnapAuto*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSnapAuto(handler, o);
                }
            }
          
            // downcast to RSnapEntityBase:
            {
                RSnapEntityBase* o = dynamic_cast<RSnapEntityBase*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSnapEntityBase(handler, o);
                }
            }
          
            // downcast to RSnapFree:
            {
                RSnapFree* o = dynamic_cast<RSnapFree*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSnapFree(handler, o);
                }
            }
          
            // downcast to RSnapGrid:
            {
                RSnapGrid* o = dynamic_cast<RSnapGrid*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSnapGrid(handler, o);
                }
            }
          
            // downcast to RSnapIntersection:
            {
                RSnapIntersection* o = dynamic_cast<RSnapIntersection*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSnapIntersection(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RSnap_Wrapper* ret = new RSnap_Wrapper(handler, v, false);

          // JS: new RSnap('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnap");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnap is undefined. Use RSnap_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnap('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnap(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnap* RJSHelper_qcad::js2cpp_RSnap_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnap: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnap_Wrapper* wrapper = qobject_cast<RSnap_Wrapper*>(obj);
          //RSnap_Wrapper* wrapper = dynamic_cast<RSnap_Wrapper*>(obj);
          //RSnap_Wrapper* wrapper = (RSnap_Wrapper*)(obj);
          //RSnap_Wrapper* wrapper = getWrapper<RSnap_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnap_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RSnap(wrapper);
          return RSnap_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnap_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnap: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnap::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapAuto(RJSApi& handler, RSnapAuto* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSnapAuto_Wrapper* ret = new RSnapAuto_Wrapper(handler, v, false);

          // JS: new RSnapAuto('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapAuto");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapAuto is undefined. Use RSnapAuto_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapAuto('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapAuto(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapAuto* RJSHelper_qcad::js2cpp_RSnapAuto_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapAuto: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapAuto_Wrapper* wrapper = qobject_cast<RSnapAuto_Wrapper*>(obj);
          //RSnapAuto_Wrapper* wrapper = dynamic_cast<RSnapAuto_Wrapper*>(obj);
          //RSnapAuto_Wrapper* wrapper = (RSnapAuto_Wrapper*)(obj);
          //RSnapAuto_Wrapper* wrapper = getWrapper<RSnapAuto_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapAuto_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RSnapAuto(wrapper);
          return RSnapAuto_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapAuto_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapAuto: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapAuto::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapCenter(RJSApi& handler, RSnapCenter* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSnapCenter_Wrapper* ret = new RSnapCenter_Wrapper(handler, v, false);

          // JS: new RSnapCenter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapCenter");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapCenter is undefined. Use RSnapCenter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapCenter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapCenter(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapCenter* RJSHelper_qcad::js2cpp_RSnapCenter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapCenter: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapCenter_Wrapper* wrapper = qobject_cast<RSnapCenter_Wrapper*>(obj);
          //RSnapCenter_Wrapper* wrapper = dynamic_cast<RSnapCenter_Wrapper*>(obj);
          //RSnapCenter_Wrapper* wrapper = (RSnapCenter_Wrapper*)(obj);
          //RSnapCenter_Wrapper* wrapper = getWrapper<RSnapCenter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapCenter_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RSnapCenter(wrapper);
          return RSnapCenter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapCenter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapCenter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapCenter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapDistance(RJSApi& handler, RSnapDistance* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSnapDistance_Wrapper* ret = new RSnapDistance_Wrapper(handler, v, false);

          // JS: new RSnapDistance('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapDistance");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapDistance is undefined. Use RSnapDistance_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapDistance('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapDistance(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapDistance* RJSHelper_qcad::js2cpp_RSnapDistance_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapDistance: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapDistance_Wrapper* wrapper = qobject_cast<RSnapDistance_Wrapper*>(obj);
          //RSnapDistance_Wrapper* wrapper = dynamic_cast<RSnapDistance_Wrapper*>(obj);
          //RSnapDistance_Wrapper* wrapper = (RSnapDistance_Wrapper*)(obj);
          //RSnapDistance_Wrapper* wrapper = getWrapper<RSnapDistance_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapDistance_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RSnapDistance(wrapper);
          return RSnapDistance_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapDistance_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapDistance: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapDistance::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapEnd(RJSApi& handler, RSnapEnd* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSnapEnd_Wrapper* ret = new RSnapEnd_Wrapper(handler, v, false);

          // JS: new RSnapEnd('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapEnd");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapEnd is undefined. Use RSnapEnd_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapEnd('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapEnd(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapEnd* RJSHelper_qcad::js2cpp_RSnapEnd_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapEnd: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapEnd_Wrapper* wrapper = qobject_cast<RSnapEnd_Wrapper*>(obj);
          //RSnapEnd_Wrapper* wrapper = dynamic_cast<RSnapEnd_Wrapper*>(obj);
          //RSnapEnd_Wrapper* wrapper = (RSnapEnd_Wrapper*)(obj);
          //RSnapEnd_Wrapper* wrapper = getWrapper<RSnapEnd_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapEnd_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RSnapEnd(wrapper);
          return RSnapEnd_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapEnd_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapEnd: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapEnd::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapEntityBase(RJSApi& handler, RSnapEntityBase* v) {

          
            // downcast to RSnapCenter:
            {
                RSnapCenter* o = dynamic_cast<RSnapCenter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSnapCenter(handler, o);
                }
            }
          
            // downcast to RSnapDistance:
            {
                RSnapDistance* o = dynamic_cast<RSnapDistance*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSnapDistance(handler, o);
                }
            }
          
            // downcast to RSnapEnd:
            {
                RSnapEnd* o = dynamic_cast<RSnapEnd*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSnapEnd(handler, o);
                }
            }
          
            // downcast to RSnapMiddle:
            {
                RSnapMiddle* o = dynamic_cast<RSnapMiddle*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSnapMiddle(handler, o);
                }
            }
          
            // downcast to RSnapOnEntity:
            {
                RSnapOnEntity* o = dynamic_cast<RSnapOnEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSnapOnEntity(handler, o);
                }
            }
          
            // downcast to RSnapPerpendicular:
            {
                RSnapPerpendicular* o = dynamic_cast<RSnapPerpendicular*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSnapPerpendicular(handler, o);
                }
            }
          
            // downcast to RSnapReference:
            {
                RSnapReference* o = dynamic_cast<RSnapReference*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSnapReference(handler, o);
                }
            }
          
            // downcast to RSnapTangential:
            {
                RSnapTangential* o = dynamic_cast<RSnapTangential*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSnapTangential(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RSnapEntityBase_Wrapper* ret = new RSnapEntityBase_Wrapper(handler, v, false);

          // JS: new RSnapEntityBase('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapEntityBase");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapEntityBase is undefined. Use RSnapEntityBase_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapEntityBase('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapEntityBase(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapEntityBase* RJSHelper_qcad::js2cpp_RSnapEntityBase_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapEntityBase: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapEntityBase_Wrapper* wrapper = qobject_cast<RSnapEntityBase_Wrapper*>(obj);
          //RSnapEntityBase_Wrapper* wrapper = dynamic_cast<RSnapEntityBase_Wrapper*>(obj);
          //RSnapEntityBase_Wrapper* wrapper = (RSnapEntityBase_Wrapper*)(obj);
          //RSnapEntityBase_Wrapper* wrapper = getWrapper<RSnapEntityBase_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapEntityBase_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RSnapEntityBase(wrapper);
          return RSnapEntityBase_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapEntityBase_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapEntityBase: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapEntityBase::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapFree(RJSApi& handler, RSnapFree* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSnapFree_Wrapper* ret = new RSnapFree_Wrapper(handler, v, false);

          // JS: new RSnapFree('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapFree");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapFree is undefined. Use RSnapFree_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapFree('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapFree(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapFree* RJSHelper_qcad::js2cpp_RSnapFree_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapFree: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapFree_Wrapper* wrapper = qobject_cast<RSnapFree_Wrapper*>(obj);
          //RSnapFree_Wrapper* wrapper = dynamic_cast<RSnapFree_Wrapper*>(obj);
          //RSnapFree_Wrapper* wrapper = (RSnapFree_Wrapper*)(obj);
          //RSnapFree_Wrapper* wrapper = getWrapper<RSnapFree_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapFree_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RSnapFree(wrapper);
          return RSnapFree_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapFree_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapFree: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapFree::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapGrid(RJSApi& handler, RSnapGrid* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSnapGrid_Wrapper* ret = new RSnapGrid_Wrapper(handler, v, false);

          // JS: new RSnapGrid('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapGrid");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapGrid is undefined. Use RSnapGrid_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapGrid('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapGrid(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapGrid* RJSHelper_qcad::js2cpp_RSnapGrid_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapGrid: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapGrid_Wrapper* wrapper = qobject_cast<RSnapGrid_Wrapper*>(obj);
          //RSnapGrid_Wrapper* wrapper = dynamic_cast<RSnapGrid_Wrapper*>(obj);
          //RSnapGrid_Wrapper* wrapper = (RSnapGrid_Wrapper*)(obj);
          //RSnapGrid_Wrapper* wrapper = getWrapper<RSnapGrid_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapGrid_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RSnapGrid(wrapper);
          return RSnapGrid_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapGrid_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapGrid: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapGrid::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapIntersection(RJSApi& handler, RSnapIntersection* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSnapIntersection_Wrapper* ret = new RSnapIntersection_Wrapper(handler, v, false);

          // JS: new RSnapIntersection('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapIntersection");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapIntersection is undefined. Use RSnapIntersection_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapIntersection('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapIntersection(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapIntersection* RJSHelper_qcad::js2cpp_RSnapIntersection_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapIntersection: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapIntersection_Wrapper* wrapper = qobject_cast<RSnapIntersection_Wrapper*>(obj);
          //RSnapIntersection_Wrapper* wrapper = dynamic_cast<RSnapIntersection_Wrapper*>(obj);
          //RSnapIntersection_Wrapper* wrapper = (RSnapIntersection_Wrapper*)(obj);
          //RSnapIntersection_Wrapper* wrapper = getWrapper<RSnapIntersection_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapIntersection_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RSnapIntersection(wrapper);
          return RSnapIntersection_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapIntersection_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapIntersection: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapIntersection::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapListener(RJSApi& handler, RSnapListener* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSnapListener_Wrapper* ret = new RSnapListener_Wrapper(handler, v, false);

          // JS: new RSnapListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapListener is undefined. Use RSnapListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapListener* RJSHelper_qcad::js2cpp_RSnapListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapListener_Wrapper* wrapper = qobject_cast<RSnapListener_Wrapper*>(obj);
          //RSnapListener_Wrapper* wrapper = dynamic_cast<RSnapListener_Wrapper*>(obj);
          //RSnapListener_Wrapper* wrapper = (RSnapListener_Wrapper*)(obj);
          //RSnapListener_Wrapper* wrapper = getWrapper<RSnapListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapListener_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RSnapListener(wrapper);
          return RSnapListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapMiddle(RJSApi& handler, RSnapMiddle* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSnapMiddle_Wrapper* ret = new RSnapMiddle_Wrapper(handler, v, false);

          // JS: new RSnapMiddle('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapMiddle");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapMiddle is undefined. Use RSnapMiddle_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapMiddle('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapMiddle(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapMiddle* RJSHelper_qcad::js2cpp_RSnapMiddle_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapMiddle: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapMiddle_Wrapper* wrapper = qobject_cast<RSnapMiddle_Wrapper*>(obj);
          //RSnapMiddle_Wrapper* wrapper = dynamic_cast<RSnapMiddle_Wrapper*>(obj);
          //RSnapMiddle_Wrapper* wrapper = (RSnapMiddle_Wrapper*)(obj);
          //RSnapMiddle_Wrapper* wrapper = getWrapper<RSnapMiddle_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapMiddle_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RSnapMiddle(wrapper);
          return RSnapMiddle_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapMiddle_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapMiddle: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapMiddle::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapOnEntity(RJSApi& handler, RSnapOnEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSnapOnEntity_Wrapper* ret = new RSnapOnEntity_Wrapper(handler, v, false);

          // JS: new RSnapOnEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapOnEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapOnEntity is undefined. Use RSnapOnEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapOnEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapOnEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapOnEntity* RJSHelper_qcad::js2cpp_RSnapOnEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapOnEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapOnEntity_Wrapper* wrapper = qobject_cast<RSnapOnEntity_Wrapper*>(obj);
          //RSnapOnEntity_Wrapper* wrapper = dynamic_cast<RSnapOnEntity_Wrapper*>(obj);
          //RSnapOnEntity_Wrapper* wrapper = (RSnapOnEntity_Wrapper*)(obj);
          //RSnapOnEntity_Wrapper* wrapper = getWrapper<RSnapOnEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapOnEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RSnapOnEntity(wrapper);
          return RSnapOnEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapOnEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapOnEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapOnEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapPerpendicular(RJSApi& handler, RSnapPerpendicular* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSnapPerpendicular_Wrapper* ret = new RSnapPerpendicular_Wrapper(handler, v, false);

          // JS: new RSnapPerpendicular('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapPerpendicular");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapPerpendicular is undefined. Use RSnapPerpendicular_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapPerpendicular('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapPerpendicular(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapPerpendicular* RJSHelper_qcad::js2cpp_RSnapPerpendicular_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapPerpendicular: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapPerpendicular_Wrapper* wrapper = qobject_cast<RSnapPerpendicular_Wrapper*>(obj);
          //RSnapPerpendicular_Wrapper* wrapper = dynamic_cast<RSnapPerpendicular_Wrapper*>(obj);
          //RSnapPerpendicular_Wrapper* wrapper = (RSnapPerpendicular_Wrapper*)(obj);
          //RSnapPerpendicular_Wrapper* wrapper = getWrapper<RSnapPerpendicular_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapPerpendicular_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RSnapPerpendicular(wrapper);
          return RSnapPerpendicular_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapPerpendicular_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapPerpendicular: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapPerpendicular::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapReference(RJSApi& handler, RSnapReference* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSnapReference_Wrapper* ret = new RSnapReference_Wrapper(handler, v, false);

          // JS: new RSnapReference('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapReference");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapReference is undefined. Use RSnapReference_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapReference('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapReference(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapReference* RJSHelper_qcad::js2cpp_RSnapReference_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapReference: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapReference_Wrapper* wrapper = qobject_cast<RSnapReference_Wrapper*>(obj);
          //RSnapReference_Wrapper* wrapper = dynamic_cast<RSnapReference_Wrapper*>(obj);
          //RSnapReference_Wrapper* wrapper = (RSnapReference_Wrapper*)(obj);
          //RSnapReference_Wrapper* wrapper = getWrapper<RSnapReference_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapReference_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RSnapReference(wrapper);
          return RSnapReference_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapReference_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapReference: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapReference::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapRestriction(RJSApi& handler, RSnapRestriction* v) {

          
            // downcast to RRestrictAngleLength:
            {
                RRestrictAngleLength* o = dynamic_cast<RRestrictAngleLength*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RRestrictAngleLength(handler, o);
                }
            }
          
            // downcast to RRestrictOff:
            {
                RRestrictOff* o = dynamic_cast<RRestrictOff*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RRestrictOff(handler, o);
                }
            }
          
            // downcast to RRestrictOrthogonal:
            {
                RRestrictOrthogonal* o = dynamic_cast<RRestrictOrthogonal*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RRestrictOrthogonal(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RSnapRestriction_Wrapper* ret = new RSnapRestriction_Wrapper(handler, v, false);

          // JS: new RSnapRestriction('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapRestriction");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapRestriction is undefined. Use RSnapRestriction_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapRestriction('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapRestriction(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapRestriction* RJSHelper_qcad::js2cpp_RSnapRestriction_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapRestriction: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapRestriction_Wrapper* wrapper = qobject_cast<RSnapRestriction_Wrapper*>(obj);
          //RSnapRestriction_Wrapper* wrapper = dynamic_cast<RSnapRestriction_Wrapper*>(obj);
          //RSnapRestriction_Wrapper* wrapper = (RSnapRestriction_Wrapper*)(obj);
          //RSnapRestriction_Wrapper* wrapper = getWrapper<RSnapRestriction_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapRestriction_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RSnapRestriction(wrapper);
          return RSnapRestriction_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapRestriction_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapRestriction: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapRestriction::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapTangential(RJSApi& handler, RSnapTangential* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSnapTangential_Wrapper* ret = new RSnapTangential_Wrapper(handler, v, false);

          // JS: new RSnapTangential('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapTangential");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapTangential is undefined. Use RSnapTangential_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapTangential('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapTangential(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapTangential* RJSHelper_qcad::js2cpp_RSnapTangential_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapTangential: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapTangential_Wrapper* wrapper = qobject_cast<RSnapTangential_Wrapper*>(obj);
          //RSnapTangential_Wrapper* wrapper = dynamic_cast<RSnapTangential_Wrapper*>(obj);
          //RSnapTangential_Wrapper* wrapper = (RSnapTangential_Wrapper*)(obj);
          //RSnapTangential_Wrapper* wrapper = getWrapper<RSnapTangential_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapTangential_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RSnapTangential(wrapper);
          return RSnapTangential_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapTangential_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapTangential: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapTangential::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSolidEntity(RJSApi& handler, RSolidEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSolidEntity_Wrapper* ret = new RSolidEntity_Wrapper(handler, v, false);

          // JS: new RSolidEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSolidEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RSolidEntity is undefined. Use RSolidEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSolidEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSolidEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSolidEntity* RJSHelper_qcad::js2cpp_RSolidEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSolidEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSolidEntity_Wrapper* wrapper = qobject_cast<RSolidEntity_Wrapper*>(obj);
          //RSolidEntity_Wrapper* wrapper = dynamic_cast<RSolidEntity_Wrapper*>(obj);
          //RSolidEntity_Wrapper* wrapper = (RSolidEntity_Wrapper*)(obj);
          //RSolidEntity_Wrapper* wrapper = getWrapper<RSolidEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSolidEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RSolidEntity(wrapper);
          return RSolidEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSolidEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSolidEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSolidEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSpatialIndex(RJSApi& handler, RSpatialIndex* v) {

          
            // downcast to RSpatialIndexNavel:
            {
                RSpatialIndexNavel* o = dynamic_cast<RSpatialIndexNavel*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSpatialIndexNavel(handler, o);
                }
            }
          
            // downcast to RSpatialIndexSimple:
            {
                RSpatialIndexSimple* o = dynamic_cast<RSpatialIndexSimple*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSpatialIndexSimple(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RSpatialIndex_Wrapper* ret = new RSpatialIndex_Wrapper(handler, v, false);

          // JS: new RSpatialIndex('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSpatialIndex");
          if (cl.isUndefined()) {
              qWarning() << "Class RSpatialIndex is undefined. Use RSpatialIndex_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSpatialIndex('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSpatialIndex(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSpatialIndex* RJSHelper_qcad::js2cpp_RSpatialIndex_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSpatialIndex: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSpatialIndex_Wrapper* wrapper = qobject_cast<RSpatialIndex_Wrapper*>(obj);
          //RSpatialIndex_Wrapper* wrapper = dynamic_cast<RSpatialIndex_Wrapper*>(obj);
          //RSpatialIndex_Wrapper* wrapper = (RSpatialIndex_Wrapper*)(obj);
          //RSpatialIndex_Wrapper* wrapper = getWrapper<RSpatialIndex_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSpatialIndex_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RSpatialIndex(wrapper);
          return RSpatialIndex_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSpatialIndex_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSpatialIndex: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSpatialIndex::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSpatialIndexSimple(RJSApi& handler, RSpatialIndexSimple* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSpatialIndexSimple_Wrapper* ret = new RSpatialIndexSimple_Wrapper(handler, v, false);

          // JS: new RSpatialIndexSimple('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSpatialIndexSimple");
          if (cl.isUndefined()) {
              qWarning() << "Class RSpatialIndexSimple is undefined. Use RSpatialIndexSimple_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSpatialIndexSimple('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSpatialIndexSimple(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSpatialIndexSimple* RJSHelper_qcad::js2cpp_RSpatialIndexSimple_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSpatialIndexSimple: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSpatialIndexSimple_Wrapper* wrapper = qobject_cast<RSpatialIndexSimple_Wrapper*>(obj);
          //RSpatialIndexSimple_Wrapper* wrapper = dynamic_cast<RSpatialIndexSimple_Wrapper*>(obj);
          //RSpatialIndexSimple_Wrapper* wrapper = (RSpatialIndexSimple_Wrapper*)(obj);
          //RSpatialIndexSimple_Wrapper* wrapper = getWrapper<RSpatialIndexSimple_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSpatialIndexSimple_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RSpatialIndexSimple(wrapper);
          return RSpatialIndexSimple_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSpatialIndexSimple_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSpatialIndexSimple: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSpatialIndexSimple::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSpatialIndexVisitor(RJSApi& handler, RSpatialIndexVisitor* v) {

          
            // downcast to RSpatialIndexVisitorAdapter:
            {
                RSpatialIndexVisitorAdapter* o = dynamic_cast<RSpatialIndexVisitorAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSpatialIndexVisitorAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RSpatialIndexVisitor_Wrapper* ret = new RSpatialIndexVisitor_Wrapper(handler, v, false);

          // JS: new RSpatialIndexVisitor('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSpatialIndexVisitor");
          if (cl.isUndefined()) {
              qWarning() << "Class RSpatialIndexVisitor is undefined. Use RSpatialIndexVisitor_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSpatialIndexVisitor('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSpatialIndexVisitor(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSpatialIndexVisitor* RJSHelper_qcad::js2cpp_RSpatialIndexVisitor_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSpatialIndexVisitor: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSpatialIndexVisitor_Wrapper* wrapper = qobject_cast<RSpatialIndexVisitor_Wrapper*>(obj);
          //RSpatialIndexVisitor_Wrapper* wrapper = dynamic_cast<RSpatialIndexVisitor_Wrapper*>(obj);
          //RSpatialIndexVisitor_Wrapper* wrapper = (RSpatialIndexVisitor_Wrapper*)(obj);
          //RSpatialIndexVisitor_Wrapper* wrapper = getWrapper<RSpatialIndexVisitor_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSpatialIndexVisitor_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RSpatialIndexVisitor(wrapper);
          return RSpatialIndexVisitor_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSpatialIndexVisitor_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSpatialIndexVisitor: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSpatialIndexVisitor::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSplineEntity(RJSApi& handler, RSplineEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSplineEntity_Wrapper* ret = new RSplineEntity_Wrapper(handler, v, false);

          // JS: new RSplineEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSplineEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RSplineEntity is undefined. Use RSplineEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSplineEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSplineEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSplineEntity* RJSHelper_qcad::js2cpp_RSplineEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSplineEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSplineEntity_Wrapper* wrapper = qobject_cast<RSplineEntity_Wrapper*>(obj);
          //RSplineEntity_Wrapper* wrapper = dynamic_cast<RSplineEntity_Wrapper*>(obj);
          //RSplineEntity_Wrapper* wrapper = (RSplineEntity_Wrapper*)(obj);
          //RSplineEntity_Wrapper* wrapper = getWrapper<RSplineEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSplineEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RSplineEntity(wrapper);
          return RSplineEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSplineEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSplineEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSplineEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RStorage(RJSApi& handler, RStorage* v) {

          
            // downcast to RMemoryStorage:
            {
                RMemoryStorage* o = dynamic_cast<RMemoryStorage*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RMemoryStorage(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RStorage_Wrapper* ret = new RStorage_Wrapper(handler, v, false);

          // JS: new RStorage('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RStorage");
          if (cl.isUndefined()) {
              qWarning() << "Class RStorage is undefined. Use RStorage_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RStorage('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RStorage(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RStorage* RJSHelper_qcad::js2cpp_RStorage_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RStorage: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RStorage_Wrapper* wrapper = qobject_cast<RStorage_Wrapper*>(obj);
          //RStorage_Wrapper* wrapper = dynamic_cast<RStorage_Wrapper*>(obj);
          //RStorage_Wrapper* wrapper = (RStorage_Wrapper*)(obj);
          //RStorage_Wrapper* wrapper = getWrapper<RStorage_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RStorage_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RStorage(wrapper);
          return RStorage_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RStorage_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RStorage: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RStorage::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTabletEvent(RJSApi& handler, RTabletEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          RTabletEvent_Wrapper* ret = new RTabletEvent_Wrapper(handler, v, false);

          // JS: new RTabletEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTabletEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class RTabletEvent is undefined. Use RTabletEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTabletEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTabletEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RTabletEvent* RJSHelper_qcad::js2cpp_RTabletEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTabletEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RTabletEvent_Wrapper* wrapper = qobject_cast<RTabletEvent_Wrapper*>(obj);
          //RTabletEvent_Wrapper* wrapper = dynamic_cast<RTabletEvent_Wrapper*>(obj);
          //RTabletEvent_Wrapper* wrapper = (RTabletEvent_Wrapper*)(obj);
          //RTabletEvent_Wrapper* wrapper = getWrapper<RTabletEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTabletEvent_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RTabletEvent(wrapper);
          return RTabletEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RTabletEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTabletEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RTabletEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTerminateEvent(RJSApi& handler, RTerminateEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          RTerminateEvent_Wrapper* ret = new RTerminateEvent_Wrapper(handler, v, false);

          // JS: new RTerminateEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTerminateEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class RTerminateEvent is undefined. Use RTerminateEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTerminateEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTerminateEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RTerminateEvent* RJSHelper_qcad::js2cpp_RTerminateEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTerminateEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RTerminateEvent_Wrapper* wrapper = qobject_cast<RTerminateEvent_Wrapper*>(obj);
          //RTerminateEvent_Wrapper* wrapper = dynamic_cast<RTerminateEvent_Wrapper*>(obj);
          //RTerminateEvent_Wrapper* wrapper = (RTerminateEvent_Wrapper*)(obj);
          //RTerminateEvent_Wrapper* wrapper = getWrapper<RTerminateEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTerminateEvent_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RTerminateEvent(wrapper);
          return RTerminateEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RTerminateEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTerminateEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RTerminateEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTextBasedEntity(RJSApi& handler, RTextBasedEntity* v) {

          
            // downcast to RAttributeDefinitionEntity:
            {
                RAttributeDefinitionEntity* o = dynamic_cast<RAttributeDefinitionEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RAttributeDefinitionEntity(handler, o);
                }
            }
          
            // downcast to RAttributeEntity:
            {
                RAttributeEntity* o = dynamic_cast<RAttributeEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RAttributeEntity(handler, o);
                }
            }
          
            // downcast to RTextEntity:
            {
                RTextEntity* o = dynamic_cast<RTextEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RTextEntity(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RTextBasedEntity_Wrapper* ret = new RTextBasedEntity_Wrapper(handler, v, false);

          // JS: new RTextBasedEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTextBasedEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RTextBasedEntity is undefined. Use RTextBasedEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTextBasedEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTextBasedEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RTextBasedEntity* RJSHelper_qcad::js2cpp_RTextBasedEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTextBasedEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RTextBasedEntity_Wrapper* wrapper = qobject_cast<RTextBasedEntity_Wrapper*>(obj);
          //RTextBasedEntity_Wrapper* wrapper = dynamic_cast<RTextBasedEntity_Wrapper*>(obj);
          //RTextBasedEntity_Wrapper* wrapper = (RTextBasedEntity_Wrapper*)(obj);
          //RTextBasedEntity_Wrapper* wrapper = getWrapper<RTextBasedEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTextBasedEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RTextBasedEntity(wrapper);
          return RTextBasedEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RTextBasedEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTextBasedEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RTextBasedEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTextEntity(RJSApi& handler, RTextEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RTextEntity_Wrapper* ret = new RTextEntity_Wrapper(handler, v, false);

          // JS: new RTextEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTextEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RTextEntity is undefined. Use RTextEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTextEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTextEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RTextEntity* RJSHelper_qcad::js2cpp_RTextEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTextEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RTextEntity_Wrapper* wrapper = qobject_cast<RTextEntity_Wrapper*>(obj);
          //RTextEntity_Wrapper* wrapper = dynamic_cast<RTextEntity_Wrapper*>(obj);
          //RTextEntity_Wrapper* wrapper = (RTextEntity_Wrapper*)(obj);
          //RTextEntity_Wrapper* wrapper = getWrapper<RTextEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTextEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RTextEntity(wrapper);
          return RTextEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RTextEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTextEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RTextEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTextRenderer(RJSApi& handler, RTextRenderer* v) {

          

          QJSEngine* engine = handler.getEngine();
          RTextRenderer_Wrapper* ret = new RTextRenderer_Wrapper(handler, v, false);

          // JS: new RTextRenderer('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTextRenderer");
          if (cl.isUndefined()) {
              qWarning() << "Class RTextRenderer is undefined. Use RTextRenderer_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTextRenderer('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTextRenderer(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RTextRenderer* RJSHelper_qcad::js2cpp_RTextRenderer_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTextRenderer: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RTextRenderer_Wrapper* wrapper = qobject_cast<RTextRenderer_Wrapper*>(obj);
          //RTextRenderer_Wrapper* wrapper = dynamic_cast<RTextRenderer_Wrapper*>(obj);
          //RTextRenderer_Wrapper* wrapper = (RTextRenderer_Wrapper*)(obj);
          //RTextRenderer_Wrapper* wrapper = getWrapper<RTextRenderer_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTextRenderer_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RTextRenderer(wrapper);
          return RTextRenderer_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RTextRenderer_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTextRenderer: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RTextRenderer::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RToleranceEntity(RJSApi& handler, RToleranceEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RToleranceEntity_Wrapper* ret = new RToleranceEntity_Wrapper(handler, v, false);

          // JS: new RToleranceEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RToleranceEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RToleranceEntity is undefined. Use RToleranceEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RToleranceEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RToleranceEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RToleranceEntity* RJSHelper_qcad::js2cpp_RToleranceEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RToleranceEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RToleranceEntity_Wrapper* wrapper = qobject_cast<RToleranceEntity_Wrapper*>(obj);
          //RToleranceEntity_Wrapper* wrapper = dynamic_cast<RToleranceEntity_Wrapper*>(obj);
          //RToleranceEntity_Wrapper* wrapper = (RToleranceEntity_Wrapper*)(obj);
          //RToleranceEntity_Wrapper* wrapper = getWrapper<RToleranceEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RToleranceEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RToleranceEntity(wrapper);
          return RToleranceEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RToleranceEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RToleranceEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RToleranceEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTraceEntity(RJSApi& handler, RTraceEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RTraceEntity_Wrapper* ret = new RTraceEntity_Wrapper(handler, v, false);

          // JS: new RTraceEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTraceEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RTraceEntity is undefined. Use RTraceEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTraceEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTraceEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RTraceEntity* RJSHelper_qcad::js2cpp_RTraceEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTraceEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RTraceEntity_Wrapper* wrapper = qobject_cast<RTraceEntity_Wrapper*>(obj);
          //RTraceEntity_Wrapper* wrapper = dynamic_cast<RTraceEntity_Wrapper*>(obj);
          //RTraceEntity_Wrapper* wrapper = (RTraceEntity_Wrapper*)(obj);
          //RTraceEntity_Wrapper* wrapper = getWrapper<RTraceEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTraceEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RTraceEntity(wrapper);
          return RTraceEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RTraceEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTraceEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RTraceEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTransaction(RJSApi& handler, RTransaction* v) {

          

          QJSEngine* engine = handler.getEngine();
          RTransaction_Wrapper* ret = new RTransaction_Wrapper(handler, v, false);

          // JS: new RTransaction('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTransaction");
          if (cl.isUndefined()) {
              qWarning() << "Class RTransaction is undefined. Use RTransaction_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTransaction('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTransaction(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RTransaction* RJSHelper_qcad::js2cpp_RTransaction_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTransaction: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RTransaction_Wrapper* wrapper = qobject_cast<RTransaction_Wrapper*>(obj);
          //RTransaction_Wrapper* wrapper = dynamic_cast<RTransaction_Wrapper*>(obj);
          //RTransaction_Wrapper* wrapper = (RTransaction_Wrapper*)(obj);
          //RTransaction_Wrapper* wrapper = getWrapper<RTransaction_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTransaction_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RTransaction(wrapper);
          return RTransaction_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RTransaction_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTransaction: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RTransaction::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTransactionListener(RJSApi& handler, RTransactionListener* v) {

          
            // downcast to RTransactionListenerAdapter:
            {
                RTransactionListenerAdapter* o = dynamic_cast<RTransactionListenerAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RTransactionListenerAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RTransactionListener_Wrapper* ret = new RTransactionListener_Wrapper(handler, v, false);

          // JS: new RTransactionListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTransactionListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RTransactionListener is undefined. Use RTransactionListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTransactionListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTransactionListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RTransactionListener* RJSHelper_qcad::js2cpp_RTransactionListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTransactionListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RTransactionListener_Wrapper* wrapper = qobject_cast<RTransactionListener_Wrapper*>(obj);
          //RTransactionListener_Wrapper* wrapper = dynamic_cast<RTransactionListener_Wrapper*>(obj);
          //RTransactionListener_Wrapper* wrapper = (RTransactionListener_Wrapper*)(obj);
          //RTransactionListener_Wrapper* wrapper = getWrapper<RTransactionListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTransactionListener_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RTransactionListener(wrapper);
          return RTransactionListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RTransactionListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTransactionListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RTransactionListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTransactionStack(RJSApi& handler, RTransactionStack* v) {

          

          QJSEngine* engine = handler.getEngine();
          RTransactionStack_Wrapper* ret = new RTransactionStack_Wrapper(handler, v, false);

          // JS: new RTransactionStack('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTransactionStack");
          if (cl.isUndefined()) {
              qWarning() << "Class RTransactionStack is undefined. Use RTransactionStack_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTransactionStack('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTransactionStack(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RTransactionStack* RJSHelper_qcad::js2cpp_RTransactionStack_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTransactionStack: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RTransactionStack_Wrapper* wrapper = qobject_cast<RTransactionStack_Wrapper*>(obj);
          //RTransactionStack_Wrapper* wrapper = dynamic_cast<RTransactionStack_Wrapper*>(obj);
          //RTransactionStack_Wrapper* wrapper = (RTransactionStack_Wrapper*)(obj);
          //RTransactionStack_Wrapper* wrapper = getWrapper<RTransactionStack_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTransactionStack_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RTransactionStack(wrapper);
          return RTransactionStack_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RTransactionStack_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTransactionStack: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RTransactionStack::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTransformation(RJSApi& handler, RTransformation* v) {

          
            // downcast to RTranslation:
            {
                RTranslation* o = dynamic_cast<RTranslation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RTranslation(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RTransformation_Wrapper* ret = new RTransformation_Wrapper(handler, v, false);

          // JS: new RTransformation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTransformation");
          if (cl.isUndefined()) {
              qWarning() << "Class RTransformation is undefined. Use RTransformation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTransformation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTransformation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RTransformation* RJSHelper_qcad::js2cpp_RTransformation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTransformation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RTransformation_Wrapper* wrapper = qobject_cast<RTransformation_Wrapper*>(obj);
          //RTransformation_Wrapper* wrapper = dynamic_cast<RTransformation_Wrapper*>(obj);
          //RTransformation_Wrapper* wrapper = (RTransformation_Wrapper*)(obj);
          //RTransformation_Wrapper* wrapper = getWrapper<RTransformation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTransformation_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RTransformation(wrapper);
          return RTransformation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RTransformation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTransformation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RTransformation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTranslation(RJSApi& handler, RTranslation* v) {

          

          QJSEngine* engine = handler.getEngine();
          RTranslation_Wrapper* ret = new RTranslation_Wrapper(handler, v, false);

          // JS: new RTranslation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTranslation");
          if (cl.isUndefined()) {
              qWarning() << "Class RTranslation is undefined. Use RTranslation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTranslation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTranslation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RTranslation* RJSHelper_qcad::js2cpp_RTranslation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTranslation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RTranslation_Wrapper* wrapper = qobject_cast<RTranslation_Wrapper*>(obj);
          //RTranslation_Wrapper* wrapper = dynamic_cast<RTranslation_Wrapper*>(obj);
          //RTranslation_Wrapper* wrapper = (RTranslation_Wrapper*)(obj);
          //RTranslation_Wrapper* wrapper = getWrapper<RTranslation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTranslation_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RTranslation(wrapper);
          return RTranslation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RTranslation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTranslation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RTranslation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RUcs(RJSApi& handler, RUcs* v) {

          

          QJSEngine* engine = handler.getEngine();
          RUcs_Wrapper* ret = new RUcs_Wrapper(handler, v, false);

          // JS: new RUcs('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RUcs");
          if (cl.isUndefined()) {
              qWarning() << "Class RUcs is undefined. Use RUcs_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RUcs('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RUcs(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RUcs* RJSHelper_qcad::js2cpp_RUcs_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RUcs: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RUcs_Wrapper* wrapper = qobject_cast<RUcs_Wrapper*>(obj);
          //RUcs_Wrapper* wrapper = dynamic_cast<RUcs_Wrapper*>(obj);
          //RUcs_Wrapper* wrapper = (RUcs_Wrapper*)(obj);
          //RUcs_Wrapper* wrapper = getWrapper<RUcs_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RUcs_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RUcs(wrapper);
          return RUcs_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RUcs_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RUcs: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RUcs::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RUcsListener(RJSApi& handler, RUcsListener* v) {

          

          QJSEngine* engine = handler.getEngine();
          RUcsListener_Wrapper* ret = new RUcsListener_Wrapper(handler, v, false);

          // JS: new RUcsListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RUcsListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RUcsListener is undefined. Use RUcsListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RUcsListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RUcsListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RUcsListener* RJSHelper_qcad::js2cpp_RUcsListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RUcsListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RUcsListener_Wrapper* wrapper = qobject_cast<RUcsListener_Wrapper*>(obj);
          //RUcsListener_Wrapper* wrapper = dynamic_cast<RUcsListener_Wrapper*>(obj);
          //RUcsListener_Wrapper* wrapper = (RUcsListener_Wrapper*)(obj);
          //RUcsListener_Wrapper* wrapper = getWrapper<RUcsListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RUcsListener_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RUcsListener(wrapper);
          return RUcsListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RUcsListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RUcsListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RUcsListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RView(RJSApi& handler, RView* v) {

          

          QJSEngine* engine = handler.getEngine();
          RView_Wrapper* ret = new RView_Wrapper(handler, v, false);

          // JS: new RView('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RView");
          if (cl.isUndefined()) {
              qWarning() << "Class RView is undefined. Use RView_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RView('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RView(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RView* RJSHelper_qcad::js2cpp_RView_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RView: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RView_Wrapper* wrapper = qobject_cast<RView_Wrapper*>(obj);
          //RView_Wrapper* wrapper = dynamic_cast<RView_Wrapper*>(obj);
          //RView_Wrapper* wrapper = (RView_Wrapper*)(obj);
          //RView_Wrapper* wrapper = getWrapper<RView_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RView_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RView(wrapper);
          return RView_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RView_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RView: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RView::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RViewFocusListener(RJSApi& handler, RViewFocusListener* v) {

          
            // downcast to RViewFocusListenerAdapter:
            {
                RViewFocusListenerAdapter* o = dynamic_cast<RViewFocusListenerAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RViewFocusListenerAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RViewFocusListener_Wrapper* ret = new RViewFocusListener_Wrapper(handler, v, false);

          // JS: new RViewFocusListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RViewFocusListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RViewFocusListener is undefined. Use RViewFocusListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RViewFocusListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RViewFocusListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RViewFocusListener* RJSHelper_qcad::js2cpp_RViewFocusListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RViewFocusListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RViewFocusListener_Wrapper* wrapper = qobject_cast<RViewFocusListener_Wrapper*>(obj);
          //RViewFocusListener_Wrapper* wrapper = dynamic_cast<RViewFocusListener_Wrapper*>(obj);
          //RViewFocusListener_Wrapper* wrapper = (RViewFocusListener_Wrapper*)(obj);
          //RViewFocusListener_Wrapper* wrapper = getWrapper<RViewFocusListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RViewFocusListener_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RViewFocusListener(wrapper);
          return RViewFocusListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RViewFocusListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RViewFocusListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RViewFocusListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RViewListener(RJSApi& handler, RViewListener* v) {

          
            // downcast to RViewListenerAdapter:
            {
                RViewListenerAdapter* o = dynamic_cast<RViewListenerAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RViewListenerAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RViewListener_Wrapper* ret = new RViewListener_Wrapper(handler, v, false);

          // JS: new RViewListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RViewListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RViewListener is undefined. Use RViewListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RViewListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RViewListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RViewListener* RJSHelper_qcad::js2cpp_RViewListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RViewListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RViewListener_Wrapper* wrapper = qobject_cast<RViewListener_Wrapper*>(obj);
          //RViewListener_Wrapper* wrapper = dynamic_cast<RViewListener_Wrapper*>(obj);
          //RViewListener_Wrapper* wrapper = (RViewListener_Wrapper*)(obj);
          //RViewListener_Wrapper* wrapper = getWrapper<RViewListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RViewListener_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RViewListener(wrapper);
          return RViewListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RViewListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RViewListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RViewListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RViewportEntity(RJSApi& handler, RViewportEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RViewportEntity_Wrapper* ret = new RViewportEntity_Wrapper(handler, v, false);

          // JS: new RViewportEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RViewportEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RViewportEntity is undefined. Use RViewportEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RViewportEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RViewportEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RViewportEntity* RJSHelper_qcad::js2cpp_RViewportEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RViewportEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RViewportEntity_Wrapper* wrapper = qobject_cast<RViewportEntity_Wrapper*>(obj);
          //RViewportEntity_Wrapper* wrapper = dynamic_cast<RViewportEntity_Wrapper*>(obj);
          //RViewportEntity_Wrapper* wrapper = (RViewportEntity_Wrapper*)(obj);
          //RViewportEntity_Wrapper* wrapper = getWrapper<RViewportEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RViewportEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RViewportEntity(wrapper);
          return RViewportEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RViewportEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RViewportEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RViewportEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RWheelEvent(RJSApi& handler, RWheelEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          RWheelEvent_Wrapper* ret = new RWheelEvent_Wrapper(handler, v, false);

          // JS: new RWheelEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RWheelEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class RWheelEvent is undefined. Use RWheelEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RWheelEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RWheelEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RWheelEvent* RJSHelper_qcad::js2cpp_RWheelEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RWheelEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RWheelEvent_Wrapper* wrapper = qobject_cast<RWheelEvent_Wrapper*>(obj);
          //RWheelEvent_Wrapper* wrapper = dynamic_cast<RWheelEvent_Wrapper*>(obj);
          //RWheelEvent_Wrapper* wrapper = (RWheelEvent_Wrapper*)(obj);
          //RWheelEvent_Wrapper* wrapper = getWrapper<RWheelEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RWheelEvent_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RWheelEvent(wrapper);
          return RWheelEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RWheelEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RWheelEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RWheelEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RXLineEntity(RJSApi& handler, RXLineEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RXLineEntity_Wrapper* ret = new RXLineEntity_Wrapper(handler, v, false);

          // JS: new RXLineEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RXLineEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RXLineEntity is undefined. Use RXLineEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RXLineEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RXLineEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RXLineEntity* RJSHelper_qcad::js2cpp_RXLineEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RXLineEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RXLineEntity_Wrapper* wrapper = qobject_cast<RXLineEntity_Wrapper*>(obj);
          //RXLineEntity_Wrapper* wrapper = dynamic_cast<RXLineEntity_Wrapper*>(obj);
          //RXLineEntity_Wrapper* wrapper = (RXLineEntity_Wrapper*)(obj);
          //RXLineEntity_Wrapper* wrapper = getWrapper<RXLineEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RXLineEntity_ptr: no wrapper";
              return nullptr;
          }
          //return getWrapped_RXLineEntity(wrapper);
          return RXLineEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RXLineEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RXLineEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RXLineEntity::getIdStatic())).toBool();
      }
    
  // ------------------------------
  // wrapped QObject pointer types:
  // ------------------------------
  
      QJSValue RJSHelper_qcad::cpp2js_RBlockListenerAdapter(RJSApi& handler, RBlockListenerAdapter* v) {
          RBlockListenerAdapter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RBlockListenerAdapter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RBlockListenerAdapter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RBlockListenerAdapter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RBlockListenerAdapter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RBlockListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RBlockListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RBlockListenerAdapter is undefined. Use RBlockListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RBlockListenerAdapter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RBlockListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RBlockListenerAdapter(RJSApi& handler, const RBlockListenerAdapter* v) {
          return RJSHelper_qcad::cpp2js_RBlockListenerAdapter(handler, const_cast<RBlockListenerAdapter*>(v));
      }

      RBlockListenerAdapter* RJSHelper_qcad::js2cpp_RBlockListenerAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RBlockListenerAdapter: not a QObject";
              return nullptr;
          }
          //RBlockListenerAdapter_Wrapper* wrapper = getWrapper<RBlockListenerAdapter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RBlockListenerAdapter_Wrapper* wrapper = qobject_cast<RBlockListenerAdapter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RBlockListenerAdapter_Wrapper* wrapper = dynamic_cast<RBlockListenerAdapter_Wrapper*>(obj);
          //RBlockListenerAdapter_Wrapper* wrapper = (RBlockListenerAdapter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RBlockListenerAdapter: no wrapper";
              return nullptr;
          }
          //return (RBlockListenerAdapter*)wrapper->getWrappedVoid();
          //return getWrapped_RBlockListenerAdapter(wrapper);
          return RBlockListenerAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RBlockListenerAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RBlockListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RBlockListenerAdapter_Type);
          //return fun.call().toInt()==RJSType::RBlockListenerAdapter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RBlockListenerAdapter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RCadToolBar(RJSApi& handler, RCadToolBar* v) {
          RCadToolBar_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RCadToolBar_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RCadToolBar: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RCadToolBar_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RCadToolBar_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RCadToolBar('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCadToolBar");
          if (cl.isUndefined()) {
              qWarning() << "Class RCadToolBar is undefined. Use RCadToolBar_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCadToolBar('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCadToolBar(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RCadToolBar(RJSApi& handler, const RCadToolBar* v) {
          return RJSHelper_qcad::cpp2js_RCadToolBar(handler, const_cast<RCadToolBar*>(v));
      }

      RCadToolBar* RJSHelper_qcad::js2cpp_RCadToolBar_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RCadToolBar: not a QObject";
              return nullptr;
          }
          //RCadToolBar_Wrapper* wrapper = getWrapper<RCadToolBar_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RCadToolBar_Wrapper* wrapper = qobject_cast<RCadToolBar_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RCadToolBar_Wrapper* wrapper = dynamic_cast<RCadToolBar_Wrapper*>(obj);
          //RCadToolBar_Wrapper* wrapper = (RCadToolBar_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCadToolBar: no wrapper";
              return nullptr;
          }
          //return (RCadToolBar*)wrapper->getWrappedVoid();
          //return getWrapped_RCadToolBar(wrapper);
          return RCadToolBar_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RCadToolBar_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RCadToolBar: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RCadToolBar_Type);
          //return fun.call().toInt()==RJSType::RCadToolBar_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RCadToolBar::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RCadToolBarPanel(RJSApi& handler, RCadToolBarPanel* v) {
          RCadToolBarPanel_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RCadToolBarPanel_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RCadToolBarPanel: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RCadToolBarPanel_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RCadToolBarPanel_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RCadToolBarPanel('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCadToolBarPanel");
          if (cl.isUndefined()) {
              qWarning() << "Class RCadToolBarPanel is undefined. Use RCadToolBarPanel_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCadToolBarPanel('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCadToolBarPanel(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RCadToolBarPanel(RJSApi& handler, const RCadToolBarPanel* v) {
          return RJSHelper_qcad::cpp2js_RCadToolBarPanel(handler, const_cast<RCadToolBarPanel*>(v));
      }

      RCadToolBarPanel* RJSHelper_qcad::js2cpp_RCadToolBarPanel_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RCadToolBarPanel: not a QObject";
              return nullptr;
          }
          //RCadToolBarPanel_Wrapper* wrapper = getWrapper<RCadToolBarPanel_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RCadToolBarPanel_Wrapper* wrapper = qobject_cast<RCadToolBarPanel_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RCadToolBarPanel_Wrapper* wrapper = dynamic_cast<RCadToolBarPanel_Wrapper*>(obj);
          //RCadToolBarPanel_Wrapper* wrapper = (RCadToolBarPanel_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCadToolBarPanel: no wrapper";
              return nullptr;
          }
          //return (RCadToolBarPanel*)wrapper->getWrappedVoid();
          //return getWrapped_RCadToolBarPanel(wrapper);
          return RCadToolBarPanel_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RCadToolBarPanel_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RCadToolBarPanel: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RCadToolBarPanel_Type);
          //return fun.call().toInt()==RJSType::RCadToolBarPanel_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RCadToolBarPanel::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RCharacterWidget(RJSApi& handler, RCharacterWidget* v) {
          RCharacterWidget_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RCharacterWidget_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RCharacterWidget: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RCharacterWidget_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RCharacterWidget_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RCharacterWidget('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCharacterWidget");
          if (cl.isUndefined()) {
              qWarning() << "Class RCharacterWidget is undefined. Use RCharacterWidget_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCharacterWidget('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCharacterWidget(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RCharacterWidget(RJSApi& handler, const RCharacterWidget* v) {
          return RJSHelper_qcad::cpp2js_RCharacterWidget(handler, const_cast<RCharacterWidget*>(v));
      }

      RCharacterWidget* RJSHelper_qcad::js2cpp_RCharacterWidget_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RCharacterWidget: not a QObject";
              return nullptr;
          }
          //RCharacterWidget_Wrapper* wrapper = getWrapper<RCharacterWidget_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RCharacterWidget_Wrapper* wrapper = qobject_cast<RCharacterWidget_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RCharacterWidget_Wrapper* wrapper = dynamic_cast<RCharacterWidget_Wrapper*>(obj);
          //RCharacterWidget_Wrapper* wrapper = (RCharacterWidget_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCharacterWidget: no wrapper";
              return nullptr;
          }
          //return (RCharacterWidget*)wrapper->getWrappedVoid();
          //return getWrapped_RCharacterWidget(wrapper);
          return RCharacterWidget_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RCharacterWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RCharacterWidget: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RCharacterWidget_Type);
          //return fun.call().toInt()==RJSType::RCharacterWidget_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RCharacterWidget::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RColorCombo(RJSApi& handler, RColorCombo* v) {
          RColorCombo_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RColorCombo_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RColorCombo: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RColorCombo_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RColorCombo_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RColorCombo('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RColorCombo");
          if (cl.isUndefined()) {
              qWarning() << "Class RColorCombo is undefined. Use RColorCombo_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RColorCombo('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RColorCombo(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RColorCombo(RJSApi& handler, const RColorCombo* v) {
          return RJSHelper_qcad::cpp2js_RColorCombo(handler, const_cast<RColorCombo*>(v));
      }

      RColorCombo* RJSHelper_qcad::js2cpp_RColorCombo_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RColorCombo: not a QObject";
              return nullptr;
          }
          //RColorCombo_Wrapper* wrapper = getWrapper<RColorCombo_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RColorCombo_Wrapper* wrapper = qobject_cast<RColorCombo_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RColorCombo_Wrapper* wrapper = dynamic_cast<RColorCombo_Wrapper*>(obj);
          //RColorCombo_Wrapper* wrapper = (RColorCombo_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RColorCombo: no wrapper";
              return nullptr;
          }
          //return (RColorCombo*)wrapper->getWrappedVoid();
          //return getWrapped_RColorCombo(wrapper);
          return RColorCombo_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RColorCombo_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RColorCombo: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RColorCombo_Type);
          //return fun.call().toInt()==RJSType::RColorCombo_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RColorCombo::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RCommandLine(RJSApi& handler, RCommandLine* v) {
          RCommandLine_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RCommandLine_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RCommandLine: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RCommandLine_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RCommandLine_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RCommandLine('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCommandLine");
          if (cl.isUndefined()) {
              qWarning() << "Class RCommandLine is undefined. Use RCommandLine_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCommandLine('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCommandLine(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RCommandLine(RJSApi& handler, const RCommandLine* v) {
          return RJSHelper_qcad::cpp2js_RCommandLine(handler, const_cast<RCommandLine*>(v));
      }

      RCommandLine* RJSHelper_qcad::js2cpp_RCommandLine_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RCommandLine: not a QObject";
              return nullptr;
          }
          //RCommandLine_Wrapper* wrapper = getWrapper<RCommandLine_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RCommandLine_Wrapper* wrapper = qobject_cast<RCommandLine_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RCommandLine_Wrapper* wrapper = dynamic_cast<RCommandLine_Wrapper*>(obj);
          //RCommandLine_Wrapper* wrapper = (RCommandLine_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCommandLine: no wrapper";
              return nullptr;
          }
          //return (RCommandLine*)wrapper->getWrappedVoid();
          //return getWrapped_RCommandLine(wrapper);
          return RCommandLine_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RCommandLine_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RCommandLine: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RCommandLine_Type);
          //return fun.call().toInt()==RJSType::RCommandLine_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RCommandLine::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RCoordinateListenerAdapter(RJSApi& handler, RCoordinateListenerAdapter* v) {
          RCoordinateListenerAdapter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RCoordinateListenerAdapter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RCoordinateListenerAdapter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RCoordinateListenerAdapter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RCoordinateListenerAdapter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RCoordinateListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCoordinateListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RCoordinateListenerAdapter is undefined. Use RCoordinateListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCoordinateListenerAdapter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCoordinateListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RCoordinateListenerAdapter(RJSApi& handler, const RCoordinateListenerAdapter* v) {
          return RJSHelper_qcad::cpp2js_RCoordinateListenerAdapter(handler, const_cast<RCoordinateListenerAdapter*>(v));
      }

      RCoordinateListenerAdapter* RJSHelper_qcad::js2cpp_RCoordinateListenerAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RCoordinateListenerAdapter: not a QObject";
              return nullptr;
          }
          //RCoordinateListenerAdapter_Wrapper* wrapper = getWrapper<RCoordinateListenerAdapter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RCoordinateListenerAdapter_Wrapper* wrapper = qobject_cast<RCoordinateListenerAdapter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RCoordinateListenerAdapter_Wrapper* wrapper = dynamic_cast<RCoordinateListenerAdapter_Wrapper*>(obj);
          //RCoordinateListenerAdapter_Wrapper* wrapper = (RCoordinateListenerAdapter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCoordinateListenerAdapter: no wrapper";
              return nullptr;
          }
          //return (RCoordinateListenerAdapter*)wrapper->getWrappedVoid();
          //return getWrapped_RCoordinateListenerAdapter(wrapper);
          return RCoordinateListenerAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RCoordinateListenerAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RCoordinateListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RCoordinateListenerAdapter_Type);
          //return fun.call().toInt()==RJSType::RCoordinateListenerAdapter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RCoordinateListenerAdapter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RDockWidget(RJSApi& handler, RDockWidget* v) {
          RDockWidget_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RDockWidget_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RDockWidget: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RDockWidget_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RDockWidget_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RDockWidget('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDockWidget");
          if (cl.isUndefined()) {
              qWarning() << "Class RDockWidget is undefined. Use RDockWidget_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDockWidget('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDockWidget(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RDockWidget(RJSApi& handler, const RDockWidget* v) {
          return RJSHelper_qcad::cpp2js_RDockWidget(handler, const_cast<RDockWidget*>(v));
      }

      RDockWidget* RJSHelper_qcad::js2cpp_RDockWidget_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDockWidget: not a QObject";
              return nullptr;
          }
          //RDockWidget_Wrapper* wrapper = getWrapper<RDockWidget_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RDockWidget_Wrapper* wrapper = qobject_cast<RDockWidget_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDockWidget_Wrapper* wrapper = dynamic_cast<RDockWidget_Wrapper*>(obj);
          //RDockWidget_Wrapper* wrapper = (RDockWidget_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDockWidget: no wrapper";
              return nullptr;
          }
          //return (RDockWidget*)wrapper->getWrappedVoid();
          //return getWrapped_RDockWidget(wrapper);
          return RDockWidget_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDockWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDockWidget: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RDockWidget_Type);
          //return fun.call().toInt()==RJSType::RDockWidget_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RDockWidget::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_REventFilter(RJSApi& handler, REventFilter* v) {
          REventFilter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<REventFilter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_REventFilter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new REventFilter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new REventFilter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new REventFilter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("REventFilter");
          if (cl.isUndefined()) {
              qWarning() << "Class REventFilter is undefined. Use REventFilter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new REventFilter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new REventFilter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_REventFilter(RJSApi& handler, const REventFilter* v) {
          return RJSHelper_qcad::cpp2js_REventFilter(handler, const_cast<REventFilter*>(v));
      }

      REventFilter* RJSHelper_qcad::js2cpp_REventFilter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_REventFilter: not a QObject";
              return nullptr;
          }
          //REventFilter_Wrapper* wrapper = getWrapper<REventFilter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //REventFilter_Wrapper* wrapper = qobject_cast<REventFilter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //REventFilter_Wrapper* wrapper = dynamic_cast<REventFilter_Wrapper*>(obj);
          //REventFilter_Wrapper* wrapper = (REventFilter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_REventFilter: no wrapper";
              return nullptr;
          }
          //return (REventFilter*)wrapper->getWrappedVoid();
          //return getWrapped_REventFilter(wrapper);
          return REventFilter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_REventFilter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_REventFilter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::REventFilter_Type);
          //return fun.call().toInt()==RJSType::REventFilter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_REventFilter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_REventHandler(RJSApi& handler, REventHandler* v) {
          REventHandler_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<REventHandler_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_REventHandler: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new REventHandler_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new REventHandler_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new REventHandler('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("REventHandler");
          if (cl.isUndefined()) {
              qWarning() << "Class REventHandler is undefined. Use REventHandler_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new REventHandler('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new REventHandler(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_REventHandler(RJSApi& handler, const REventHandler* v) {
          return RJSHelper_qcad::cpp2js_REventHandler(handler, const_cast<REventHandler*>(v));
      }

      REventHandler* RJSHelper_qcad::js2cpp_REventHandler_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_REventHandler: not a QObject";
              return nullptr;
          }
          //REventHandler_Wrapper* wrapper = getWrapper<REventHandler_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //REventHandler_Wrapper* wrapper = qobject_cast<REventHandler_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //REventHandler_Wrapper* wrapper = dynamic_cast<REventHandler_Wrapper*>(obj);
          //REventHandler_Wrapper* wrapper = (REventHandler_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_REventHandler: no wrapper";
              return nullptr;
          }
          //return (REventHandler*)wrapper->getWrappedVoid();
          //return getWrapped_REventHandler(wrapper);
          return REventHandler_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_REventHandler_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_REventHandler: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::REventHandler_Type);
          //return fun.call().toInt()==RJSType::REventHandler_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_REventHandler::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RFileSystemModel(RJSApi& handler, RFileSystemModel* v) {
          RFileSystemModel_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RFileSystemModel_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RFileSystemModel: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RFileSystemModel_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RFileSystemModel_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RFileSystemModel('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileSystemModel");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileSystemModel is undefined. Use RFileSystemModel_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileSystemModel('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileSystemModel(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RFileSystemModel(RJSApi& handler, const RFileSystemModel* v) {
          return RJSHelper_qcad::cpp2js_RFileSystemModel(handler, const_cast<RFileSystemModel*>(v));
      }

      RFileSystemModel* RJSHelper_qcad::js2cpp_RFileSystemModel_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFileSystemModel: not a QObject";
              return nullptr;
          }
          //RFileSystemModel_Wrapper* wrapper = getWrapper<RFileSystemModel_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RFileSystemModel_Wrapper* wrapper = qobject_cast<RFileSystemModel_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RFileSystemModel_Wrapper* wrapper = dynamic_cast<RFileSystemModel_Wrapper*>(obj);
          //RFileSystemModel_Wrapper* wrapper = (RFileSystemModel_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileSystemModel: no wrapper";
              return nullptr;
          }
          //return (RFileSystemModel*)wrapper->getWrappedVoid();
          //return getWrapped_RFileSystemModel(wrapper);
          return RFileSystemModel_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RFileSystemModel_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFileSystemModel: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RFileSystemModel_Type);
          //return fun.call().toInt()==RJSType::RFileSystemModel_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RFileSystemModel::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RFlowLayout(RJSApi& handler, RFlowLayout* v) {
          RFlowLayout_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RFlowLayout_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RFlowLayout: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RFlowLayout_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RFlowLayout_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RFlowLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFlowLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class RFlowLayout is undefined. Use RFlowLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFlowLayout('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFlowLayout(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RFlowLayout(RJSApi& handler, const RFlowLayout* v) {
          return RJSHelper_qcad::cpp2js_RFlowLayout(handler, const_cast<RFlowLayout*>(v));
      }

      RFlowLayout* RJSHelper_qcad::js2cpp_RFlowLayout_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFlowLayout: not a QObject";
              return nullptr;
          }
          //RFlowLayout_Wrapper* wrapper = getWrapper<RFlowLayout_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RFlowLayout_Wrapper* wrapper = qobject_cast<RFlowLayout_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RFlowLayout_Wrapper* wrapper = dynamic_cast<RFlowLayout_Wrapper*>(obj);
          //RFlowLayout_Wrapper* wrapper = (RFlowLayout_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFlowLayout: no wrapper";
              return nullptr;
          }
          //return (RFlowLayout*)wrapper->getWrappedVoid();
          //return getWrapped_RFlowLayout(wrapper);
          return RFlowLayout_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RFlowLayout_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFlowLayout: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RFlowLayout_Type);
          //return fun.call().toInt()==RJSType::RFlowLayout_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RFlowLayout::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RFocusListenerAdapter(RJSApi& handler, RFocusListenerAdapter* v) {
          RFocusListenerAdapter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RFocusListenerAdapter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RFocusListenerAdapter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RFocusListenerAdapter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RFocusListenerAdapter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RFocusListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFocusListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RFocusListenerAdapter is undefined. Use RFocusListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFocusListenerAdapter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFocusListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RFocusListenerAdapter(RJSApi& handler, const RFocusListenerAdapter* v) {
          return RJSHelper_qcad::cpp2js_RFocusListenerAdapter(handler, const_cast<RFocusListenerAdapter*>(v));
      }

      RFocusListenerAdapter* RJSHelper_qcad::js2cpp_RFocusListenerAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFocusListenerAdapter: not a QObject";
              return nullptr;
          }
          //RFocusListenerAdapter_Wrapper* wrapper = getWrapper<RFocusListenerAdapter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RFocusListenerAdapter_Wrapper* wrapper = qobject_cast<RFocusListenerAdapter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RFocusListenerAdapter_Wrapper* wrapper = dynamic_cast<RFocusListenerAdapter_Wrapper*>(obj);
          //RFocusListenerAdapter_Wrapper* wrapper = (RFocusListenerAdapter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFocusListenerAdapter: no wrapper";
              return nullptr;
          }
          //return (RFocusListenerAdapter*)wrapper->getWrappedVoid();
          //return getWrapped_RFocusListenerAdapter(wrapper);
          return RFocusListenerAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RFocusListenerAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFocusListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RFocusListenerAdapter_Type);
          //return fun.call().toInt()==RJSType::RFocusListenerAdapter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RFocusListenerAdapter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RFontChooserWidget(RJSApi& handler, RFontChooserWidget* v) {
          RFontChooserWidget_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RFontChooserWidget_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RFontChooserWidget: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RFontChooserWidget_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RFontChooserWidget_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RFontChooserWidget('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFontChooserWidget");
          if (cl.isUndefined()) {
              qWarning() << "Class RFontChooserWidget is undefined. Use RFontChooserWidget_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFontChooserWidget('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFontChooserWidget(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RFontChooserWidget(RJSApi& handler, const RFontChooserWidget* v) {
          return RJSHelper_qcad::cpp2js_RFontChooserWidget(handler, const_cast<RFontChooserWidget*>(v));
      }

      RFontChooserWidget* RJSHelper_qcad::js2cpp_RFontChooserWidget_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFontChooserWidget: not a QObject";
              return nullptr;
          }
          //RFontChooserWidget_Wrapper* wrapper = getWrapper<RFontChooserWidget_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RFontChooserWidget_Wrapper* wrapper = qobject_cast<RFontChooserWidget_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RFontChooserWidget_Wrapper* wrapper = dynamic_cast<RFontChooserWidget_Wrapper*>(obj);
          //RFontChooserWidget_Wrapper* wrapper = (RFontChooserWidget_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFontChooserWidget: no wrapper";
              return nullptr;
          }
          //return (RFontChooserWidget*)wrapper->getWrappedVoid();
          //return getWrapped_RFontChooserWidget(wrapper);
          return RFontChooserWidget_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RFontChooserWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFontChooserWidget: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RFontChooserWidget_Type);
          //return fun.call().toInt()==RJSType::RFontChooserWidget_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RFontChooserWidget::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RGraphicsViewQt(RJSApi& handler, RGraphicsViewQt* v) {
          RGraphicsViewQt_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RGraphicsViewQt_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RGraphicsViewQt: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RGraphicsViewQt_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RGraphicsViewQt_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RGraphicsViewQt('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RGraphicsViewQt");
          if (cl.isUndefined()) {
              qWarning() << "Class RGraphicsViewQt is undefined. Use RGraphicsViewQt_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RGraphicsViewQt('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RGraphicsViewQt(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RGraphicsViewQt(RJSApi& handler, const RGraphicsViewQt* v) {
          return RJSHelper_qcad::cpp2js_RGraphicsViewQt(handler, const_cast<RGraphicsViewQt*>(v));
      }

      RGraphicsViewQt* RJSHelper_qcad::js2cpp_RGraphicsViewQt_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RGraphicsViewQt: not a QObject";
              return nullptr;
          }
          //RGraphicsViewQt_Wrapper* wrapper = getWrapper<RGraphicsViewQt_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RGraphicsViewQt_Wrapper* wrapper = qobject_cast<RGraphicsViewQt_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RGraphicsViewQt_Wrapper* wrapper = dynamic_cast<RGraphicsViewQt_Wrapper*>(obj);
          //RGraphicsViewQt_Wrapper* wrapper = (RGraphicsViewQt_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RGraphicsViewQt: no wrapper";
              return nullptr;
          }
          //return (RGraphicsViewQt*)wrapper->getWrappedVoid();
          //return getWrapped_RGraphicsViewQt(wrapper);
          return RGraphicsViewQt_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RGraphicsViewQt_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RGraphicsViewQt: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RGraphicsViewQt_Type);
          //return fun.call().toInt()==RJSType::RGraphicsViewQt_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RGraphicsViewQt::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RGraphicsViewImage(RJSApi& handler, RGraphicsViewImage* v) {
          RGraphicsViewImage_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RGraphicsViewImage_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RGraphicsViewImage: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RGraphicsViewImage_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RGraphicsViewImage_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RGraphicsViewImage('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RGraphicsViewImage");
          if (cl.isUndefined()) {
              qWarning() << "Class RGraphicsViewImage is undefined. Use RGraphicsViewImage_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RGraphicsViewImage('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RGraphicsViewImage(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RGraphicsViewImage(RJSApi& handler, const RGraphicsViewImage* v) {
          return RJSHelper_qcad::cpp2js_RGraphicsViewImage(handler, const_cast<RGraphicsViewImage*>(v));
      }

      RGraphicsViewImage* RJSHelper_qcad::js2cpp_RGraphicsViewImage_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RGraphicsViewImage: not a QObject";
              return nullptr;
          }
          //RGraphicsViewImage_Wrapper* wrapper = getWrapper<RGraphicsViewImage_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RGraphicsViewImage_Wrapper* wrapper = qobject_cast<RGraphicsViewImage_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RGraphicsViewImage_Wrapper* wrapper = dynamic_cast<RGraphicsViewImage_Wrapper*>(obj);
          //RGraphicsViewImage_Wrapper* wrapper = (RGraphicsViewImage_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RGraphicsViewImage: no wrapper";
              return nullptr;
          }
          //return (RGraphicsViewImage*)wrapper->getWrappedVoid();
          //return getWrapped_RGraphicsViewImage(wrapper);
          return RGraphicsViewImage_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RGraphicsViewImage_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RGraphicsViewImage: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RGraphicsViewImage_Type);
          //return fun.call().toInt()==RJSType::RGraphicsViewImage_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RGraphicsViewImage::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RGuiAction(RJSApi& handler, RGuiAction* v) {
          RGuiAction_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RGuiAction_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RGuiAction: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RGuiAction_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RGuiAction_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RGuiAction('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RGuiAction");
          if (cl.isUndefined()) {
              qWarning() << "Class RGuiAction is undefined. Use RGuiAction_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RGuiAction('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RGuiAction(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RGuiAction(RJSApi& handler, const RGuiAction* v) {
          return RJSHelper_qcad::cpp2js_RGuiAction(handler, const_cast<RGuiAction*>(v));
      }

      RGuiAction* RJSHelper_qcad::js2cpp_RGuiAction_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RGuiAction: not a QObject";
              return nullptr;
          }
          //RGuiAction_Wrapper* wrapper = getWrapper<RGuiAction_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RGuiAction_Wrapper* wrapper = qobject_cast<RGuiAction_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RGuiAction_Wrapper* wrapper = dynamic_cast<RGuiAction_Wrapper*>(obj);
          //RGuiAction_Wrapper* wrapper = (RGuiAction_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RGuiAction: no wrapper";
              return nullptr;
          }
          //return (RGuiAction*)wrapper->getWrappedVoid();
          //return getWrapped_RGuiAction(wrapper);
          return RGuiAction_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RGuiAction_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RGuiAction: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RGuiAction_Type);
          //return fun.call().toInt()==RJSType::RGuiAction_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RGuiAction::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RInterTransactionListenerAdapter(RJSApi& handler, RInterTransactionListenerAdapter* v) {
          RInterTransactionListenerAdapter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RInterTransactionListenerAdapter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RInterTransactionListenerAdapter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RInterTransactionListenerAdapter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RInterTransactionListenerAdapter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RInterTransactionListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RInterTransactionListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RInterTransactionListenerAdapter is undefined. Use RInterTransactionListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RInterTransactionListenerAdapter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RInterTransactionListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RInterTransactionListenerAdapter(RJSApi& handler, const RInterTransactionListenerAdapter* v) {
          return RJSHelper_qcad::cpp2js_RInterTransactionListenerAdapter(handler, const_cast<RInterTransactionListenerAdapter*>(v));
      }

      RInterTransactionListenerAdapter* RJSHelper_qcad::js2cpp_RInterTransactionListenerAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RInterTransactionListenerAdapter: not a QObject";
              return nullptr;
          }
          //RInterTransactionListenerAdapter_Wrapper* wrapper = getWrapper<RInterTransactionListenerAdapter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RInterTransactionListenerAdapter_Wrapper* wrapper = qobject_cast<RInterTransactionListenerAdapter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RInterTransactionListenerAdapter_Wrapper* wrapper = dynamic_cast<RInterTransactionListenerAdapter_Wrapper*>(obj);
          //RInterTransactionListenerAdapter_Wrapper* wrapper = (RInterTransactionListenerAdapter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RInterTransactionListenerAdapter: no wrapper";
              return nullptr;
          }
          //return (RInterTransactionListenerAdapter*)wrapper->getWrappedVoid();
          //return getWrapped_RInterTransactionListenerAdapter(wrapper);
          return RInterTransactionListenerAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RInterTransactionListenerAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RInterTransactionListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RInterTransactionListenerAdapter_Type);
          //return fun.call().toInt()==RJSType::RInterTransactionListenerAdapter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RInterTransactionListenerAdapter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RKeyListenerAdapter(RJSApi& handler, RKeyListenerAdapter* v) {
          RKeyListenerAdapter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RKeyListenerAdapter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RKeyListenerAdapter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RKeyListenerAdapter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RKeyListenerAdapter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RKeyListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RKeyListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RKeyListenerAdapter is undefined. Use RKeyListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RKeyListenerAdapter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RKeyListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RKeyListenerAdapter(RJSApi& handler, const RKeyListenerAdapter* v) {
          return RJSHelper_qcad::cpp2js_RKeyListenerAdapter(handler, const_cast<RKeyListenerAdapter*>(v));
      }

      RKeyListenerAdapter* RJSHelper_qcad::js2cpp_RKeyListenerAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RKeyListenerAdapter: not a QObject";
              return nullptr;
          }
          //RKeyListenerAdapter_Wrapper* wrapper = getWrapper<RKeyListenerAdapter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RKeyListenerAdapter_Wrapper* wrapper = qobject_cast<RKeyListenerAdapter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RKeyListenerAdapter_Wrapper* wrapper = dynamic_cast<RKeyListenerAdapter_Wrapper*>(obj);
          //RKeyListenerAdapter_Wrapper* wrapper = (RKeyListenerAdapter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RKeyListenerAdapter: no wrapper";
              return nullptr;
          }
          //return (RKeyListenerAdapter*)wrapper->getWrappedVoid();
          //return getWrapped_RKeyListenerAdapter(wrapper);
          return RKeyListenerAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RKeyListenerAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RKeyListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RKeyListenerAdapter_Type);
          //return fun.call().toInt()==RJSType::RKeyListenerAdapter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RKeyListenerAdapter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RLayerListenerAdapter(RJSApi& handler, RLayerListenerAdapter* v) {
          RLayerListenerAdapter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RLayerListenerAdapter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RLayerListenerAdapter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RLayerListenerAdapter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RLayerListenerAdapter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RLayerListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLayerListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RLayerListenerAdapter is undefined. Use RLayerListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLayerListenerAdapter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLayerListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RLayerListenerAdapter(RJSApi& handler, const RLayerListenerAdapter* v) {
          return RJSHelper_qcad::cpp2js_RLayerListenerAdapter(handler, const_cast<RLayerListenerAdapter*>(v));
      }

      RLayerListenerAdapter* RJSHelper_qcad::js2cpp_RLayerListenerAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLayerListenerAdapter: not a QObject";
              return nullptr;
          }
          //RLayerListenerAdapter_Wrapper* wrapper = getWrapper<RLayerListenerAdapter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RLayerListenerAdapter_Wrapper* wrapper = qobject_cast<RLayerListenerAdapter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RLayerListenerAdapter_Wrapper* wrapper = dynamic_cast<RLayerListenerAdapter_Wrapper*>(obj);
          //RLayerListenerAdapter_Wrapper* wrapper = (RLayerListenerAdapter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLayerListenerAdapter: no wrapper";
              return nullptr;
          }
          //return (RLayerListenerAdapter*)wrapper->getWrappedVoid();
          //return getWrapped_RLayerListenerAdapter(wrapper);
          return RLayerListenerAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RLayerListenerAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLayerListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RLayerListenerAdapter_Type);
          //return fun.call().toInt()==RJSType::RLayerListenerAdapter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RLayerListenerAdapter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RLinetypeCombo(RJSApi& handler, RLinetypeCombo* v) {
          RLinetypeCombo_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RLinetypeCombo_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RLinetypeCombo: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RLinetypeCombo_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RLinetypeCombo_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RLinetypeCombo('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLinetypeCombo");
          if (cl.isUndefined()) {
              qWarning() << "Class RLinetypeCombo is undefined. Use RLinetypeCombo_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLinetypeCombo('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLinetypeCombo(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RLinetypeCombo(RJSApi& handler, const RLinetypeCombo* v) {
          return RJSHelper_qcad::cpp2js_RLinetypeCombo(handler, const_cast<RLinetypeCombo*>(v));
      }

      RLinetypeCombo* RJSHelper_qcad::js2cpp_RLinetypeCombo_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLinetypeCombo: not a QObject";
              return nullptr;
          }
          //RLinetypeCombo_Wrapper* wrapper = getWrapper<RLinetypeCombo_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RLinetypeCombo_Wrapper* wrapper = qobject_cast<RLinetypeCombo_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RLinetypeCombo_Wrapper* wrapper = dynamic_cast<RLinetypeCombo_Wrapper*>(obj);
          //RLinetypeCombo_Wrapper* wrapper = (RLinetypeCombo_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLinetypeCombo: no wrapper";
              return nullptr;
          }
          //return (RLinetypeCombo*)wrapper->getWrappedVoid();
          //return getWrapped_RLinetypeCombo(wrapper);
          return RLinetypeCombo_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RLinetypeCombo_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLinetypeCombo: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RLinetypeCombo_Type);
          //return fun.call().toInt()==RJSType::RLinetypeCombo_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RLinetypeCombo::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RLineweightCombo(RJSApi& handler, RLineweightCombo* v) {
          RLineweightCombo_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RLineweightCombo_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RLineweightCombo: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RLineweightCombo_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RLineweightCombo_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RLineweightCombo('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLineweightCombo");
          if (cl.isUndefined()) {
              qWarning() << "Class RLineweightCombo is undefined. Use RLineweightCombo_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLineweightCombo('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLineweightCombo(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RLineweightCombo(RJSApi& handler, const RLineweightCombo* v) {
          return RJSHelper_qcad::cpp2js_RLineweightCombo(handler, const_cast<RLineweightCombo*>(v));
      }

      RLineweightCombo* RJSHelper_qcad::js2cpp_RLineweightCombo_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLineweightCombo: not a QObject";
              return nullptr;
          }
          //RLineweightCombo_Wrapper* wrapper = getWrapper<RLineweightCombo_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RLineweightCombo_Wrapper* wrapper = qobject_cast<RLineweightCombo_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RLineweightCombo_Wrapper* wrapper = dynamic_cast<RLineweightCombo_Wrapper*>(obj);
          //RLineweightCombo_Wrapper* wrapper = (RLineweightCombo_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLineweightCombo: no wrapper";
              return nullptr;
          }
          //return (RLineweightCombo*)wrapper->getWrappedVoid();
          //return getWrapped_RLineweightCombo(wrapper);
          return RLineweightCombo_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RLineweightCombo_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLineweightCombo: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RLineweightCombo_Type);
          //return fun.call().toInt()==RJSType::RLineweightCombo_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RLineweightCombo::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RListView(RJSApi& handler, RListView* v) {
          RListView_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RListView_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RListView: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RListView_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RListView_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RListView('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RListView");
          if (cl.isUndefined()) {
              qWarning() << "Class RListView is undefined. Use RListView_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RListView('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RListView(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RListView(RJSApi& handler, const RListView* v) {
          return RJSHelper_qcad::cpp2js_RListView(handler, const_cast<RListView*>(v));
      }

      RListView* RJSHelper_qcad::js2cpp_RListView_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RListView: not a QObject";
              return nullptr;
          }
          //RListView_Wrapper* wrapper = getWrapper<RListView_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RListView_Wrapper* wrapper = qobject_cast<RListView_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RListView_Wrapper* wrapper = dynamic_cast<RListView_Wrapper*>(obj);
          //RListView_Wrapper* wrapper = (RListView_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RListView: no wrapper";
              return nullptr;
          }
          //return (RListView*)wrapper->getWrappedVoid();
          //return getWrapped_RListView(wrapper);
          return RListView_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RListView_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RListView: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RListView_Type);
          //return fun.call().toInt()==RJSType::RListView_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RListView::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RListWidget(RJSApi& handler, RListWidget* v) {
          RListWidget_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RListWidget_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RListWidget: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RListWidget_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RListWidget_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RListWidget('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RListWidget");
          if (cl.isUndefined()) {
              qWarning() << "Class RListWidget is undefined. Use RListWidget_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RListWidget('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RListWidget(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RListWidget(RJSApi& handler, const RListWidget* v) {
          return RJSHelper_qcad::cpp2js_RListWidget(handler, const_cast<RListWidget*>(v));
      }

      RListWidget* RJSHelper_qcad::js2cpp_RListWidget_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RListWidget: not a QObject";
              return nullptr;
          }
          //RListWidget_Wrapper* wrapper = getWrapper<RListWidget_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RListWidget_Wrapper* wrapper = qobject_cast<RListWidget_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RListWidget_Wrapper* wrapper = dynamic_cast<RListWidget_Wrapper*>(obj);
          //RListWidget_Wrapper* wrapper = (RListWidget_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RListWidget: no wrapper";
              return nullptr;
          }
          //return (RListWidget*)wrapper->getWrappedVoid();
          //return getWrapped_RListWidget(wrapper);
          return RListWidget_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RListWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RListWidget: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RListWidget_Type);
          //return fun.call().toInt()==RJSType::RListWidget_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RListWidget::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RMainWindowQt(RJSApi& handler, RMainWindowQt* v) {
          RMainWindowQt_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RMainWindowQt_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RMainWindowQt: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RMainWindowQt_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RMainWindowQt_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RMainWindowQt('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMainWindowQt");
          if (cl.isUndefined()) {
              qWarning() << "Class RMainWindowQt is undefined. Use RMainWindowQt_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMainWindowQt('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMainWindowQt(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RMainWindowQt(RJSApi& handler, const RMainWindowQt* v) {
          return RJSHelper_qcad::cpp2js_RMainWindowQt(handler, const_cast<RMainWindowQt*>(v));
      }

      RMainWindowQt* RJSHelper_qcad::js2cpp_RMainWindowQt_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RMainWindowQt: not a QObject";
              return nullptr;
          }
          //RMainWindowQt_Wrapper* wrapper = getWrapper<RMainWindowQt_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RMainWindowQt_Wrapper* wrapper = qobject_cast<RMainWindowQt_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RMainWindowQt_Wrapper* wrapper = dynamic_cast<RMainWindowQt_Wrapper*>(obj);
          //RMainWindowQt_Wrapper* wrapper = (RMainWindowQt_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMainWindowQt: no wrapper";
              return nullptr;
          }
          //return (RMainWindowQt*)wrapper->getWrappedVoid();
          //return getWrapped_RMainWindowQt(wrapper);
          return RMainWindowQt_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RMainWindowQt_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RMainWindowQt: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RMainWindowQt_Type);
          //return fun.call().toInt()==RJSType::RMainWindowQt_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RMainWindowQt::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RMathComboBox(RJSApi& handler, RMathComboBox* v) {
          RMathComboBox_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RMathComboBox_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RMathComboBox: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RMathComboBox_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RMathComboBox_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RMathComboBox('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMathComboBox");
          if (cl.isUndefined()) {
              qWarning() << "Class RMathComboBox is undefined. Use RMathComboBox_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMathComboBox('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMathComboBox(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RMathComboBox(RJSApi& handler, const RMathComboBox* v) {
          return RJSHelper_qcad::cpp2js_RMathComboBox(handler, const_cast<RMathComboBox*>(v));
      }

      RMathComboBox* RJSHelper_qcad::js2cpp_RMathComboBox_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RMathComboBox: not a QObject";
              return nullptr;
          }
          //RMathComboBox_Wrapper* wrapper = getWrapper<RMathComboBox_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RMathComboBox_Wrapper* wrapper = qobject_cast<RMathComboBox_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RMathComboBox_Wrapper* wrapper = dynamic_cast<RMathComboBox_Wrapper*>(obj);
          //RMathComboBox_Wrapper* wrapper = (RMathComboBox_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMathComboBox: no wrapper";
              return nullptr;
          }
          //return (RMathComboBox*)wrapper->getWrappedVoid();
          //return getWrapped_RMathComboBox(wrapper);
          return RMathComboBox_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RMathComboBox_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RMathComboBox: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RMathComboBox_Type);
          //return fun.call().toInt()==RJSType::RMathComboBox_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RMathComboBox::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RMathLineEdit(RJSApi& handler, RMathLineEdit* v) {
          RMathLineEdit_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RMathLineEdit_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RMathLineEdit: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RMathLineEdit_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RMathLineEdit_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RMathLineEdit('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMathLineEdit");
          if (cl.isUndefined()) {
              qWarning() << "Class RMathLineEdit is undefined. Use RMathLineEdit_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMathLineEdit('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMathLineEdit(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RMathLineEdit(RJSApi& handler, const RMathLineEdit* v) {
          return RJSHelper_qcad::cpp2js_RMathLineEdit(handler, const_cast<RMathLineEdit*>(v));
      }

      RMathLineEdit* RJSHelper_qcad::js2cpp_RMathLineEdit_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RMathLineEdit: not a QObject";
              return nullptr;
          }
          //RMathLineEdit_Wrapper* wrapper = getWrapper<RMathLineEdit_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RMathLineEdit_Wrapper* wrapper = qobject_cast<RMathLineEdit_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RMathLineEdit_Wrapper* wrapper = dynamic_cast<RMathLineEdit_Wrapper*>(obj);
          //RMathLineEdit_Wrapper* wrapper = (RMathLineEdit_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMathLineEdit: no wrapper";
              return nullptr;
          }
          //return (RMathLineEdit*)wrapper->getWrappedVoid();
          //return getWrapped_RMathLineEdit(wrapper);
          return RMathLineEdit_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RMathLineEdit_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RMathLineEdit: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RMathLineEdit_Type);
          //return fun.call().toInt()==RJSType::RMathLineEdit_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RMathLineEdit::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RMdiArea(RJSApi& handler, RMdiArea* v) {
          RMdiArea_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RMdiArea_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RMdiArea: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RMdiArea_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RMdiArea_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RMdiArea('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMdiArea");
          if (cl.isUndefined()) {
              qWarning() << "Class RMdiArea is undefined. Use RMdiArea_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMdiArea('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMdiArea(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RMdiArea(RJSApi& handler, const RMdiArea* v) {
          return RJSHelper_qcad::cpp2js_RMdiArea(handler, const_cast<RMdiArea*>(v));
      }

      RMdiArea* RJSHelper_qcad::js2cpp_RMdiArea_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RMdiArea: not a QObject";
              return nullptr;
          }
          //RMdiArea_Wrapper* wrapper = getWrapper<RMdiArea_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RMdiArea_Wrapper* wrapper = qobject_cast<RMdiArea_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RMdiArea_Wrapper* wrapper = dynamic_cast<RMdiArea_Wrapper*>(obj);
          //RMdiArea_Wrapper* wrapper = (RMdiArea_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMdiArea: no wrapper";
              return nullptr;
          }
          //return (RMdiArea*)wrapper->getWrappedVoid();
          //return getWrapped_RMdiArea(wrapper);
          return RMdiArea_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RMdiArea_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RMdiArea: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RMdiArea_Type);
          //return fun.call().toInt()==RJSType::RMdiArea_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RMdiArea::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RMdiChildQt(RJSApi& handler, RMdiChildQt* v) {
          RMdiChildQt_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RMdiChildQt_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RMdiChildQt: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RMdiChildQt_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RMdiChildQt_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RMdiChildQt('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMdiChildQt");
          if (cl.isUndefined()) {
              qWarning() << "Class RMdiChildQt is undefined. Use RMdiChildQt_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMdiChildQt('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMdiChildQt(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RMdiChildQt(RJSApi& handler, const RMdiChildQt* v) {
          return RJSHelper_qcad::cpp2js_RMdiChildQt(handler, const_cast<RMdiChildQt*>(v));
      }

      RMdiChildQt* RJSHelper_qcad::js2cpp_RMdiChildQt_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RMdiChildQt: not a QObject";
              return nullptr;
          }
          //RMdiChildQt_Wrapper* wrapper = getWrapper<RMdiChildQt_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RMdiChildQt_Wrapper* wrapper = qobject_cast<RMdiChildQt_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RMdiChildQt_Wrapper* wrapper = dynamic_cast<RMdiChildQt_Wrapper*>(obj);
          //RMdiChildQt_Wrapper* wrapper = (RMdiChildQt_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMdiChildQt: no wrapper";
              return nullptr;
          }
          //return (RMdiChildQt*)wrapper->getWrappedVoid();
          //return getWrapped_RMdiChildQt(wrapper);
          return RMdiChildQt_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RMdiChildQt_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RMdiChildQt: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RMdiChildQt_Type);
          //return fun.call().toInt()==RJSType::RMdiChildQt_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RMdiChildQt::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RPaletteListenerAdapter(RJSApi& handler, RPaletteListenerAdapter* v) {
          RPaletteListenerAdapter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RPaletteListenerAdapter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RPaletteListenerAdapter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RPaletteListenerAdapter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RPaletteListenerAdapter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RPaletteListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPaletteListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RPaletteListenerAdapter is undefined. Use RPaletteListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPaletteListenerAdapter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPaletteListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPaletteListenerAdapter(RJSApi& handler, const RPaletteListenerAdapter* v) {
          return RJSHelper_qcad::cpp2js_RPaletteListenerAdapter(handler, const_cast<RPaletteListenerAdapter*>(v));
      }

      RPaletteListenerAdapter* RJSHelper_qcad::js2cpp_RPaletteListenerAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPaletteListenerAdapter: not a QObject";
              return nullptr;
          }
          //RPaletteListenerAdapter_Wrapper* wrapper = getWrapper<RPaletteListenerAdapter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RPaletteListenerAdapter_Wrapper* wrapper = qobject_cast<RPaletteListenerAdapter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPaletteListenerAdapter_Wrapper* wrapper = dynamic_cast<RPaletteListenerAdapter_Wrapper*>(obj);
          //RPaletteListenerAdapter_Wrapper* wrapper = (RPaletteListenerAdapter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPaletteListenerAdapter: no wrapper";
              return nullptr;
          }
          //return (RPaletteListenerAdapter*)wrapper->getWrappedVoid();
          //return getWrapped_RPaletteListenerAdapter(wrapper);
          return RPaletteListenerAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPaletteListenerAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPaletteListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RPaletteListenerAdapter_Type);
          //return fun.call().toInt()==RJSType::RPaletteListenerAdapter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RPaletteListenerAdapter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RPenListenerAdapter(RJSApi& handler, RPenListenerAdapter* v) {
          RPenListenerAdapter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RPenListenerAdapter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RPenListenerAdapter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RPenListenerAdapter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RPenListenerAdapter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RPenListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPenListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RPenListenerAdapter is undefined. Use RPenListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPenListenerAdapter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPenListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPenListenerAdapter(RJSApi& handler, const RPenListenerAdapter* v) {
          return RJSHelper_qcad::cpp2js_RPenListenerAdapter(handler, const_cast<RPenListenerAdapter*>(v));
      }

      RPenListenerAdapter* RJSHelper_qcad::js2cpp_RPenListenerAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPenListenerAdapter: not a QObject";
              return nullptr;
          }
          //RPenListenerAdapter_Wrapper* wrapper = getWrapper<RPenListenerAdapter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RPenListenerAdapter_Wrapper* wrapper = qobject_cast<RPenListenerAdapter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPenListenerAdapter_Wrapper* wrapper = dynamic_cast<RPenListenerAdapter_Wrapper*>(obj);
          //RPenListenerAdapter_Wrapper* wrapper = (RPenListenerAdapter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPenListenerAdapter: no wrapper";
              return nullptr;
          }
          //return (RPenListenerAdapter*)wrapper->getWrappedVoid();
          //return getWrapped_RPenListenerAdapter(wrapper);
          return RPenListenerAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPenListenerAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPenListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RPenListenerAdapter_Type);
          //return fun.call().toInt()==RJSType::RPenListenerAdapter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RPenListenerAdapter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RPreferencesListenerAdapter(RJSApi& handler, RPreferencesListenerAdapter* v) {
          RPreferencesListenerAdapter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RPreferencesListenerAdapter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RPreferencesListenerAdapter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RPreferencesListenerAdapter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RPreferencesListenerAdapter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RPreferencesListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPreferencesListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RPreferencesListenerAdapter is undefined. Use RPreferencesListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPreferencesListenerAdapter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPreferencesListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPreferencesListenerAdapter(RJSApi& handler, const RPreferencesListenerAdapter* v) {
          return RJSHelper_qcad::cpp2js_RPreferencesListenerAdapter(handler, const_cast<RPreferencesListenerAdapter*>(v));
      }

      RPreferencesListenerAdapter* RJSHelper_qcad::js2cpp_RPreferencesListenerAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPreferencesListenerAdapter: not a QObject";
              return nullptr;
          }
          //RPreferencesListenerAdapter_Wrapper* wrapper = getWrapper<RPreferencesListenerAdapter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RPreferencesListenerAdapter_Wrapper* wrapper = qobject_cast<RPreferencesListenerAdapter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPreferencesListenerAdapter_Wrapper* wrapper = dynamic_cast<RPreferencesListenerAdapter_Wrapper*>(obj);
          //RPreferencesListenerAdapter_Wrapper* wrapper = (RPreferencesListenerAdapter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPreferencesListenerAdapter: no wrapper";
              return nullptr;
          }
          //return (RPreferencesListenerAdapter*)wrapper->getWrappedVoid();
          //return getWrapped_RPreferencesListenerAdapter(wrapper);
          return RPreferencesListenerAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPreferencesListenerAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPreferencesListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RPreferencesListenerAdapter_Type);
          //return fun.call().toInt()==RJSType::RPreferencesListenerAdapter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RPreferencesListenerAdapter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RPropertyListenerAdapter(RJSApi& handler, RPropertyListenerAdapter* v) {
          RPropertyListenerAdapter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RPropertyListenerAdapter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RPropertyListenerAdapter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RPropertyListenerAdapter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RPropertyListenerAdapter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RPropertyListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPropertyListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RPropertyListenerAdapter is undefined. Use RPropertyListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPropertyListenerAdapter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPropertyListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPropertyListenerAdapter(RJSApi& handler, const RPropertyListenerAdapter* v) {
          return RJSHelper_qcad::cpp2js_RPropertyListenerAdapter(handler, const_cast<RPropertyListenerAdapter*>(v));
      }

      RPropertyListenerAdapter* RJSHelper_qcad::js2cpp_RPropertyListenerAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPropertyListenerAdapter: not a QObject";
              return nullptr;
          }
          //RPropertyListenerAdapter_Wrapper* wrapper = getWrapper<RPropertyListenerAdapter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RPropertyListenerAdapter_Wrapper* wrapper = qobject_cast<RPropertyListenerAdapter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPropertyListenerAdapter_Wrapper* wrapper = dynamic_cast<RPropertyListenerAdapter_Wrapper*>(obj);
          //RPropertyListenerAdapter_Wrapper* wrapper = (RPropertyListenerAdapter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPropertyListenerAdapter: no wrapper";
              return nullptr;
          }
          //return (RPropertyListenerAdapter*)wrapper->getWrappedVoid();
          //return getWrapped_RPropertyListenerAdapter(wrapper);
          return RPropertyListenerAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPropertyListenerAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPropertyListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RPropertyListenerAdapter_Type);
          //return fun.call().toInt()==RJSType::RPropertyListenerAdapter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RPropertyListenerAdapter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RRulerQt(RJSApi& handler, RRulerQt* v) {
          RRulerQt_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RRulerQt_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RRulerQt: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RRulerQt_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RRulerQt_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RRulerQt('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRulerQt");
          if (cl.isUndefined()) {
              qWarning() << "Class RRulerQt is undefined. Use RRulerQt_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RRulerQt('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RRulerQt(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RRulerQt(RJSApi& handler, const RRulerQt* v) {
          return RJSHelper_qcad::cpp2js_RRulerQt(handler, const_cast<RRulerQt*>(v));
      }

      RRulerQt* RJSHelper_qcad::js2cpp_RRulerQt_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RRulerQt: not a QObject";
              return nullptr;
          }
          //RRulerQt_Wrapper* wrapper = getWrapper<RRulerQt_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RRulerQt_Wrapper* wrapper = qobject_cast<RRulerQt_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RRulerQt_Wrapper* wrapper = dynamic_cast<RRulerQt_Wrapper*>(obj);
          //RRulerQt_Wrapper* wrapper = (RRulerQt_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RRulerQt: no wrapper";
              return nullptr;
          }
          //return (RRulerQt*)wrapper->getWrappedVoid();
          //return getWrapped_RRulerQt(wrapper);
          return RRulerQt_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RRulerQt_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RRulerQt: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RRulerQt_Type);
          //return fun.call().toInt()==RJSType::RRulerQt_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RRulerQt::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RSelectionListenerAdapter(RJSApi& handler, RSelectionListenerAdapter* v) {
          RSelectionListenerAdapter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RSelectionListenerAdapter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RSelectionListenerAdapter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RSelectionListenerAdapter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RSelectionListenerAdapter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RSelectionListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSelectionListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RSelectionListenerAdapter is undefined. Use RSelectionListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSelectionListenerAdapter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSelectionListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RSelectionListenerAdapter(RJSApi& handler, const RSelectionListenerAdapter* v) {
          return RJSHelper_qcad::cpp2js_RSelectionListenerAdapter(handler, const_cast<RSelectionListenerAdapter*>(v));
      }

      RSelectionListenerAdapter* RJSHelper_qcad::js2cpp_RSelectionListenerAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSelectionListenerAdapter: not a QObject";
              return nullptr;
          }
          //RSelectionListenerAdapter_Wrapper* wrapper = getWrapper<RSelectionListenerAdapter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RSelectionListenerAdapter_Wrapper* wrapper = qobject_cast<RSelectionListenerAdapter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSelectionListenerAdapter_Wrapper* wrapper = dynamic_cast<RSelectionListenerAdapter_Wrapper*>(obj);
          //RSelectionListenerAdapter_Wrapper* wrapper = (RSelectionListenerAdapter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSelectionListenerAdapter: no wrapper";
              return nullptr;
          }
          //return (RSelectionListenerAdapter*)wrapper->getWrappedVoid();
          //return getWrapped_RSelectionListenerAdapter(wrapper);
          return RSelectionListenerAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSelectionListenerAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSelectionListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RSelectionListenerAdapter_Type);
          //return fun.call().toInt()==RJSType::RSelectionListenerAdapter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RSelectionListenerAdapter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RSingleApplication(RJSApi& handler, RSingleApplication* v) {
          RSingleApplication_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RSingleApplication_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RSingleApplication: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RSingleApplication_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RSingleApplication_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RSingleApplication('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSingleApplication");
          if (cl.isUndefined()) {
              qWarning() << "Class RSingleApplication is undefined. Use RSingleApplication_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSingleApplication('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSingleApplication(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RSingleApplication(RJSApi& handler, const RSingleApplication* v) {
          return RJSHelper_qcad::cpp2js_RSingleApplication(handler, const_cast<RSingleApplication*>(v));
      }

      RSingleApplication* RJSHelper_qcad::js2cpp_RSingleApplication_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSingleApplication: not a QObject";
              return nullptr;
          }
          //RSingleApplication_Wrapper* wrapper = getWrapper<RSingleApplication_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RSingleApplication_Wrapper* wrapper = qobject_cast<RSingleApplication_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSingleApplication_Wrapper* wrapper = dynamic_cast<RSingleApplication_Wrapper*>(obj);
          //RSingleApplication_Wrapper* wrapper = (RSingleApplication_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSingleApplication: no wrapper";
              return nullptr;
          }
          //return (RSingleApplication*)wrapper->getWrappedVoid();
          //return getWrapped_RSingleApplication(wrapper);
          return RSingleApplication_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSingleApplication_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSingleApplication: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RSingleApplication_Type);
          //return fun.call().toInt()==RJSType::RSingleApplication_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RSingleApplication::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RTextEdit(RJSApi& handler, RTextEdit* v) {
          RTextEdit_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RTextEdit_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RTextEdit: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RTextEdit_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RTextEdit_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RTextEdit('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTextEdit");
          if (cl.isUndefined()) {
              qWarning() << "Class RTextEdit is undefined. Use RTextEdit_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTextEdit('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTextEdit(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RTextEdit(RJSApi& handler, const RTextEdit* v) {
          return RJSHelper_qcad::cpp2js_RTextEdit(handler, const_cast<RTextEdit*>(v));
      }

      RTextEdit* RJSHelper_qcad::js2cpp_RTextEdit_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTextEdit: not a QObject";
              return nullptr;
          }
          //RTextEdit_Wrapper* wrapper = getWrapper<RTextEdit_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RTextEdit_Wrapper* wrapper = qobject_cast<RTextEdit_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RTextEdit_Wrapper* wrapper = dynamic_cast<RTextEdit_Wrapper*>(obj);
          //RTextEdit_Wrapper* wrapper = (RTextEdit_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTextEdit: no wrapper";
              return nullptr;
          }
          //return (RTextEdit*)wrapper->getWrappedVoid();
          //return getWrapped_RTextEdit(wrapper);
          return RTextEdit_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RTextEdit_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTextEdit: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RTextEdit_Type);
          //return fun.call().toInt()==RJSType::RTextEdit_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RTextEdit::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RToolButton(RJSApi& handler, RToolButton* v) {
          RToolButton_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RToolButton_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RToolButton: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RToolButton_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RToolButton_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RToolButton('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RToolButton");
          if (cl.isUndefined()) {
              qWarning() << "Class RToolButton is undefined. Use RToolButton_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RToolButton('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RToolButton(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RToolButton(RJSApi& handler, const RToolButton* v) {
          return RJSHelper_qcad::cpp2js_RToolButton(handler, const_cast<RToolButton*>(v));
      }

      RToolButton* RJSHelper_qcad::js2cpp_RToolButton_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RToolButton: not a QObject";
              return nullptr;
          }
          //RToolButton_Wrapper* wrapper = getWrapper<RToolButton_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RToolButton_Wrapper* wrapper = qobject_cast<RToolButton_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RToolButton_Wrapper* wrapper = dynamic_cast<RToolButton_Wrapper*>(obj);
          //RToolButton_Wrapper* wrapper = (RToolButton_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RToolButton: no wrapper";
              return nullptr;
          }
          //return (RToolButton*)wrapper->getWrappedVoid();
          //return getWrapped_RToolButton(wrapper);
          return RToolButton_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RToolButton_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RToolButton: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RToolButton_Type);
          //return fun.call().toInt()==RJSType::RToolButton_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RToolButton::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RToolMatrixItemDelegate(RJSApi& handler, RToolMatrixItemDelegate* v) {
          RToolMatrixItemDelegate_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RToolMatrixItemDelegate_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RToolMatrixItemDelegate: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RToolMatrixItemDelegate_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RToolMatrixItemDelegate_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RToolMatrixItemDelegate('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RToolMatrixItemDelegate");
          if (cl.isUndefined()) {
              qWarning() << "Class RToolMatrixItemDelegate is undefined. Use RToolMatrixItemDelegate_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RToolMatrixItemDelegate('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RToolMatrixItemDelegate(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RToolMatrixItemDelegate(RJSApi& handler, const RToolMatrixItemDelegate* v) {
          return RJSHelper_qcad::cpp2js_RToolMatrixItemDelegate(handler, const_cast<RToolMatrixItemDelegate*>(v));
      }

      RToolMatrixItemDelegate* RJSHelper_qcad::js2cpp_RToolMatrixItemDelegate_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RToolMatrixItemDelegate: not a QObject";
              return nullptr;
          }
          //RToolMatrixItemDelegate_Wrapper* wrapper = getWrapper<RToolMatrixItemDelegate_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RToolMatrixItemDelegate_Wrapper* wrapper = qobject_cast<RToolMatrixItemDelegate_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RToolMatrixItemDelegate_Wrapper* wrapper = dynamic_cast<RToolMatrixItemDelegate_Wrapper*>(obj);
          //RToolMatrixItemDelegate_Wrapper* wrapper = (RToolMatrixItemDelegate_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RToolMatrixItemDelegate: no wrapper";
              return nullptr;
          }
          //return (RToolMatrixItemDelegate*)wrapper->getWrappedVoid();
          //return getWrapped_RToolMatrixItemDelegate(wrapper);
          return RToolMatrixItemDelegate_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RToolMatrixItemDelegate_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RToolMatrixItemDelegate: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RToolMatrixItemDelegate_Type);
          //return fun.call().toInt()==RJSType::RToolMatrixItemDelegate_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RToolMatrixItemDelegate::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RTransactionListenerAdapter(RJSApi& handler, RTransactionListenerAdapter* v) {
          RTransactionListenerAdapter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RTransactionListenerAdapter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RTransactionListenerAdapter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RTransactionListenerAdapter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RTransactionListenerAdapter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RTransactionListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTransactionListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RTransactionListenerAdapter is undefined. Use RTransactionListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTransactionListenerAdapter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTransactionListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RTransactionListenerAdapter(RJSApi& handler, const RTransactionListenerAdapter* v) {
          return RJSHelper_qcad::cpp2js_RTransactionListenerAdapter(handler, const_cast<RTransactionListenerAdapter*>(v));
      }

      RTransactionListenerAdapter* RJSHelper_qcad::js2cpp_RTransactionListenerAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTransactionListenerAdapter: not a QObject";
              return nullptr;
          }
          //RTransactionListenerAdapter_Wrapper* wrapper = getWrapper<RTransactionListenerAdapter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RTransactionListenerAdapter_Wrapper* wrapper = qobject_cast<RTransactionListenerAdapter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RTransactionListenerAdapter_Wrapper* wrapper = dynamic_cast<RTransactionListenerAdapter_Wrapper*>(obj);
          //RTransactionListenerAdapter_Wrapper* wrapper = (RTransactionListenerAdapter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTransactionListenerAdapter: no wrapper";
              return nullptr;
          }
          //return (RTransactionListenerAdapter*)wrapper->getWrappedVoid();
          //return getWrapped_RTransactionListenerAdapter(wrapper);
          return RTransactionListenerAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RTransactionListenerAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTransactionListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RTransactionListenerAdapter_Type);
          //return fun.call().toInt()==RJSType::RTransactionListenerAdapter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RTransactionListenerAdapter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RTreeWidget(RJSApi& handler, RTreeWidget* v) {
          RTreeWidget_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RTreeWidget_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RTreeWidget: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RTreeWidget_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RTreeWidget_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RTreeWidget('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTreeWidget");
          if (cl.isUndefined()) {
              qWarning() << "Class RTreeWidget is undefined. Use RTreeWidget_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTreeWidget('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTreeWidget(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RTreeWidget(RJSApi& handler, const RTreeWidget* v) {
          return RJSHelper_qcad::cpp2js_RTreeWidget(handler, const_cast<RTreeWidget*>(v));
      }

      RTreeWidget* RJSHelper_qcad::js2cpp_RTreeWidget_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTreeWidget: not a QObject";
              return nullptr;
          }
          //RTreeWidget_Wrapper* wrapper = getWrapper<RTreeWidget_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RTreeWidget_Wrapper* wrapper = qobject_cast<RTreeWidget_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RTreeWidget_Wrapper* wrapper = dynamic_cast<RTreeWidget_Wrapper*>(obj);
          //RTreeWidget_Wrapper* wrapper = (RTreeWidget_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTreeWidget: no wrapper";
              return nullptr;
          }
          //return (RTreeWidget*)wrapper->getWrappedVoid();
          //return getWrapped_RTreeWidget(wrapper);
          return RTreeWidget_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RTreeWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTreeWidget: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RTreeWidget_Type);
          //return fun.call().toInt()==RJSType::RTreeWidget_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RTreeWidget::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RViewListenerAdapter(RJSApi& handler, RViewListenerAdapter* v) {
          RViewListenerAdapter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RViewListenerAdapter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RViewListenerAdapter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RViewListenerAdapter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RViewListenerAdapter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RViewListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RViewListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RViewListenerAdapter is undefined. Use RViewListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RViewListenerAdapter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RViewListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RViewListenerAdapter(RJSApi& handler, const RViewListenerAdapter* v) {
          return RJSHelper_qcad::cpp2js_RViewListenerAdapter(handler, const_cast<RViewListenerAdapter*>(v));
      }

      RViewListenerAdapter* RJSHelper_qcad::js2cpp_RViewListenerAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RViewListenerAdapter: not a QObject";
              return nullptr;
          }
          //RViewListenerAdapter_Wrapper* wrapper = getWrapper<RViewListenerAdapter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RViewListenerAdapter_Wrapper* wrapper = qobject_cast<RViewListenerAdapter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RViewListenerAdapter_Wrapper* wrapper = dynamic_cast<RViewListenerAdapter_Wrapper*>(obj);
          //RViewListenerAdapter_Wrapper* wrapper = (RViewListenerAdapter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RViewListenerAdapter: no wrapper";
              return nullptr;
          }
          //return (RViewListenerAdapter*)wrapper->getWrappedVoid();
          //return getWrapped_RViewListenerAdapter(wrapper);
          return RViewListenerAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RViewListenerAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RViewListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RViewListenerAdapter_Type);
          //return fun.call().toInt()==RJSType::RViewListenerAdapter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RViewListenerAdapter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RWidget(RJSApi& handler, RWidget* v) {
          
            // downcast to RCadToolBarPanel:
            {
                RCadToolBarPanel* o = qobject_cast<RCadToolBarPanel*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RCadToolBarPanel(handler, o);
                }
            }
          RWidget_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RWidget_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RWidget: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RWidget_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RWidget_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RWidget('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RWidget");
          if (cl.isUndefined()) {
              qWarning() << "Class RWidget is undefined. Use RWidget_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RWidget('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RWidget(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RWidget(RJSApi& handler, const RWidget* v) {
          return RJSHelper_qcad::cpp2js_RWidget(handler, const_cast<RWidget*>(v));
      }

      RWidget* RJSHelper_qcad::js2cpp_RWidget_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RWidget: not a QObject";
              return nullptr;
          }
          //RWidget_Wrapper* wrapper = getWrapper<RWidget_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RWidget_Wrapper* wrapper = qobject_cast<RWidget_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RWidget_Wrapper* wrapper = dynamic_cast<RWidget_Wrapper*>(obj);
          //RWidget_Wrapper* wrapper = (RWidget_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RWidget: no wrapper";
              return nullptr;
          }
          //return (RWidget*)wrapper->getWrappedVoid();
          //return getWrapped_RWidget(wrapper);
          return RWidget_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RWidget: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RWidget_Type);
          //return fun.call().toInt()==RJSType::RWidget_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RWidget::getIdStatic())).toBool();
      }

    
  // ------------
  // QList types:
  // ------------
  
      QJSValue RJSHelper_qcad::cpp2js_QList_RArc(RJSApi& handler, const QList<RArc>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RArc(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RArc> RJSHelper_qcad::js2cpp_QList_RArc(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RArc>>(v);
          QList<RArc> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RArc: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RArc(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RArc(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RBlock_Id(RJSApi& handler, const QList<RBlock::Id>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RBlock_Id(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RBlock::Id> RJSHelper_qcad::js2cpp_QList_RBlock_Id(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RBlock::Id>>(v);
          QList<RBlock::Id> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RBlock_Id: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RBlock_Id(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RBlock_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RBox(RJSApi& handler, const QList<RBox>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RBox(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RBox> RJSHelper_qcad::js2cpp_QList_RBox(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RBox>>(v);
          QList<RBox> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RBox: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RBox(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RBox(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RColor(RJSApi& handler, const QList<RColor>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RColor(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RColor> RJSHelper_qcad::js2cpp_QList_RColor(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RColor>>(v);
          QList<RColor> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RColor: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RColor(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RColor(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_REntity_Id(RJSApi& handler, const QList<REntity::Id>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_REntity_Id(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<REntity::Id> RJSHelper_qcad::js2cpp_QList_REntity_Id(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<REntity::Id>>(v);
          QList<REntity::Id> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_REntity_Id: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_REntity_Id(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_REntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RGraphicsSceneDrawable(RJSApi& handler, const QList<RGraphicsSceneDrawable>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RGraphicsSceneDrawable(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RGraphicsSceneDrawable> RJSHelper_qcad::js2cpp_QList_RGraphicsSceneDrawable(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RGraphicsSceneDrawable>>(v);
          QList<RGraphicsSceneDrawable> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RGraphicsSceneDrawable: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RGraphicsSceneDrawable(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RGraphicsSceneDrawable(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RLayer_Id(RJSApi& handler, const QList<RLayer::Id>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RLayer_Id(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RLayer::Id> RJSHelper_qcad::js2cpp_QList_RLayer_Id(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RLayer::Id>>(v);
          QList<RLayer::Id> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RLayer_Id: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RLayer_Id(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RLayer_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RLine(RJSApi& handler, const QList<RLine>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RLine(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RLine> RJSHelper_qcad::js2cpp_QList_RLine(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RLine>>(v);
          QList<RLine> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RLine: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RLine(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RLine(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RLinetypePattern(RJSApi& handler, const QList<RLinetypePattern>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RLinetypePattern(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RLinetypePattern> RJSHelper_qcad::js2cpp_QList_RLinetypePattern(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RLinetypePattern>>(v);
          QList<RLinetypePattern> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RLinetypePattern: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RLinetypePattern(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RLinetypePattern(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RObject_Id(RJSApi& handler, const QList<RObject::Id>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RObject_Id(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RObject::Id> RJSHelper_qcad::js2cpp_QList_RObject_Id(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RObject::Id>>(v);
          QList<RObject::Id> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RObject_Id: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RObject_Id(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RObject_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RPainterPath(RJSApi& handler, const QList<RPainterPath>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RPainterPath(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RPainterPath> RJSHelper_qcad::js2cpp_QList_RPainterPath(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RPainterPath>>(v);
          QList<RPainterPath> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RPainterPath: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RPainterPath(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RPainterPath(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RPatternLine(RJSApi& handler, const QList<RPatternLine>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RPatternLine(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RPatternLine> RJSHelper_qcad::js2cpp_QList_RPatternLine(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RPatternLine>>(v);
          QList<RPatternLine> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RPatternLine: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RPatternLine(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RPatternLine(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RPolyline(RJSApi& handler, const QList<RPolyline>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RPolyline(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RPolyline> RJSHelper_qcad::js2cpp_QList_RPolyline(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RPolyline>>(v);
          QList<RPolyline> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RPolyline: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RPolyline(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RPolyline(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RPropertyChange(RJSApi& handler, const QList<RPropertyChange>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RPropertyChange(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RPropertyChange> RJSHelper_qcad::js2cpp_QList_RPropertyChange(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RPropertyChange>>(v);
          QList<RPropertyChange> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RPropertyChange: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RPropertyChange(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RPropertyChange(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RPropertyTypeId(RJSApi& handler, const QList<RPropertyTypeId>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RPropertyTypeId(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RPropertyTypeId> RJSHelper_qcad::js2cpp_QList_RPropertyTypeId(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RPropertyTypeId>>(v);
          QList<RPropertyTypeId> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RPropertyTypeId: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RPropertyTypeId(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RPropertyTypeId(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RRefPoint(RJSApi& handler, const QList<RRefPoint>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RRefPoint(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RRefPoint> RJSHelper_qcad::js2cpp_QList_RRefPoint(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RRefPoint>>(v);
          QList<RRefPoint> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RRefPoint: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RRefPoint(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RRefPoint(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RS_EntityType(RJSApi& handler, const QList<RS::EntityType>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RS_EntityType(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RS::EntityType> RJSHelper_qcad::js2cpp_QList_RS_EntityType(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RS::EntityType>>(v);
          QList<RS::EntityType> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RS_EntityType: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RS_EntityType(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RS_EntityType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RSpline(RJSApi& handler, const QList<RSpline>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RSpline(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RSpline> RJSHelper_qcad::js2cpp_QList_RSpline(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RSpline>>(v);
          QList<RSpline> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RSpline: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RSpline(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RSpline(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RTextBasedData(RJSApi& handler, const QList<RTextBasedData>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RTextBasedData(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RTextBasedData> RJSHelper_qcad::js2cpp_QList_RTextBasedData(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RTextBasedData>>(v);
          QList<RTextBasedData> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RTextBasedData: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RTextBasedData(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RTextBasedData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RTextData(RJSApi& handler, const QList<RTextData>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RTextData(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RTextData> RJSHelper_qcad::js2cpp_QList_RTextData(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RTextData>>(v);
          QList<RTextData> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RTextData: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RTextData(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RTextData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RTextLabel(RJSApi& handler, const QList<RTextLabel>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RTextLabel(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RTextLabel> RJSHelper_qcad::js2cpp_QList_RTextLabel(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RTextLabel>>(v);
          QList<RTextLabel> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RTextLabel: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RTextLabel(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RTextLabel(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RTextLayout(RJSApi& handler, const QList<RTextLayout>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RTextLayout(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RTextLayout> RJSHelper_qcad::js2cpp_QList_RTextLayout(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RTextLayout>>(v);
          QList<RTextLayout> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RTextLayout: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RTextLayout(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RTextLayout(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RTransaction(RJSApi& handler, const QList<RTransaction>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RTransaction(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RTransaction> RJSHelper_qcad::js2cpp_QList_RTransaction(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RTransaction>>(v);
          QList<RTransaction> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RTransaction: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RTransaction(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RTransaction(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RTransformOp(RJSApi& handler, const QList<RTransformOp>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RTransformOp(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RTransformOp> RJSHelper_qcad::js2cpp_QList_RTransformOp(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RTransformOp>>(v);
          QList<RTransformOp> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RTransformOp: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RTransformOp(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RTransformOp(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RTriangle(RJSApi& handler, const QList<RTriangle>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RTriangle(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RTriangle> RJSHelper_qcad::js2cpp_QList_RTriangle(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RTriangle>>(v);
          QList<RTriangle> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RTriangle: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RTriangle(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RTriangle(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RVector(RJSApi& handler, const QList<RVector>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RVector(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RVector> RJSHelper_qcad::js2cpp_QList_RVector(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RVector>>(v);
          QList<RVector> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RVector: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RVector(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RVector(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
  // --------------------
  // QList pointer types:
  // --------------------
  
      QJSValue RJSHelper_qcad::cpp2js_QList_RGraphicsScene_ptr(RJSApi& handler, const QList<RGraphicsScene*>& v) {
          QJSValue ret = handler.getEngine()->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RGraphicsScene(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RGraphicsScene*> RJSHelper_qcad::js2cpp_QList_RGraphicsScene_ptr(RJSApi& handler, const QJSValue& v) {
          // TODO:
          qWarning() << "js2cpp_QList_RGraphicsScene: TODO: not properly implemented";
          return handler.getEngine()->fromScriptValue<QList<RGraphicsScene*>>(v);
      }

      bool RJSHelper_qcad::is_QList_RGraphicsScene_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RGraphicsView_ptr(RJSApi& handler, const QList<RGraphicsView*>& v) {
          QJSValue ret = handler.getEngine()->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RGraphicsView(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RGraphicsView*> RJSHelper_qcad::js2cpp_QList_RGraphicsView_ptr(RJSApi& handler, const QJSValue& v) {
          // TODO:
          qWarning() << "js2cpp_QList_RGraphicsView: TODO: not properly implemented";
          return handler.getEngine()->fromScriptValue<QList<RGraphicsView*>>(v);
      }

      bool RJSHelper_qcad::is_QList_RGraphicsView_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RGuiAction_ptr(RJSApi& handler, const QList<RGuiAction*>& v) {
          QJSValue ret = handler.getEngine()->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RGuiAction(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RGuiAction*> RJSHelper_qcad::js2cpp_QList_RGuiAction_ptr(RJSApi& handler, const QJSValue& v) {
          // TODO:
          qWarning() << "js2cpp_QList_RGuiAction: TODO: not properly implemented";
          return handler.getEngine()->fromScriptValue<QList<RGuiAction*>>(v);
      }

      bool RJSHelper_qcad::is_QList_RGuiAction_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RTransaction_ptr(RJSApi& handler, const QList<RTransaction*>& v) {
          QJSValue ret = handler.getEngine()->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RTransaction(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RTransaction*> RJSHelper_qcad::js2cpp_QList_RTransaction_ptr(RJSApi& handler, const QJSValue& v) {
          // TODO:
          qWarning() << "js2cpp_QList_RTransaction: TODO: not properly implemented";
          return handler.getEngine()->fromScriptValue<QList<RTransaction*>>(v);
      }

      bool RJSHelper_qcad::is_QList_RTransaction_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
  // ---------------------------
  // QList shared pointer types:
  // ---------------------------
  
      QJSValue RJSHelper_qcad::cpp2js_QList_QSharedPointer_RLayer(RJSApi& handler, const QList<QSharedPointer<RLayer>>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              if (v.at(i).isNull()) {
                ret.setProperty((quint32)i, RJSHelper_qcad::cpp2js_RLayer(handler, nullptr));
              }
              else {
                //ret.setProperty((quint32)i, RJSHelper_qcad::cpp2js_RLayer(handler, v.at(i)->clone()));
                ret.setProperty((quint32)i, RJSHelper_qcad::cpp2js_QSharedPointer_RLayer(handler, v.at(i)));
              }
          }
          return ret;
      }

      QList<QSharedPointer<RLayer>> RJSHelper_qcad::js2cpp_QList_QSharedPointer_RLayer(RJSApi& handler, const QJSValue& v) {
          // TODO:
          qWarning() << "js2cpp_QList_QSharedPointer_RLayer: TODO: not properly implemented";
          QJSEngine* engine = handler.getEngine();
          return engine->fromScriptValue<QList<QSharedPointer<RLayer>>>(v);
      }

      bool RJSHelper_qcad::is_QList_QSharedPointer_RLayer(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_QSharedPointer_RObject(RJSApi& handler, const QList<QSharedPointer<RObject>>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              if (v.at(i).isNull()) {
                ret.setProperty((quint32)i, RJSHelper_qcad::cpp2js_RObject(handler, nullptr));
              }
              else {
                //ret.setProperty((quint32)i, RJSHelper_qcad::cpp2js_RObject(handler, v.at(i)->clone()));
                ret.setProperty((quint32)i, RJSHelper_qcad::cpp2js_QSharedPointer_RObject(handler, v.at(i)));
              }
          }
          return ret;
      }

      QList<QSharedPointer<RObject>> RJSHelper_qcad::js2cpp_QList_QSharedPointer_RObject(RJSApi& handler, const QJSValue& v) {
          // TODO:
          qWarning() << "js2cpp_QList_QSharedPointer_RObject: TODO: not properly implemented";
          QJSEngine* engine = handler.getEngine();
          return engine->fromScriptValue<QList<QSharedPointer<RObject>>>(v);
      }

      bool RJSHelper_qcad::is_QList_QSharedPointer_RObject(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_QSharedPointer_RShape(RJSApi& handler, const QList<QSharedPointer<RShape>>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              if (v.at(i).isNull()) {
                ret.setProperty((quint32)i, RJSHelper_qcad::cpp2js_RShape(handler, nullptr));
              }
              else {
                //ret.setProperty((quint32)i, RJSHelper_qcad::cpp2js_RShape(handler, v.at(i)->clone()));
                ret.setProperty((quint32)i, RJSHelper_qcad::cpp2js_QSharedPointer_RShape(handler, v.at(i)));
              }
          }
          return ret;
      }

      QList<QSharedPointer<RShape>> RJSHelper_qcad::js2cpp_QList_QSharedPointer_RShape(RJSApi& handler, const QJSValue& v) {
          // TODO:
          qWarning() << "js2cpp_QList_QSharedPointer_RShape: TODO: not properly implemented";
          QJSEngine* engine = handler.getEngine();
          return engine->fromScriptValue<QList<QSharedPointer<RShape>>>(v);
      }

      bool RJSHelper_qcad::is_QList_QSharedPointer_RShape(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
  // -----------
  // QSet types:
  // -----------
  
      QJSValue RJSHelper_qcad::cpp2js_QSet_RBlock_Id(RJSApi& handler, const QSet<RBlock::Id>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.size());
          QSet<RBlock::Id>::const_iterator it;
          int i=0;
          for (it=v.constBegin(); it!=v.constEnd(); i++, it++) {
              ret.setProperty((quint32)i, RJSHelper_qcad::cpp2js_RBlock_Id(handler, *it));
          }
          return ret;
      }

      QSet<RBlock::Id> RJSHelper_qcad::js2cpp_QSet_RBlock_Id(RJSApi& handler, const QJSValue& v) {
          QSet<RBlock::Id> ret;
          if (!v.isArray()) {
              qWarning() << "js2cpp_QSet_RBlock_Id: value is not an array";
              return ret;
          }

          int len = v.property("length").toInt();
          for (int i=0; i<len; i++) {
              ret.insert(js2cpp_RBlock_Id(handler, v.property(i)));
          }
          return ret;

          //QJSEngine* engine = handler.getEngine();
          //return engine->fromScriptValue<QSet<RBlock::Id>>(v);
      }

      bool RJSHelper_qcad::is_QSet_RBlock_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSet_REntity_Id(RJSApi& handler, const QSet<REntity::Id>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.size());
          QSet<REntity::Id>::const_iterator it;
          int i=0;
          for (it=v.constBegin(); it!=v.constEnd(); i++, it++) {
              ret.setProperty((quint32)i, RJSHelper_qcad::cpp2js_REntity_Id(handler, *it));
          }
          return ret;
      }

      QSet<REntity::Id> RJSHelper_qcad::js2cpp_QSet_REntity_Id(RJSApi& handler, const QJSValue& v) {
          QSet<REntity::Id> ret;
          if (!v.isArray()) {
              qWarning() << "js2cpp_QSet_REntity_Id: value is not an array";
              return ret;
          }

          int len = v.property("length").toInt();
          for (int i=0; i<len; i++) {
              ret.insert(js2cpp_REntity_Id(handler, v.property(i)));
          }
          return ret;

          //QJSEngine* engine = handler.getEngine();
          //return engine->fromScriptValue<QSet<REntity::Id>>(v);
      }

      bool RJSHelper_qcad::is_QSet_REntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSet_RLayer_Id(RJSApi& handler, const QSet<RLayer::Id>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.size());
          QSet<RLayer::Id>::const_iterator it;
          int i=0;
          for (it=v.constBegin(); it!=v.constEnd(); i++, it++) {
              ret.setProperty((quint32)i, RJSHelper_qcad::cpp2js_RLayer_Id(handler, *it));
          }
          return ret;
      }

      QSet<RLayer::Id> RJSHelper_qcad::js2cpp_QSet_RLayer_Id(RJSApi& handler, const QJSValue& v) {
          QSet<RLayer::Id> ret;
          if (!v.isArray()) {
              qWarning() << "js2cpp_QSet_RLayer_Id: value is not an array";
              return ret;
          }

          int len = v.property("length").toInt();
          for (int i=0; i<len; i++) {
              ret.insert(js2cpp_RLayer_Id(handler, v.property(i)));
          }
          return ret;

          //QJSEngine* engine = handler.getEngine();
          //return engine->fromScriptValue<QSet<RLayer::Id>>(v);
      }

      bool RJSHelper_qcad::is_QSet_RLayer_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSet_RLayerState_Id(RJSApi& handler, const QSet<RLayerState::Id>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.size());
          QSet<RLayerState::Id>::const_iterator it;
          int i=0;
          for (it=v.constBegin(); it!=v.constEnd(); i++, it++) {
              ret.setProperty((quint32)i, RJSHelper_qcad::cpp2js_RLayerState_Id(handler, *it));
          }
          return ret;
      }

      QSet<RLayerState::Id> RJSHelper_qcad::js2cpp_QSet_RLayerState_Id(RJSApi& handler, const QJSValue& v) {
          QSet<RLayerState::Id> ret;
          if (!v.isArray()) {
              qWarning() << "js2cpp_QSet_RLayerState_Id: value is not an array";
              return ret;
          }

          int len = v.property("length").toInt();
          for (int i=0; i<len; i++) {
              ret.insert(js2cpp_RLayerState_Id(handler, v.property(i)));
          }
          return ret;

          //QJSEngine* engine = handler.getEngine();
          //return engine->fromScriptValue<QSet<RLayerState::Id>>(v);
      }

      bool RJSHelper_qcad::is_QSet_RLayerState_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSet_RLayout_Id(RJSApi& handler, const QSet<RLayout::Id>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.size());
          QSet<RLayout::Id>::const_iterator it;
          int i=0;
          for (it=v.constBegin(); it!=v.constEnd(); i++, it++) {
              ret.setProperty((quint32)i, RJSHelper_qcad::cpp2js_RLayout_Id(handler, *it));
          }
          return ret;
      }

      QSet<RLayout::Id> RJSHelper_qcad::js2cpp_QSet_RLayout_Id(RJSApi& handler, const QJSValue& v) {
          QSet<RLayout::Id> ret;
          if (!v.isArray()) {
              qWarning() << "js2cpp_QSet_RLayout_Id: value is not an array";
              return ret;
          }

          int len = v.property("length").toInt();
          for (int i=0; i<len; i++) {
              ret.insert(js2cpp_RLayout_Id(handler, v.property(i)));
          }
          return ret;

          //QJSEngine* engine = handler.getEngine();
          //return engine->fromScriptValue<QSet<RLayout::Id>>(v);
      }

      bool RJSHelper_qcad::is_QSet_RLayout_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSet_RLinetype_Id(RJSApi& handler, const QSet<RLinetype::Id>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.size());
          QSet<RLinetype::Id>::const_iterator it;
          int i=0;
          for (it=v.constBegin(); it!=v.constEnd(); i++, it++) {
              ret.setProperty((quint32)i, RJSHelper_qcad::cpp2js_RLinetype_Id(handler, *it));
          }
          return ret;
      }

      QSet<RLinetype::Id> RJSHelper_qcad::js2cpp_QSet_RLinetype_Id(RJSApi& handler, const QJSValue& v) {
          QSet<RLinetype::Id> ret;
          if (!v.isArray()) {
              qWarning() << "js2cpp_QSet_RLinetype_Id: value is not an array";
              return ret;
          }

          int len = v.property("length").toInt();
          for (int i=0; i<len; i++) {
              ret.insert(js2cpp_RLinetype_Id(handler, v.property(i)));
          }
          return ret;

          //QJSEngine* engine = handler.getEngine();
          //return engine->fromScriptValue<QSet<RLinetype::Id>>(v);
      }

      bool RJSHelper_qcad::is_QSet_RLinetype_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSet_RObject_Id(RJSApi& handler, const QSet<RObject::Id>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.size());
          QSet<RObject::Id>::const_iterator it;
          int i=0;
          for (it=v.constBegin(); it!=v.constEnd(); i++, it++) {
              ret.setProperty((quint32)i, RJSHelper_qcad::cpp2js_RObject_Id(handler, *it));
          }
          return ret;
      }

      QSet<RObject::Id> RJSHelper_qcad::js2cpp_QSet_RObject_Id(RJSApi& handler, const QJSValue& v) {
          QSet<RObject::Id> ret;
          if (!v.isArray()) {
              qWarning() << "js2cpp_QSet_RObject_Id: value is not an array";
              return ret;
          }

          int len = v.property("length").toInt();
          for (int i=0; i<len; i++) {
              ret.insert(js2cpp_RObject_Id(handler, v.property(i)));
          }
          return ret;

          //QJSEngine* engine = handler.getEngine();
          //return engine->fromScriptValue<QSet<RObject::Id>>(v);
      }

      bool RJSHelper_qcad::is_QSet_RObject_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSet_RPropertyTypeId(RJSApi& handler, const QSet<RPropertyTypeId>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.size());
          QSet<RPropertyTypeId>::const_iterator it;
          int i=0;
          for (it=v.constBegin(); it!=v.constEnd(); i++, it++) {
              ret.setProperty((quint32)i, RJSHelper_qcad::cpp2js_RPropertyTypeId(handler, *it));
          }
          return ret;
      }

      QSet<RPropertyTypeId> RJSHelper_qcad::js2cpp_QSet_RPropertyTypeId(RJSApi& handler, const QJSValue& v) {
          QSet<RPropertyTypeId> ret;
          if (!v.isArray()) {
              qWarning() << "js2cpp_QSet_RPropertyTypeId: value is not an array";
              return ret;
          }

          int len = v.property("length").toInt();
          for (int i=0; i<len; i++) {
              ret.insert(js2cpp_RPropertyTypeId(handler, v.property(i)));
          }
          return ret;

          //QJSEngine* engine = handler.getEngine();
          //return engine->fromScriptValue<QSet<RPropertyTypeId>>(v);
      }

      bool RJSHelper_qcad::is_QSet_RPropertyTypeId(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSet_RUcs_Id(RJSApi& handler, const QSet<RUcs::Id>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.size());
          QSet<RUcs::Id>::const_iterator it;
          int i=0;
          for (it=v.constBegin(); it!=v.constEnd(); i++, it++) {
              ret.setProperty((quint32)i, RJSHelper_qcad::cpp2js_RUcs_Id(handler, *it));
          }
          return ret;
      }

      QSet<RUcs::Id> RJSHelper_qcad::js2cpp_QSet_RUcs_Id(RJSApi& handler, const QJSValue& v) {
          QSet<RUcs::Id> ret;
          if (!v.isArray()) {
              qWarning() << "js2cpp_QSet_RUcs_Id: value is not an array";
              return ret;
          }

          int len = v.property("length").toInt();
          for (int i=0; i<len; i++) {
              ret.insert(js2cpp_RUcs_Id(handler, v.property(i)));
          }
          return ret;

          //QJSEngine* engine = handler.getEngine();
          //return engine->fromScriptValue<QSet<RUcs::Id>>(v);
      }

      bool RJSHelper_qcad::is_QSet_RUcs_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSet_RView_Id(RJSApi& handler, const QSet<RView::Id>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.size());
          QSet<RView::Id>::const_iterator it;
          int i=0;
          for (it=v.constBegin(); it!=v.constEnd(); i++, it++) {
              ret.setProperty((quint32)i, RJSHelper_qcad::cpp2js_RView_Id(handler, *it));
          }
          return ret;
      }

      QSet<RView::Id> RJSHelper_qcad::js2cpp_QSet_RView_Id(RJSApi& handler, const QJSValue& v) {
          QSet<RView::Id> ret;
          if (!v.isArray()) {
              qWarning() << "js2cpp_QSet_RView_Id: value is not an array";
              return ret;
          }

          int len = v.property("length").toInt();
          for (int i=0; i<len; i++) {
              ret.insert(js2cpp_RView_Id(handler, v.property(i)));
          }
          return ret;

          //QJSEngine* engine = handler.getEngine();
          //return engine->fromScriptValue<QSet<RView::Id>>(v);
      }

      bool RJSHelper_qcad::is_QSet_RView_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
  // -----------
  // QMap types:
  // -----------
  
  // ------------
  // QPair types:
  // ------------
  
      QJSValue RJSHelper_qcad::cpp2js_QPair_QVariant_RPropertyAttributes(RJSApi& handler, const QPair<QVariant,RPropertyAttributes>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray(2);
          ret.setProperty(0, RJSHelper::cpp2js_QVariant(handler, v.first));
          ret.setProperty(1, RJSHelper_qcad::cpp2js_RPropertyAttributes(handler, v.second));
          return ret;
      }

      QPair<QVariant,RPropertyAttributes> RJSHelper_qcad::js2cpp_QPair_QVariant_RPropertyAttributes(RJSApi& handler, const QJSValue& v) {
          // TODO:
          qWarning() << "js2cpp_QPair_QVariant_RPropertyAttributes: TODO: not properly implemented";
          QJSEngine* engine = handler.getEngine();
          return engine->fromScriptValue<QPair<QVariant,RPropertyAttributes>>(v);
      }

      bool RJSHelper_qcad::is_QPair_QVariant_RPropertyAttributes(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
  // ------------
  // dummy types:
  // ------------
  
  // --------------------
  // dummy pointer types:
  // --------------------
  