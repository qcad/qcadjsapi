
  // Automatically generated, do not edit
  
          #include "RJSHelper_qcad.h"
        
          #include "header_qcad_cpp.h"
        
          #include "raction_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "raddobjectsoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rarc_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rtextbaseddata_wrapper.h"
        
          #include "rtextbaseddata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rtextbasedentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rtextbasedentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rblocklistener_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qtoolbar_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rwidget_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rcircle_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qcolor_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qlineedit_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "rinputevent_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rcoordinatelistener_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rclipboardoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rdeleteobjectsoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rclipboardoperation_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimlineardata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimlinearentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimangulardata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimangularentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimangulardata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimangularentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimangulardata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimangularentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimlineardata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimlinearentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rdimstyledata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qdockwidget_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rellipse_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rinputevent_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rsoliddata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rexporter_wrapper.h"
        
          #include "rexporter_wrapper.h"
        
          #include "rfileexporter_wrapper.h"
        
          #include "rfileexporterfactory_wrapper.h"
        
          #include "rimporter_wrapper.h"
        
          #include "rimporter_wrapper.h"
        
          #include "rfileimporter_wrapper.h"
        
          #include "rfileimporterfactory_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemmodel_wrapper.h"
        
          #include "qfilesystemmodel_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
          #include "qlayout_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rfocuslistener_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rexporter_wrapper.h"
        
          #include "rexporter_wrapper.h"
        
          #include "rgraphicsscene_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rgraphicsview_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rfocuslistener_wrapper.h"
        
          #include "rtransactionlistener_wrapper.h"
        
          #include "rselectionlistener_wrapper.h"
        
          #include "qaction_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rintertransactionlistener_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rkeylistener_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rlayerlistener_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpolyline_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rline_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qlistview_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qlistview_wrapper.h"
        
          #include "qlistwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rmainwindow_wrapper.h"
        
          #include "qmainwindow_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qlineedit_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qmdiarea_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rmodifiedlistener_wrapper.h"
        
          #include "qmdisubwindow_wrapper.h"
        
          #include "rstorage_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "raddobjectoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "raddobjectsoperation_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qinputevent_wrapper.h"
        
          #include "qpointerevent_wrapper.h"
        
          #include "qsinglepointevent_wrapper.h"
        
          #include "qmouseevent_wrapper.h"
        
          #include "rinputevent_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rgrid_wrapper.h"
        
          #include "qpainterpath_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpalettelistener_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rclipboardoperation_wrapper.h"
        
          #include "rpatternlist_wrapper.h"
        
          #include "rpatternlist_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpenlistener_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpoint_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rexplodable_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpolyline_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpreferenceslistener_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpropertylistener_wrapper.h"
        
          #include "rlayerlistener_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpropertylistener_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rxline_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rray_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rvector_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
          #include "rrestrictorthogonal_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
          #include "rrestrictorthogonal_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rruler_wrapper.h"
        
          #include "rcoordinatelistener_wrapper.h"
        
          #include "rpalettelistener_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rselectionlistener_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qcoreapplication_wrapper.h"
        
          #include "qguiapplication_wrapper.h"
        
          #include "qapplication_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpolyline_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rspatialindex_wrapper.h"
        
          #include "rspatialindex_wrapper.h"
        
          #include "rspatialindexvisitor_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rexplodable_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rspline_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpainterpathsource_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rtextbaseddata_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qtextedit_wrapper.h"
        
          #include "qtextbrowser_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rtextbasedentity_wrapper.h"
        
          #include "rpoint_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qtoolbutton_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemdelegate_wrapper.h"
        
          #include "qitemdelegate_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rsoliddata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rtransactionlistener_wrapper.h"
        
          #include "qtransform_wrapper.h"
        
          #include "rtransformation_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qtreeview_wrapper.h"
        
          #include "qtreewidget_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rexplodable_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rviewfocuslistener_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rviewlistener_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpoint_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qinputevent_wrapper.h"
        
          #include "qpointerevent_wrapper.h"
        
          #include "qsinglepointevent_wrapper.h"
        
          #include "qwheelevent_wrapper.h"
        
          #include "rinputevent_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpolylinedata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rxline_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        // downcaster classes:
        

          // downcasters from QAction to ...
          

            // downcasters from QAction to RGuiAction
            class RJSDowncaster_QAction_RGuiAction : public RJSDowncaster_QAction {
                QJSValue downcast(RJSApi& handler, QAction* o) {
                    RGuiAction* c = dynamic_cast<RGuiAction*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RGuiAction(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QApplication to ...
          

            // downcasters from QApplication to RSingleApplication
            class RJSDowncaster_QApplication_RSingleApplication : public RJSDowncaster_QApplication {
                QJSValue downcast(RJSApi& handler, QApplication* o) {
                    RSingleApplication* c = dynamic_cast<RSingleApplication*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RSingleApplication(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QComboBox to ...
          

            // downcasters from QComboBox to RColorCombo
            class RJSDowncaster_QComboBox_RColorCombo : public RJSDowncaster_QComboBox {
                QJSValue downcast(RJSApi& handler, QComboBox* o) {
                    RColorCombo* c = dynamic_cast<RColorCombo*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RColorCombo(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QComboBox to RComboBox
            class RJSDowncaster_QComboBox_RComboBox : public RJSDowncaster_QComboBox {
                QJSValue downcast(RJSApi& handler, QComboBox* o) {
                    RComboBox* c = dynamic_cast<RComboBox*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RComboBox(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QComboBox to RLinetypeCombo
            class RJSDowncaster_QComboBox_RLinetypeCombo : public RJSDowncaster_QComboBox {
                QJSValue downcast(RJSApi& handler, QComboBox* o) {
                    RLinetypeCombo* c = dynamic_cast<RLinetypeCombo*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RLinetypeCombo(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QComboBox to RLineweightCombo
            class RJSDowncaster_QComboBox_RLineweightCombo : public RJSDowncaster_QComboBox {
                QJSValue downcast(RJSApi& handler, QComboBox* o) {
                    RLineweightCombo* c = dynamic_cast<RLineweightCombo*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RLineweightCombo(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QComboBox to RMathComboBox
            class RJSDowncaster_QComboBox_RMathComboBox : public RJSDowncaster_QComboBox {
                QJSValue downcast(RJSApi& handler, QComboBox* o) {
                    RMathComboBox* c = dynamic_cast<RMathComboBox*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RMathComboBox(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QEvent to ...
          

            // downcasters from QEvent to RCloseCurrentEvent
            class RJSDowncaster_QEvent_RCloseCurrentEvent : public RJSDowncaster_QEvent {
                QJSValue downcast(RJSApi& handler, QEvent* o) {
                    RCloseCurrentEvent* c = dynamic_cast<RCloseCurrentEvent*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RCloseCurrentEvent(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QEvent to RPropertyEvent
            class RJSDowncaster_QEvent_RPropertyEvent : public RJSDowncaster_QEvent {
                QJSValue downcast(RJSApi& handler, QEvent* o) {
                    RPropertyEvent* c = dynamic_cast<RPropertyEvent*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RPropertyEvent(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QEvent to RTerminateEvent
            class RJSDowncaster_QEvent_RTerminateEvent : public RJSDowncaster_QEvent {
                QJSValue downcast(RJSApi& handler, QEvent* o) {
                    RTerminateEvent* c = dynamic_cast<RTerminateEvent*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RTerminateEvent(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QDockWidget to ...
          

            // downcasters from QDockWidget to RDockWidget
            class RJSDowncaster_QDockWidget_RDockWidget : public RJSDowncaster_QDockWidget {
                QJSValue downcast(RJSApi& handler, QDockWidget* o) {
                    RDockWidget* c = dynamic_cast<RDockWidget*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RDockWidget(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QFileSystemModel to ...
          

            // downcasters from QFileSystemModel to RFileSystemModel
            class RJSDowncaster_QFileSystemModel_RFileSystemModel : public RJSDowncaster_QFileSystemModel {
                QJSValue downcast(RJSApi& handler, QFileSystemModel* o) {
                    RFileSystemModel* c = dynamic_cast<RFileSystemModel*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RFileSystemModel(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QFrame to ...
          

            // downcasters from QFrame to RRulerQt
            class RJSDowncaster_QFrame_RRulerQt : public RJSDowncaster_QFrame {
                QJSValue downcast(RJSApi& handler, QFrame* o) {
                    RRulerQt* c = dynamic_cast<RRulerQt*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RRulerQt(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QItemDelegate to ...
          

            // downcasters from QItemDelegate to RToolMatrixItemDelegate
            class RJSDowncaster_QItemDelegate_RToolMatrixItemDelegate : public RJSDowncaster_QItemDelegate {
                QJSValue downcast(RJSApi& handler, QItemDelegate* o) {
                    RToolMatrixItemDelegate* c = dynamic_cast<RToolMatrixItemDelegate*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RToolMatrixItemDelegate(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QJSEngine to ...
          

          // downcasters from QLayout to ...
          

            // downcasters from QLayout to RFlowLayout
            class RJSDowncaster_QLayout_RFlowLayout : public RJSDowncaster_QLayout {
                QJSValue downcast(RJSApi& handler, QLayout* o) {
                    RFlowLayout* c = dynamic_cast<RFlowLayout*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RFlowLayout(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QLineEdit to ...
          

            // downcasters from QLineEdit to RCommandLine
            class RJSDowncaster_QLineEdit_RCommandLine : public RJSDowncaster_QLineEdit {
                QJSValue downcast(RJSApi& handler, QLineEdit* o) {
                    RCommandLine* c = dynamic_cast<RCommandLine*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RCommandLine(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QLineEdit to RMathLineEdit
            class RJSDowncaster_QLineEdit_RMathLineEdit : public RJSDowncaster_QLineEdit {
                QJSValue downcast(RJSApi& handler, QLineEdit* o) {
                    RMathLineEdit* c = dynamic_cast<RMathLineEdit*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RMathLineEdit(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QListView to ...
          

            // downcasters from QListView to RListView
            class RJSDowncaster_QListView_RListView : public RJSDowncaster_QListView {
                QJSValue downcast(RJSApi& handler, QListView* o) {
                    RListView* c = dynamic_cast<RListView*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RListView(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QListWidget to ...
          

            // downcasters from QListWidget to RListWidget
            class RJSDowncaster_QListWidget_RListWidget : public RJSDowncaster_QListWidget {
                QJSValue downcast(RJSApi& handler, QListWidget* o) {
                    RListWidget* c = dynamic_cast<RListWidget*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RListWidget(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QMainWindow to ...
          

            // downcasters from QMainWindow to RMainWindowQt
            class RJSDowncaster_QMainWindow_RMainWindowQt : public RJSDowncaster_QMainWindow {
                QJSValue downcast(RJSApi& handler, QMainWindow* o) {
                    RMainWindowQt* c = dynamic_cast<RMainWindowQt*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RMainWindowQt(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QMdiArea to ...
          

            // downcasters from QMdiArea to RMdiArea
            class RJSDowncaster_QMdiArea_RMdiArea : public RJSDowncaster_QMdiArea {
                QJSValue downcast(RJSApi& handler, QMdiArea* o) {
                    RMdiArea* c = dynamic_cast<RMdiArea*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RMdiArea(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QMdiSubWindow to ...
          

            // downcasters from QMdiSubWindow to RMdiChildQt
            class RJSDowncaster_QMdiSubWindow_RMdiChildQt : public RJSDowncaster_QMdiSubWindow {
                QJSValue downcast(RJSApi& handler, QMdiSubWindow* o) {
                    RMdiChildQt* c = dynamic_cast<RMdiChildQt*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RMdiChildQt(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QObject to ...
          

            // downcasters from QObject to REventFilter
            class RJSDowncaster_QObject_REventFilter : public RJSDowncaster_QObject {
                QJSValue downcast(RJSApi& handler, QObject* o) {
                    REventFilter* c = dynamic_cast<REventFilter*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_REventFilter(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QObject to REventHandler
            class RJSDowncaster_QObject_REventHandler : public RJSDowncaster_QObject {
                QJSValue downcast(RJSApi& handler, QObject* o) {
                    REventHandler* c = dynamic_cast<REventHandler*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_REventHandler(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QObject to RGraphicsViewImage
            class RJSDowncaster_QObject_RGraphicsViewImage : public RJSDowncaster_QObject {
                QJSValue downcast(RJSApi& handler, QObject* o) {
                    RGraphicsViewImage* c = dynamic_cast<RGraphicsViewImage*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RGraphicsViewImage(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QObject to RGraphicsViewWorker
            class RJSDowncaster_QObject_RGraphicsViewWorker : public RJSDowncaster_QObject {
                QJSValue downcast(RJSApi& handler, QObject* o) {
                    RGraphicsViewWorker* c = dynamic_cast<RGraphicsViewWorker*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RGraphicsViewWorker(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QObject to RToolOptionEventFilter
            class RJSDowncaster_QObject_RToolOptionEventFilter : public RJSDowncaster_QObject {
                QJSValue downcast(RJSApi& handler, QObject* o) {
                    RToolOptionEventFilter* c = dynamic_cast<RToolOptionEventFilter*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RToolOptionEventFilter(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QQmlEngine to ...
          

          // downcasters from QTextBrowser to ...
          

            // downcasters from QTextBrowser to RTextEdit
            class RJSDowncaster_QTextBrowser_RTextEdit : public RJSDowncaster_QTextBrowser {
                QJSValue downcast(RJSApi& handler, QTextBrowser* o) {
                    RTextEdit* c = dynamic_cast<RTextEdit*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RTextEdit(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QToolBar to ...
          

            // downcasters from QToolBar to RCadToolBar
            class RJSDowncaster_QToolBar_RCadToolBar : public RJSDowncaster_QToolBar {
                QJSValue downcast(RJSApi& handler, QToolBar* o) {
                    RCadToolBar* c = dynamic_cast<RCadToolBar*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RCadToolBar(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QToolButton to ...
          

            // downcasters from QToolButton to RToolButton
            class RJSDowncaster_QToolButton_RToolButton : public RJSDowncaster_QToolButton {
                QJSValue downcast(RJSApi& handler, QToolButton* o) {
                    RToolButton* c = dynamic_cast<RToolButton*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RToolButton(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QTreeWidget to ...
          

            // downcasters from QTreeWidget to RTreeWidget
            class RJSDowncaster_QTreeWidget_RTreeWidget : public RJSDowncaster_QTreeWidget {
                QJSValue downcast(RJSApi& handler, QTreeWidget* o) {
                    RTreeWidget* c = dynamic_cast<RTreeWidget*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RTreeWidget(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QWidget to ...
          

            // downcasters from QWidget to RCharacterWidget
            class RJSDowncaster_QWidget_RCharacterWidget : public RJSDowncaster_QWidget {
                QJSValue downcast(RJSApi& handler, QWidget* o) {
                    RCharacterWidget* c = dynamic_cast<RCharacterWidget*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RCharacterWidget(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QWidget to RFontChooserWidget
            class RJSDowncaster_QWidget_RFontChooserWidget : public RJSDowncaster_QWidget {
                QJSValue downcast(RJSApi& handler, QWidget* o) {
                    RFontChooserWidget* c = dynamic_cast<RFontChooserWidget*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RFontChooserWidget(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QWidget to RGraphicsViewQt
            class RJSDowncaster_QWidget_RGraphicsViewQt : public RJSDowncaster_QWidget {
                QJSValue downcast(RJSApi& handler, QWidget* o) {
                    RGraphicsViewQt* c = dynamic_cast<RGraphicsViewQt*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RGraphicsViewQt(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QWidget to RWidget
            class RJSDowncaster_QWidget_RWidget : public RJSDowncaster_QWidget {
                QJSValue downcast(RJSApi& handler, QWidget* o) {
                    RWidget* c = dynamic_cast<RWidget*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RWidget(handler, c);
                    }
                    return QJSValue();
                }
            };

          
  // ----------------------
  // wrapped pointer types:
  // ----------------------
  
      QJSValue RJSHelper_qcad::cpp2js_RPainterPathSource(RJSApi& handler, RPainterPathSource* v) {

          
            // downcast to RTextBasedData:
            {
                RTextBasedData* o = dynamic_cast<RTextBasedData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RTextBasedData(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RPainterPathSource_Wrapper* ret = new RPainterPathSource_Wrapper(handler, v, false);

          // JS: new RPainterPathSource('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPainterPathSource");
          if (cl.isUndefined()) {
              qWarning() << "Class RPainterPathSource is undefined. Use RPainterPathSource_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPainterPathSource('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPainterPathSource(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RPainterPathSource* RJSHelper_qcad::js2cpp_RPainterPathSource_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPainterPathSource: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPainterPathSource_Wrapper* wrapper = qobject_cast<RPainterPathSource_Wrapper*>(obj);
          //RPainterPathSource_Wrapper* wrapper = dynamic_cast<RPainterPathSource_Wrapper*>(obj);
          //RPainterPathSource_Wrapper* wrapper = (RPainterPathSource_Wrapper*)(obj);
          //RPainterPathSource_Wrapper* wrapper = getWrapper<RPainterPathSource_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPainterPathSource_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RPainterPathSource(wrapper);
          return RPainterPathSource_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPainterPathSource_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPainterPathSource: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RPainterPathSource::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RShape(RJSApi& handler, RShape* v) {

          
            // downcast to RArc:
            {
                RArc* o = dynamic_cast<RArc*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RArc(handler, o);
                }
            }
          
            // downcast to RCircle:
            {
                RCircle* o = dynamic_cast<RCircle*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RCircle(handler, o);
                }
            }
          
            // downcast to REllipse:
            {
                REllipse* o = dynamic_cast<REllipse*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_REllipse(handler, o);
                }
            }
          
            // downcast to RLine:
            {
                RLine* o = dynamic_cast<RLine*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RLine(handler, o);
                }
            }
          
            // downcast to RPoint:
            {
                RPoint* o = dynamic_cast<RPoint*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RPoint(handler, o);
                }
            }
          
            // downcast to RPolyline:
            {
                RPolyline* o = dynamic_cast<RPolyline*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RPolyline(handler, o);
                }
            }
          
            // downcast to RRay:
            {
                RRay* o = dynamic_cast<RRay*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RRay(handler, o);
                }
            }
          
            // downcast to RSpline:
            {
                RSpline* o = dynamic_cast<RSpline*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSpline(handler, o);
                }
            }
          
            // downcast to RTriangle:
            {
                RTriangle* o = dynamic_cast<RTriangle*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RTriangle(handler, o);
                }
            }
          
            // downcast to RXLine:
            {
                RXLine* o = dynamic_cast<RXLine*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RXLine(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RShape_Wrapper* ret = new RShape_Wrapper(handler, v, false);

          // JS: new RShape('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RShape");
          if (cl.isUndefined()) {
              qWarning() << "Class RShape is undefined. Use RShape_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RShape('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RShape(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RShape* RJSHelper_qcad::js2cpp_RShape_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RShape: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RShape_Wrapper* wrapper = qobject_cast<RShape_Wrapper*>(obj);
          //RShape_Wrapper* wrapper = dynamic_cast<RShape_Wrapper*>(obj);
          //RShape_Wrapper* wrapper = (RShape_Wrapper*)(obj);
          //RShape_Wrapper* wrapper = getWrapper<RShape_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RShape_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RShape(wrapper);
          return RShape_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RShape_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RShape: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RShape::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RAction(RJSApi& handler, RAction* v) {

          
            // downcast to RActionAdapter:
            {
                RActionAdapter* o = dynamic_cast<RActionAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RActionAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RAction_Wrapper* ret = new RAction_Wrapper(handler, v, false);

          // JS: new RAction('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RAction");
          if (cl.isUndefined()) {
              qWarning() << "Class RAction is undefined. Use RAction_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RAction('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RAction(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RAction* RJSHelper_qcad::js2cpp_RAction_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RAction: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RAction_Wrapper* wrapper = qobject_cast<RAction_Wrapper*>(obj);
          //RAction_Wrapper* wrapper = dynamic_cast<RAction_Wrapper*>(obj);
          //RAction_Wrapper* wrapper = (RAction_Wrapper*)(obj);
          //RAction_Wrapper* wrapper = getWrapper<RAction_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RAction_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RAction(wrapper);
          return RAction_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RAction_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RAction: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RAction::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RActionAdapter(RJSApi& handler, RActionAdapter* v) {

          

          QJSEngine* engine = handler.getEngine();
          RActionAdapter_Wrapper* ret = new RActionAdapter_Wrapper(handler, v, false);

          // JS: new RActionAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RActionAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RActionAdapter is undefined. Use RActionAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RActionAdapter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RActionAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RActionAdapter* RJSHelper_qcad::js2cpp_RActionAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RActionAdapter: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RActionAdapter_Wrapper* wrapper = qobject_cast<RActionAdapter_Wrapper*>(obj);
          //RActionAdapter_Wrapper* wrapper = dynamic_cast<RActionAdapter_Wrapper*>(obj);
          //RActionAdapter_Wrapper* wrapper = (RActionAdapter_Wrapper*)(obj);
          //RActionAdapter_Wrapper* wrapper = getWrapper<RActionAdapter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RActionAdapter_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RActionAdapter(wrapper);
          return RActionAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RActionAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RActionAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RActionAdapter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RAddObjectOperation(RJSApi& handler, RAddObjectOperation* v) {

          
            // downcast to RModifyObjectOperation:
            {
                RModifyObjectOperation* o = dynamic_cast<RModifyObjectOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RModifyObjectOperation(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RAddObjectOperation_Wrapper* ret = new RAddObjectOperation_Wrapper(handler, v, false);

          // JS: new RAddObjectOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RAddObjectOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RAddObjectOperation is undefined. Use RAddObjectOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RAddObjectOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RAddObjectOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RAddObjectOperation* RJSHelper_qcad::js2cpp_RAddObjectOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RAddObjectOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RAddObjectOperation_Wrapper* wrapper = qobject_cast<RAddObjectOperation_Wrapper*>(obj);
          //RAddObjectOperation_Wrapper* wrapper = dynamic_cast<RAddObjectOperation_Wrapper*>(obj);
          //RAddObjectOperation_Wrapper* wrapper = (RAddObjectOperation_Wrapper*)(obj);
          //RAddObjectOperation_Wrapper* wrapper = getWrapper<RAddObjectOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RAddObjectOperation_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RAddObjectOperation(wrapper);
          return RAddObjectOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RAddObjectOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RAddObjectOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RAddObjectOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RAddObjectsOperation(RJSApi& handler, RAddObjectsOperation* v) {

          
            // downcast to RAddObjectOperation:
            {
                RAddObjectOperation* o = dynamic_cast<RAddObjectOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RAddObjectOperation(handler, o);
                }
            }
          
            // downcast to RModifyObjectsOperation:
            {
                RModifyObjectsOperation* o = dynamic_cast<RModifyObjectsOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RModifyObjectsOperation(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RAddObjectsOperation_Wrapper* ret = new RAddObjectsOperation_Wrapper(handler, v, false);

          // JS: new RAddObjectsOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RAddObjectsOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RAddObjectsOperation is undefined. Use RAddObjectsOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RAddObjectsOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RAddObjectsOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RAddObjectsOperation* RJSHelper_qcad::js2cpp_RAddObjectsOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RAddObjectsOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RAddObjectsOperation_Wrapper* wrapper = qobject_cast<RAddObjectsOperation_Wrapper*>(obj);
          //RAddObjectsOperation_Wrapper* wrapper = dynamic_cast<RAddObjectsOperation_Wrapper*>(obj);
          //RAddObjectsOperation_Wrapper* wrapper = (RAddObjectsOperation_Wrapper*)(obj);
          //RAddObjectsOperation_Wrapper* wrapper = getWrapper<RAddObjectsOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RAddObjectsOperation_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RAddObjectsOperation(wrapper);
          return RAddObjectsOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RAddObjectsOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RAddObjectsOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RAddObjectsOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RArcEntity(RJSApi& handler, RArcEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RArcEntity_Wrapper* ret = new RArcEntity_Wrapper(handler, v, false);

          // JS: new RArcEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RArcEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RArcEntity is undefined. Use RArcEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RArcEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RArcEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RArcEntity* RJSHelper_qcad::js2cpp_RArcEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RArcEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RArcEntity_Wrapper* wrapper = qobject_cast<RArcEntity_Wrapper*>(obj);
          //RArcEntity_Wrapper* wrapper = dynamic_cast<RArcEntity_Wrapper*>(obj);
          //RArcEntity_Wrapper* wrapper = (RArcEntity_Wrapper*)(obj);
          //RArcEntity_Wrapper* wrapper = getWrapper<RArcEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RArcEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RArcEntity(wrapper);
          return RArcEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RArcEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RArcEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RArcEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RAttributeDefinitionEntity(RJSApi& handler, RAttributeDefinitionEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RAttributeDefinitionEntity_Wrapper* ret = new RAttributeDefinitionEntity_Wrapper(handler, v, false);

          // JS: new RAttributeDefinitionEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RAttributeDefinitionEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RAttributeDefinitionEntity is undefined. Use RAttributeDefinitionEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RAttributeDefinitionEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RAttributeDefinitionEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RAttributeDefinitionEntity* RJSHelper_qcad::js2cpp_RAttributeDefinitionEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RAttributeDefinitionEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RAttributeDefinitionEntity_Wrapper* wrapper = qobject_cast<RAttributeDefinitionEntity_Wrapper*>(obj);
          //RAttributeDefinitionEntity_Wrapper* wrapper = dynamic_cast<RAttributeDefinitionEntity_Wrapper*>(obj);
          //RAttributeDefinitionEntity_Wrapper* wrapper = (RAttributeDefinitionEntity_Wrapper*)(obj);
          //RAttributeDefinitionEntity_Wrapper* wrapper = getWrapper<RAttributeDefinitionEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RAttributeDefinitionEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RAttributeDefinitionEntity(wrapper);
          return RAttributeDefinitionEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RAttributeDefinitionEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RAttributeDefinitionEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RAttributeDefinitionEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RAttributeEntity(RJSApi& handler, RAttributeEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RAttributeEntity_Wrapper* ret = new RAttributeEntity_Wrapper(handler, v, false);

          // JS: new RAttributeEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RAttributeEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RAttributeEntity is undefined. Use RAttributeEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RAttributeEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RAttributeEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RAttributeEntity* RJSHelper_qcad::js2cpp_RAttributeEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RAttributeEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RAttributeEntity_Wrapper* wrapper = qobject_cast<RAttributeEntity_Wrapper*>(obj);
          //RAttributeEntity_Wrapper* wrapper = dynamic_cast<RAttributeEntity_Wrapper*>(obj);
          //RAttributeEntity_Wrapper* wrapper = (RAttributeEntity_Wrapper*)(obj);
          //RAttributeEntity_Wrapper* wrapper = getWrapper<RAttributeEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RAttributeEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RAttributeEntity(wrapper);
          return RAttributeEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RAttributeEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RAttributeEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RAttributeEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RBlock(RJSApi& handler, RBlock* v) {

          

          QJSEngine* engine = handler.getEngine();
          RBlock_Wrapper* ret = new RBlock_Wrapper(handler, v, false);

          // JS: new RBlock('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RBlock");
          if (cl.isUndefined()) {
              qWarning() << "Class RBlock is undefined. Use RBlock_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RBlock('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RBlock(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RBlock* RJSHelper_qcad::js2cpp_RBlock_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RBlock: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RBlock_Wrapper* wrapper = qobject_cast<RBlock_Wrapper*>(obj);
          //RBlock_Wrapper* wrapper = dynamic_cast<RBlock_Wrapper*>(obj);
          //RBlock_Wrapper* wrapper = (RBlock_Wrapper*)(obj);
          //RBlock_Wrapper* wrapper = getWrapper<RBlock_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RBlock_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RBlock(wrapper);
          return RBlock_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RBlock_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RBlock: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RBlock::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RBlockListener(RJSApi& handler, RBlockListener* v) {

          
            // downcast to RBlockListenerAdapter:
            {
                RBlockListenerAdapter* o = dynamic_cast<RBlockListenerAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RBlockListenerAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RBlockListener_Wrapper* ret = new RBlockListener_Wrapper(handler, v, false);

          // JS: new RBlockListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RBlockListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RBlockListener is undefined. Use RBlockListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RBlockListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RBlockListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RBlockListener* RJSHelper_qcad::js2cpp_RBlockListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RBlockListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RBlockListener_Wrapper* wrapper = qobject_cast<RBlockListener_Wrapper*>(obj);
          //RBlockListener_Wrapper* wrapper = dynamic_cast<RBlockListener_Wrapper*>(obj);
          //RBlockListener_Wrapper* wrapper = (RBlockListener_Wrapper*)(obj);
          //RBlockListener_Wrapper* wrapper = getWrapper<RBlockListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RBlockListener_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RBlockListener(wrapper);
          return RBlockListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RBlockListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RBlockListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RBlockListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RBlockReferenceEntity(RJSApi& handler, RBlockReferenceEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RBlockReferenceEntity_Wrapper* ret = new RBlockReferenceEntity_Wrapper(handler, v, false);

          // JS: new RBlockReferenceEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RBlockReferenceEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RBlockReferenceEntity is undefined. Use RBlockReferenceEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RBlockReferenceEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RBlockReferenceEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RBlockReferenceEntity* RJSHelper_qcad::js2cpp_RBlockReferenceEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RBlockReferenceEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RBlockReferenceEntity_Wrapper* wrapper = qobject_cast<RBlockReferenceEntity_Wrapper*>(obj);
          //RBlockReferenceEntity_Wrapper* wrapper = dynamic_cast<RBlockReferenceEntity_Wrapper*>(obj);
          //RBlockReferenceEntity_Wrapper* wrapper = (RBlockReferenceEntity_Wrapper*)(obj);
          //RBlockReferenceEntity_Wrapper* wrapper = getWrapper<RBlockReferenceEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RBlockReferenceEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RBlockReferenceEntity(wrapper);
          return RBlockReferenceEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RBlockReferenceEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RBlockReferenceEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RBlockReferenceEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RChangePropertyOperation(RJSApi& handler, RChangePropertyOperation* v) {

          

          QJSEngine* engine = handler.getEngine();
          RChangePropertyOperation_Wrapper* ret = new RChangePropertyOperation_Wrapper(handler, v, false);

          // JS: new RChangePropertyOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RChangePropertyOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RChangePropertyOperation is undefined. Use RChangePropertyOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RChangePropertyOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RChangePropertyOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RChangePropertyOperation* RJSHelper_qcad::js2cpp_RChangePropertyOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RChangePropertyOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RChangePropertyOperation_Wrapper* wrapper = qobject_cast<RChangePropertyOperation_Wrapper*>(obj);
          //RChangePropertyOperation_Wrapper* wrapper = dynamic_cast<RChangePropertyOperation_Wrapper*>(obj);
          //RChangePropertyOperation_Wrapper* wrapper = (RChangePropertyOperation_Wrapper*)(obj);
          //RChangePropertyOperation_Wrapper* wrapper = getWrapper<RChangePropertyOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RChangePropertyOperation_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RChangePropertyOperation(wrapper);
          return RChangePropertyOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RChangePropertyOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RChangePropertyOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RChangePropertyOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RCircleEntity(RJSApi& handler, RCircleEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RCircleEntity_Wrapper* ret = new RCircleEntity_Wrapper(handler, v, false);

          // JS: new RCircleEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCircleEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RCircleEntity is undefined. Use RCircleEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCircleEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCircleEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RCircleEntity* RJSHelper_qcad::js2cpp_RCircleEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RCircleEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RCircleEntity_Wrapper* wrapper = qobject_cast<RCircleEntity_Wrapper*>(obj);
          //RCircleEntity_Wrapper* wrapper = dynamic_cast<RCircleEntity_Wrapper*>(obj);
          //RCircleEntity_Wrapper* wrapper = (RCircleEntity_Wrapper*)(obj);
          //RCircleEntity_Wrapper* wrapper = getWrapper<RCircleEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCircleEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RCircleEntity(wrapper);
          return RCircleEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RCircleEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RCircleEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RCircleEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RClickReferencePointOperation(RJSApi& handler, RClickReferencePointOperation* v) {

          

          QJSEngine* engine = handler.getEngine();
          RClickReferencePointOperation_Wrapper* ret = new RClickReferencePointOperation_Wrapper(handler, v, false);

          // JS: new RClickReferencePointOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RClickReferencePointOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RClickReferencePointOperation is undefined. Use RClickReferencePointOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RClickReferencePointOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RClickReferencePointOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RClickReferencePointOperation* RJSHelper_qcad::js2cpp_RClickReferencePointOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RClickReferencePointOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RClickReferencePointOperation_Wrapper* wrapper = qobject_cast<RClickReferencePointOperation_Wrapper*>(obj);
          //RClickReferencePointOperation_Wrapper* wrapper = dynamic_cast<RClickReferencePointOperation_Wrapper*>(obj);
          //RClickReferencePointOperation_Wrapper* wrapper = (RClickReferencePointOperation_Wrapper*)(obj);
          //RClickReferencePointOperation_Wrapper* wrapper = getWrapper<RClickReferencePointOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RClickReferencePointOperation_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RClickReferencePointOperation(wrapper);
          return RClickReferencePointOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RClickReferencePointOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RClickReferencePointOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RClickReferencePointOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RClipboardOperation(RJSApi& handler, RClipboardOperation* v) {

          
            // downcast to RCopyOperation:
            {
                RCopyOperation* o = dynamic_cast<RCopyOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RCopyOperation(handler, o);
                }
            }
          
            // downcast to RDeleteSelectionOperation:
            {
                RDeleteSelectionOperation* o = dynamic_cast<RDeleteSelectionOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDeleteSelectionOperation(handler, o);
                }
            }
          
            // downcast to RPasteOperation:
            {
                RPasteOperation* o = dynamic_cast<RPasteOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RPasteOperation(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RClipboardOperation_Wrapper* ret = new RClipboardOperation_Wrapper(handler, v, false);

          // JS: new RClipboardOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RClipboardOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RClipboardOperation is undefined. Use RClipboardOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RClipboardOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RClipboardOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RClipboardOperation* RJSHelper_qcad::js2cpp_RClipboardOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RClipboardOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RClipboardOperation_Wrapper* wrapper = qobject_cast<RClipboardOperation_Wrapper*>(obj);
          //RClipboardOperation_Wrapper* wrapper = dynamic_cast<RClipboardOperation_Wrapper*>(obj);
          //RClipboardOperation_Wrapper* wrapper = (RClipboardOperation_Wrapper*)(obj);
          //RClipboardOperation_Wrapper* wrapper = getWrapper<RClipboardOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RClipboardOperation_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RClipboardOperation(wrapper);
          return RClipboardOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RClipboardOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RClipboardOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RClipboardOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RCloseCurrentEvent(RJSApi& handler, RCloseCurrentEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          RCloseCurrentEvent_Wrapper* ret = new RCloseCurrentEvent_Wrapper(handler, v, false);

          // JS: new RCloseCurrentEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCloseCurrentEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class RCloseCurrentEvent is undefined. Use RCloseCurrentEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCloseCurrentEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCloseCurrentEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RCloseCurrentEvent* RJSHelper_qcad::js2cpp_RCloseCurrentEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RCloseCurrentEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RCloseCurrentEvent_Wrapper* wrapper = qobject_cast<RCloseCurrentEvent_Wrapper*>(obj);
          //RCloseCurrentEvent_Wrapper* wrapper = dynamic_cast<RCloseCurrentEvent_Wrapper*>(obj);
          //RCloseCurrentEvent_Wrapper* wrapper = (RCloseCurrentEvent_Wrapper*)(obj);
          //RCloseCurrentEvent_Wrapper* wrapper = getWrapper<RCloseCurrentEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCloseCurrentEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RCloseCurrentEvent(wrapper);
          return RCloseCurrentEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RCloseCurrentEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RCloseCurrentEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RCloseCurrentEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RCommandEvent(RJSApi& handler, RCommandEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          RCommandEvent_Wrapper* ret = new RCommandEvent_Wrapper(handler, v, false);

          // JS: new RCommandEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCommandEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class RCommandEvent is undefined. Use RCommandEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCommandEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCommandEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RCommandEvent* RJSHelper_qcad::js2cpp_RCommandEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RCommandEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RCommandEvent_Wrapper* wrapper = qobject_cast<RCommandEvent_Wrapper*>(obj);
          //RCommandEvent_Wrapper* wrapper = dynamic_cast<RCommandEvent_Wrapper*>(obj);
          //RCommandEvent_Wrapper* wrapper = (RCommandEvent_Wrapper*)(obj);
          //RCommandEvent_Wrapper* wrapper = getWrapper<RCommandEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCommandEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RCommandEvent(wrapper);
          return RCommandEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RCommandEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RCommandEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RCommandEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RCoordinateEvent(RJSApi& handler, RCoordinateEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          RCoordinateEvent_Wrapper* ret = new RCoordinateEvent_Wrapper(handler, v, false);

          // JS: new RCoordinateEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCoordinateEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class RCoordinateEvent is undefined. Use RCoordinateEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCoordinateEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCoordinateEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RCoordinateEvent* RJSHelper_qcad::js2cpp_RCoordinateEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RCoordinateEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RCoordinateEvent_Wrapper* wrapper = qobject_cast<RCoordinateEvent_Wrapper*>(obj);
          //RCoordinateEvent_Wrapper* wrapper = dynamic_cast<RCoordinateEvent_Wrapper*>(obj);
          //RCoordinateEvent_Wrapper* wrapper = (RCoordinateEvent_Wrapper*)(obj);
          //RCoordinateEvent_Wrapper* wrapper = getWrapper<RCoordinateEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCoordinateEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RCoordinateEvent(wrapper);
          return RCoordinateEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RCoordinateEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RCoordinateEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RCoordinateEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RCoordinateListener(RJSApi& handler, RCoordinateListener* v) {

          
            // downcast to RCoordinateListenerAdapter:
            {
                RCoordinateListenerAdapter* o = dynamic_cast<RCoordinateListenerAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RCoordinateListenerAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RCoordinateListener_Wrapper* ret = new RCoordinateListener_Wrapper(handler, v, false);

          // JS: new RCoordinateListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCoordinateListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RCoordinateListener is undefined. Use RCoordinateListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCoordinateListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCoordinateListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RCoordinateListener* RJSHelper_qcad::js2cpp_RCoordinateListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RCoordinateListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RCoordinateListener_Wrapper* wrapper = qobject_cast<RCoordinateListener_Wrapper*>(obj);
          //RCoordinateListener_Wrapper* wrapper = dynamic_cast<RCoordinateListener_Wrapper*>(obj);
          //RCoordinateListener_Wrapper* wrapper = (RCoordinateListener_Wrapper*)(obj);
          //RCoordinateListener_Wrapper* wrapper = getWrapper<RCoordinateListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCoordinateListener_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RCoordinateListener(wrapper);
          return RCoordinateListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RCoordinateListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RCoordinateListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RCoordinateListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RCopyOperation(RJSApi& handler, RCopyOperation* v) {

          

          QJSEngine* engine = handler.getEngine();
          RCopyOperation_Wrapper* ret = new RCopyOperation_Wrapper(handler, v, false);

          // JS: new RCopyOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCopyOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RCopyOperation is undefined. Use RCopyOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCopyOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCopyOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RCopyOperation* RJSHelper_qcad::js2cpp_RCopyOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RCopyOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RCopyOperation_Wrapper* wrapper = qobject_cast<RCopyOperation_Wrapper*>(obj);
          //RCopyOperation_Wrapper* wrapper = dynamic_cast<RCopyOperation_Wrapper*>(obj);
          //RCopyOperation_Wrapper* wrapper = (RCopyOperation_Wrapper*)(obj);
          //RCopyOperation_Wrapper* wrapper = getWrapper<RCopyOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCopyOperation_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RCopyOperation(wrapper);
          return RCopyOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RCopyOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RCopyOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RCopyOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDeleteAllEntitiesOperation(RJSApi& handler, RDeleteAllEntitiesOperation* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDeleteAllEntitiesOperation_Wrapper* ret = new RDeleteAllEntitiesOperation_Wrapper(handler, v, false);

          // JS: new RDeleteAllEntitiesOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDeleteAllEntitiesOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RDeleteAllEntitiesOperation is undefined. Use RDeleteAllEntitiesOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDeleteAllEntitiesOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDeleteAllEntitiesOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDeleteAllEntitiesOperation* RJSHelper_qcad::js2cpp_RDeleteAllEntitiesOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDeleteAllEntitiesOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDeleteAllEntitiesOperation_Wrapper* wrapper = qobject_cast<RDeleteAllEntitiesOperation_Wrapper*>(obj);
          //RDeleteAllEntitiesOperation_Wrapper* wrapper = dynamic_cast<RDeleteAllEntitiesOperation_Wrapper*>(obj);
          //RDeleteAllEntitiesOperation_Wrapper* wrapper = (RDeleteAllEntitiesOperation_Wrapper*)(obj);
          //RDeleteAllEntitiesOperation_Wrapper* wrapper = getWrapper<RDeleteAllEntitiesOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDeleteAllEntitiesOperation_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RDeleteAllEntitiesOperation(wrapper);
          return RDeleteAllEntitiesOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDeleteAllEntitiesOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDeleteAllEntitiesOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDeleteAllEntitiesOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDeleteObjectOperation(RJSApi& handler, RDeleteObjectOperation* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDeleteObjectOperation_Wrapper* ret = new RDeleteObjectOperation_Wrapper(handler, v, false);

          // JS: new RDeleteObjectOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDeleteObjectOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RDeleteObjectOperation is undefined. Use RDeleteObjectOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDeleteObjectOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDeleteObjectOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDeleteObjectOperation* RJSHelper_qcad::js2cpp_RDeleteObjectOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDeleteObjectOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDeleteObjectOperation_Wrapper* wrapper = qobject_cast<RDeleteObjectOperation_Wrapper*>(obj);
          //RDeleteObjectOperation_Wrapper* wrapper = dynamic_cast<RDeleteObjectOperation_Wrapper*>(obj);
          //RDeleteObjectOperation_Wrapper* wrapper = (RDeleteObjectOperation_Wrapper*)(obj);
          //RDeleteObjectOperation_Wrapper* wrapper = getWrapper<RDeleteObjectOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDeleteObjectOperation_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RDeleteObjectOperation(wrapper);
          return RDeleteObjectOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDeleteObjectOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDeleteObjectOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDeleteObjectOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDeleteObjectsOperation(RJSApi& handler, RDeleteObjectsOperation* v) {

          
            // downcast to RDeleteObjectOperation:
            {
                RDeleteObjectOperation* o = dynamic_cast<RDeleteObjectOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDeleteObjectOperation(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RDeleteObjectsOperation_Wrapper* ret = new RDeleteObjectsOperation_Wrapper(handler, v, false);

          // JS: new RDeleteObjectsOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDeleteObjectsOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RDeleteObjectsOperation is undefined. Use RDeleteObjectsOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDeleteObjectsOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDeleteObjectsOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDeleteObjectsOperation* RJSHelper_qcad::js2cpp_RDeleteObjectsOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDeleteObjectsOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDeleteObjectsOperation_Wrapper* wrapper = qobject_cast<RDeleteObjectsOperation_Wrapper*>(obj);
          //RDeleteObjectsOperation_Wrapper* wrapper = dynamic_cast<RDeleteObjectsOperation_Wrapper*>(obj);
          //RDeleteObjectsOperation_Wrapper* wrapper = (RDeleteObjectsOperation_Wrapper*)(obj);
          //RDeleteObjectsOperation_Wrapper* wrapper = getWrapper<RDeleteObjectsOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDeleteObjectsOperation_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RDeleteObjectsOperation(wrapper);
          return RDeleteObjectsOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDeleteObjectsOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDeleteObjectsOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDeleteObjectsOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDeleteSelectionOperation(RJSApi& handler, RDeleteSelectionOperation* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDeleteSelectionOperation_Wrapper* ret = new RDeleteSelectionOperation_Wrapper(handler, v, false);

          // JS: new RDeleteSelectionOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDeleteSelectionOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RDeleteSelectionOperation is undefined. Use RDeleteSelectionOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDeleteSelectionOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDeleteSelectionOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDeleteSelectionOperation* RJSHelper_qcad::js2cpp_RDeleteSelectionOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDeleteSelectionOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDeleteSelectionOperation_Wrapper* wrapper = qobject_cast<RDeleteSelectionOperation_Wrapper*>(obj);
          //RDeleteSelectionOperation_Wrapper* wrapper = dynamic_cast<RDeleteSelectionOperation_Wrapper*>(obj);
          //RDeleteSelectionOperation_Wrapper* wrapper = (RDeleteSelectionOperation_Wrapper*)(obj);
          //RDeleteSelectionOperation_Wrapper* wrapper = getWrapper<RDeleteSelectionOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDeleteSelectionOperation_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RDeleteSelectionOperation(wrapper);
          return RDeleteSelectionOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDeleteSelectionOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDeleteSelectionOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDeleteSelectionOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimAlignedEntity(RJSApi& handler, RDimAlignedEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDimAlignedEntity_Wrapper* ret = new RDimAlignedEntity_Wrapper(handler, v, false);

          // JS: new RDimAlignedEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAlignedEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAlignedEntity is undefined. Use RDimAlignedEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimAlignedEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimAlignedEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimAlignedEntity* RJSHelper_qcad::js2cpp_RDimAlignedEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimAlignedEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimAlignedEntity_Wrapper* wrapper = qobject_cast<RDimAlignedEntity_Wrapper*>(obj);
          //RDimAlignedEntity_Wrapper* wrapper = dynamic_cast<RDimAlignedEntity_Wrapper*>(obj);
          //RDimAlignedEntity_Wrapper* wrapper = (RDimAlignedEntity_Wrapper*)(obj);
          //RDimAlignedEntity_Wrapper* wrapper = getWrapper<RDimAlignedEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimAlignedEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RDimAlignedEntity(wrapper);
          return RDimAlignedEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimAlignedEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimAlignedEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimAlignedEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimAngular2LEntity(RJSApi& handler, RDimAngular2LEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDimAngular2LEntity_Wrapper* ret = new RDimAngular2LEntity_Wrapper(handler, v, false);

          // JS: new RDimAngular2LEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAngular2LEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAngular2LEntity is undefined. Use RDimAngular2LEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimAngular2LEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimAngular2LEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimAngular2LEntity* RJSHelper_qcad::js2cpp_RDimAngular2LEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimAngular2LEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimAngular2LEntity_Wrapper* wrapper = qobject_cast<RDimAngular2LEntity_Wrapper*>(obj);
          //RDimAngular2LEntity_Wrapper* wrapper = dynamic_cast<RDimAngular2LEntity_Wrapper*>(obj);
          //RDimAngular2LEntity_Wrapper* wrapper = (RDimAngular2LEntity_Wrapper*)(obj);
          //RDimAngular2LEntity_Wrapper* wrapper = getWrapper<RDimAngular2LEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimAngular2LEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RDimAngular2LEntity(wrapper);
          return RDimAngular2LEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimAngular2LEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimAngular2LEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimAngular2LEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimAngular3PEntity(RJSApi& handler, RDimAngular3PEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDimAngular3PEntity_Wrapper* ret = new RDimAngular3PEntity_Wrapper(handler, v, false);

          // JS: new RDimAngular3PEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAngular3PEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAngular3PEntity is undefined. Use RDimAngular3PEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimAngular3PEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimAngular3PEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimAngular3PEntity* RJSHelper_qcad::js2cpp_RDimAngular3PEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimAngular3PEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimAngular3PEntity_Wrapper* wrapper = qobject_cast<RDimAngular3PEntity_Wrapper*>(obj);
          //RDimAngular3PEntity_Wrapper* wrapper = dynamic_cast<RDimAngular3PEntity_Wrapper*>(obj);
          //RDimAngular3PEntity_Wrapper* wrapper = (RDimAngular3PEntity_Wrapper*)(obj);
          //RDimAngular3PEntity_Wrapper* wrapper = getWrapper<RDimAngular3PEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimAngular3PEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RDimAngular3PEntity(wrapper);
          return RDimAngular3PEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimAngular3PEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimAngular3PEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimAngular3PEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimAngularData(RJSApi& handler, RDimAngularData* v) {

          
            // downcast to RDimAngular2LData:
            {
                RDimAngular2LData* o = dynamic_cast<RDimAngular2LData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimAngular2LData(handler, o);
                }
            }
          
            // downcast to RDimAngular3PData:
            {
                RDimAngular3PData* o = dynamic_cast<RDimAngular3PData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimAngular3PData(handler, o);
                }
            }
          
            // downcast to RDimArcLengthData:
            {
                RDimArcLengthData* o = dynamic_cast<RDimArcLengthData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimArcLengthData(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RDimAngularData_Wrapper* ret = new RDimAngularData_Wrapper(handler, v, false);

          // JS: new RDimAngularData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAngularData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAngularData is undefined. Use RDimAngularData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimAngularData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimAngularData(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimAngularData* RJSHelper_qcad::js2cpp_RDimAngularData_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimAngularData: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimAngularData_Wrapper* wrapper = qobject_cast<RDimAngularData_Wrapper*>(obj);
          //RDimAngularData_Wrapper* wrapper = dynamic_cast<RDimAngularData_Wrapper*>(obj);
          //RDimAngularData_Wrapper* wrapper = (RDimAngularData_Wrapper*)(obj);
          //RDimAngularData_Wrapper* wrapper = getWrapper<RDimAngularData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimAngularData_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RDimAngularData(wrapper);
          return RDimAngularData_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimAngularData_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimAngularData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimAngularData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimAngularEntity(RJSApi& handler, RDimAngularEntity* v) {

          
            // downcast to RDimAngular2LEntity:
            {
                RDimAngular2LEntity* o = dynamic_cast<RDimAngular2LEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimAngular2LEntity(handler, o);
                }
            }
          
            // downcast to RDimAngular3PEntity:
            {
                RDimAngular3PEntity* o = dynamic_cast<RDimAngular3PEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimAngular3PEntity(handler, o);
                }
            }
          
            // downcast to RDimArcLengthEntity:
            {
                RDimArcLengthEntity* o = dynamic_cast<RDimArcLengthEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimArcLengthEntity(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RDimAngularEntity_Wrapper* ret = new RDimAngularEntity_Wrapper(handler, v, false);

          // JS: new RDimAngularEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAngularEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAngularEntity is undefined. Use RDimAngularEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimAngularEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimAngularEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimAngularEntity* RJSHelper_qcad::js2cpp_RDimAngularEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimAngularEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimAngularEntity_Wrapper* wrapper = qobject_cast<RDimAngularEntity_Wrapper*>(obj);
          //RDimAngularEntity_Wrapper* wrapper = dynamic_cast<RDimAngularEntity_Wrapper*>(obj);
          //RDimAngularEntity_Wrapper* wrapper = (RDimAngularEntity_Wrapper*)(obj);
          //RDimAngularEntity_Wrapper* wrapper = getWrapper<RDimAngularEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimAngularEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RDimAngularEntity(wrapper);
          return RDimAngularEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimAngularEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimAngularEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimAngularEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimArcLengthEntity(RJSApi& handler, RDimArcLengthEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDimArcLengthEntity_Wrapper* ret = new RDimArcLengthEntity_Wrapper(handler, v, false);

          // JS: new RDimArcLengthEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimArcLengthEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimArcLengthEntity is undefined. Use RDimArcLengthEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimArcLengthEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimArcLengthEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimArcLengthEntity* RJSHelper_qcad::js2cpp_RDimArcLengthEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimArcLengthEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimArcLengthEntity_Wrapper* wrapper = qobject_cast<RDimArcLengthEntity_Wrapper*>(obj);
          //RDimArcLengthEntity_Wrapper* wrapper = dynamic_cast<RDimArcLengthEntity_Wrapper*>(obj);
          //RDimArcLengthEntity_Wrapper* wrapper = (RDimArcLengthEntity_Wrapper*)(obj);
          //RDimArcLengthEntity_Wrapper* wrapper = getWrapper<RDimArcLengthEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimArcLengthEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RDimArcLengthEntity(wrapper);
          return RDimArcLengthEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimArcLengthEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimArcLengthEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimArcLengthEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimDiametricEntity(RJSApi& handler, RDimDiametricEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDimDiametricEntity_Wrapper* ret = new RDimDiametricEntity_Wrapper(handler, v, false);

          // JS: new RDimDiametricEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimDiametricEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimDiametricEntity is undefined. Use RDimDiametricEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimDiametricEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimDiametricEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimDiametricEntity* RJSHelper_qcad::js2cpp_RDimDiametricEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimDiametricEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimDiametricEntity_Wrapper* wrapper = qobject_cast<RDimDiametricEntity_Wrapper*>(obj);
          //RDimDiametricEntity_Wrapper* wrapper = dynamic_cast<RDimDiametricEntity_Wrapper*>(obj);
          //RDimDiametricEntity_Wrapper* wrapper = (RDimDiametricEntity_Wrapper*)(obj);
          //RDimDiametricEntity_Wrapper* wrapper = getWrapper<RDimDiametricEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimDiametricEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RDimDiametricEntity(wrapper);
          return RDimDiametricEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimDiametricEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimDiametricEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimDiametricEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimLinearEntity(RJSApi& handler, RDimLinearEntity* v) {

          
            // downcast to RDimAlignedEntity:
            {
                RDimAlignedEntity* o = dynamic_cast<RDimAlignedEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimAlignedEntity(handler, o);
                }
            }
          
            // downcast to RDimRotatedEntity:
            {
                RDimRotatedEntity* o = dynamic_cast<RDimRotatedEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimRotatedEntity(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RDimLinearEntity_Wrapper* ret = new RDimLinearEntity_Wrapper(handler, v, false);

          // JS: new RDimLinearEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimLinearEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimLinearEntity is undefined. Use RDimLinearEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimLinearEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimLinearEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimLinearEntity* RJSHelper_qcad::js2cpp_RDimLinearEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimLinearEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimLinearEntity_Wrapper* wrapper = qobject_cast<RDimLinearEntity_Wrapper*>(obj);
          //RDimLinearEntity_Wrapper* wrapper = dynamic_cast<RDimLinearEntity_Wrapper*>(obj);
          //RDimLinearEntity_Wrapper* wrapper = (RDimLinearEntity_Wrapper*)(obj);
          //RDimLinearEntity_Wrapper* wrapper = getWrapper<RDimLinearEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimLinearEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RDimLinearEntity(wrapper);
          return RDimLinearEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimLinearEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimLinearEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimLinearEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimOrdinateEntity(RJSApi& handler, RDimOrdinateEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDimOrdinateEntity_Wrapper* ret = new RDimOrdinateEntity_Wrapper(handler, v, false);

          // JS: new RDimOrdinateEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimOrdinateEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimOrdinateEntity is undefined. Use RDimOrdinateEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimOrdinateEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimOrdinateEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimOrdinateEntity* RJSHelper_qcad::js2cpp_RDimOrdinateEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimOrdinateEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimOrdinateEntity_Wrapper* wrapper = qobject_cast<RDimOrdinateEntity_Wrapper*>(obj);
          //RDimOrdinateEntity_Wrapper* wrapper = dynamic_cast<RDimOrdinateEntity_Wrapper*>(obj);
          //RDimOrdinateEntity_Wrapper* wrapper = (RDimOrdinateEntity_Wrapper*)(obj);
          //RDimOrdinateEntity_Wrapper* wrapper = getWrapper<RDimOrdinateEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimOrdinateEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RDimOrdinateEntity(wrapper);
          return RDimOrdinateEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimOrdinateEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimOrdinateEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimOrdinateEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimRadialEntity(RJSApi& handler, RDimRadialEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDimRadialEntity_Wrapper* ret = new RDimRadialEntity_Wrapper(handler, v, false);

          // JS: new RDimRadialEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimRadialEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimRadialEntity is undefined. Use RDimRadialEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimRadialEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimRadialEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimRadialEntity* RJSHelper_qcad::js2cpp_RDimRadialEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimRadialEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimRadialEntity_Wrapper* wrapper = qobject_cast<RDimRadialEntity_Wrapper*>(obj);
          //RDimRadialEntity_Wrapper* wrapper = dynamic_cast<RDimRadialEntity_Wrapper*>(obj);
          //RDimRadialEntity_Wrapper* wrapper = (RDimRadialEntity_Wrapper*)(obj);
          //RDimRadialEntity_Wrapper* wrapper = getWrapper<RDimRadialEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimRadialEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RDimRadialEntity(wrapper);
          return RDimRadialEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimRadialEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimRadialEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimRadialEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimRotatedEntity(RJSApi& handler, RDimRotatedEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDimRotatedEntity_Wrapper* ret = new RDimRotatedEntity_Wrapper(handler, v, false);

          // JS: new RDimRotatedEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimRotatedEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimRotatedEntity is undefined. Use RDimRotatedEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimRotatedEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimRotatedEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimRotatedEntity* RJSHelper_qcad::js2cpp_RDimRotatedEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimRotatedEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimRotatedEntity_Wrapper* wrapper = qobject_cast<RDimRotatedEntity_Wrapper*>(obj);
          //RDimRotatedEntity_Wrapper* wrapper = dynamic_cast<RDimRotatedEntity_Wrapper*>(obj);
          //RDimRotatedEntity_Wrapper* wrapper = (RDimRotatedEntity_Wrapper*)(obj);
          //RDimRotatedEntity_Wrapper* wrapper = getWrapper<RDimRotatedEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimRotatedEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RDimRotatedEntity(wrapper);
          return RDimRotatedEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimRotatedEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimRotatedEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimRotatedEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimStyle(RJSApi& handler, RDimStyle* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDimStyle_Wrapper* ret = new RDimStyle_Wrapper(handler, v, false);

          // JS: new RDimStyle('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimStyle");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimStyle is undefined. Use RDimStyle_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimStyle('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimStyle(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimStyle* RJSHelper_qcad::js2cpp_RDimStyle_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimStyle: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimStyle_Wrapper* wrapper = qobject_cast<RDimStyle_Wrapper*>(obj);
          //RDimStyle_Wrapper* wrapper = dynamic_cast<RDimStyle_Wrapper*>(obj);
          //RDimStyle_Wrapper* wrapper = (RDimStyle_Wrapper*)(obj);
          //RDimStyle_Wrapper* wrapper = getWrapper<RDimStyle_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimStyle_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RDimStyle(wrapper);
          return RDimStyle_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimStyle_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimStyle: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimStyle::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimensionData(RJSApi& handler, RDimensionData* v) {

          
            // downcast to RDimAngularData:
            {
                RDimAngularData* o = dynamic_cast<RDimAngularData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimAngularData(handler, o);
                }
            }
          
            // downcast to RDimDiametricData:
            {
                RDimDiametricData* o = dynamic_cast<RDimDiametricData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimDiametricData(handler, o);
                }
            }
          
            // downcast to RDimLinearData:
            {
                RDimLinearData* o = dynamic_cast<RDimLinearData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimLinearData(handler, o);
                }
            }
          
            // downcast to RDimOrdinateData:
            {
                RDimOrdinateData* o = dynamic_cast<RDimOrdinateData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimOrdinateData(handler, o);
                }
            }
          
            // downcast to RDimRadialData:
            {
                RDimRadialData* o = dynamic_cast<RDimRadialData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimRadialData(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RDimensionData_Wrapper* ret = new RDimensionData_Wrapper(handler, v, false);

          // JS: new RDimensionData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimensionData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimensionData is undefined. Use RDimensionData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimensionData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimensionData(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimensionData* RJSHelper_qcad::js2cpp_RDimensionData_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimensionData: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimensionData_Wrapper* wrapper = qobject_cast<RDimensionData_Wrapper*>(obj);
          //RDimensionData_Wrapper* wrapper = dynamic_cast<RDimensionData_Wrapper*>(obj);
          //RDimensionData_Wrapper* wrapper = (RDimensionData_Wrapper*)(obj);
          //RDimensionData_Wrapper* wrapper = getWrapper<RDimensionData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimensionData_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RDimensionData(wrapper);
          return RDimensionData_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimensionData_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimensionData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimensionData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimLinearData(RJSApi& handler, RDimLinearData* v) {

          
            // downcast to RDimAlignedData:
            {
                RDimAlignedData* o = dynamic_cast<RDimAlignedData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimAlignedData(handler, o);
                }
            }
          
            // downcast to RDimRotatedData:
            {
                RDimRotatedData* o = dynamic_cast<RDimRotatedData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimRotatedData(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RDimLinearData_Wrapper* ret = new RDimLinearData_Wrapper(handler, v, false);

          // JS: new RDimLinearData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimLinearData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimLinearData is undefined. Use RDimLinearData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimLinearData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimLinearData(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimLinearData* RJSHelper_qcad::js2cpp_RDimLinearData_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimLinearData: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimLinearData_Wrapper* wrapper = qobject_cast<RDimLinearData_Wrapper*>(obj);
          //RDimLinearData_Wrapper* wrapper = dynamic_cast<RDimLinearData_Wrapper*>(obj);
          //RDimLinearData_Wrapper* wrapper = (RDimLinearData_Wrapper*)(obj);
          //RDimLinearData_Wrapper* wrapper = getWrapper<RDimLinearData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimLinearData_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RDimLinearData(wrapper);
          return RDimLinearData_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimLinearData_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimLinearData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimLinearData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimensionEntity(RJSApi& handler, RDimensionEntity* v) {

          
            // downcast to RDimAlignedEntity:
            {
                RDimAlignedEntity* o = dynamic_cast<RDimAlignedEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimAlignedEntity(handler, o);
                }
            }
          
            // downcast to RDimAngular2LEntity:
            {
                RDimAngular2LEntity* o = dynamic_cast<RDimAngular2LEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimAngular2LEntity(handler, o);
                }
            }
          
            // downcast to RDimAngular3PEntity:
            {
                RDimAngular3PEntity* o = dynamic_cast<RDimAngular3PEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimAngular3PEntity(handler, o);
                }
            }
          
            // downcast to RDimAngularEntity:
            {
                RDimAngularEntity* o = dynamic_cast<RDimAngularEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimAngularEntity(handler, o);
                }
            }
          
            // downcast to RDimArcLengthEntity:
            {
                RDimArcLengthEntity* o = dynamic_cast<RDimArcLengthEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimArcLengthEntity(handler, o);
                }
            }
          
            // downcast to RDimDiametricEntity:
            {
                RDimDiametricEntity* o = dynamic_cast<RDimDiametricEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimDiametricEntity(handler, o);
                }
            }
          
            // downcast to RDimLinearEntity:
            {
                RDimLinearEntity* o = dynamic_cast<RDimLinearEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimLinearEntity(handler, o);
                }
            }
          
            // downcast to RDimOrdinateEntity:
            {
                RDimOrdinateEntity* o = dynamic_cast<RDimOrdinateEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimOrdinateEntity(handler, o);
                }
            }
          
            // downcast to RDimRadialEntity:
            {
                RDimRadialEntity* o = dynamic_cast<RDimRadialEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimRadialEntity(handler, o);
                }
            }
          
            // downcast to RDimRotatedEntity:
            {
                RDimRotatedEntity* o = dynamic_cast<RDimRotatedEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimRotatedEntity(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RDimensionEntity_Wrapper* ret = new RDimensionEntity_Wrapper(handler, v, false);

          // JS: new RDimensionEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimensionEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimensionEntity is undefined. Use RDimensionEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimensionEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimensionEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDimensionEntity* RJSHelper_qcad::js2cpp_RDimensionEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimensionEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDimensionEntity_Wrapper* wrapper = qobject_cast<RDimensionEntity_Wrapper*>(obj);
          //RDimensionEntity_Wrapper* wrapper = dynamic_cast<RDimensionEntity_Wrapper*>(obj);
          //RDimensionEntity_Wrapper* wrapper = (RDimensionEntity_Wrapper*)(obj);
          //RDimensionEntity_Wrapper* wrapper = getWrapper<RDimensionEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimensionEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RDimensionEntity(wrapper);
          return RDimensionEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDimensionEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimensionEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDimensionEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDirected(RJSApi& handler, RDirected* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDirected_Wrapper* ret = new RDirected_Wrapper(handler, v, false);

          // JS: new RDirected('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDirected");
          if (cl.isUndefined()) {
              qWarning() << "Class RDirected is undefined. Use RDirected_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDirected('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDirected(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDirected* RJSHelper_qcad::js2cpp_RDirected_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDirected: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDirected_Wrapper* wrapper = qobject_cast<RDirected_Wrapper*>(obj);
          //RDirected_Wrapper* wrapper = dynamic_cast<RDirected_Wrapper*>(obj);
          //RDirected_Wrapper* wrapper = (RDirected_Wrapper*)(obj);
          //RDirected_Wrapper* wrapper = getWrapper<RDirected_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDirected_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RDirected(wrapper);
          return RDirected_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDirected_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDirected: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDirected::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDocument(RJSApi& handler, RDocument* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDocument_Wrapper* ret = new RDocument_Wrapper(handler, v, false);

          // JS: new RDocument('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDocument");
          if (cl.isUndefined()) {
              qWarning() << "Class RDocument is undefined. Use RDocument_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDocument('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDocument(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDocument* RJSHelper_qcad::js2cpp_RDocument_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDocument: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDocument_Wrapper* wrapper = qobject_cast<RDocument_Wrapper*>(obj);
          //RDocument_Wrapper* wrapper = dynamic_cast<RDocument_Wrapper*>(obj);
          //RDocument_Wrapper* wrapper = (RDocument_Wrapper*)(obj);
          //RDocument_Wrapper* wrapper = getWrapper<RDocument_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDocument_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RDocument(wrapper);
          return RDocument_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDocument_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDocument: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDocument::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDocumentInterface(RJSApi& handler, RDocumentInterface* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDocumentInterface_Wrapper* ret = new RDocumentInterface_Wrapper(handler, v, false);

          // JS: new RDocumentInterface('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDocumentInterface");
          if (cl.isUndefined()) {
              qWarning() << "Class RDocumentInterface is undefined. Use RDocumentInterface_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDocumentInterface('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDocumentInterface(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDocumentInterface* RJSHelper_qcad::js2cpp_RDocumentInterface_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDocumentInterface: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDocumentInterface_Wrapper* wrapper = qobject_cast<RDocumentInterface_Wrapper*>(obj);
          //RDocumentInterface_Wrapper* wrapper = dynamic_cast<RDocumentInterface_Wrapper*>(obj);
          //RDocumentInterface_Wrapper* wrapper = (RDocumentInterface_Wrapper*)(obj);
          //RDocumentInterface_Wrapper* wrapper = getWrapper<RDocumentInterface_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDocumentInterface_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RDocumentInterface(wrapper);
          return RDocumentInterface_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDocumentInterface_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDocumentInterface: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDocumentInterface::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDocumentVariables(RJSApi& handler, RDocumentVariables* v) {

          

          QJSEngine* engine = handler.getEngine();
          RDocumentVariables_Wrapper* ret = new RDocumentVariables_Wrapper(handler, v, false);

          // JS: new RDocumentVariables('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDocumentVariables");
          if (cl.isUndefined()) {
              qWarning() << "Class RDocumentVariables is undefined. Use RDocumentVariables_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDocumentVariables('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDocumentVariables(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RDocumentVariables* RJSHelper_qcad::js2cpp_RDocumentVariables_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDocumentVariables: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDocumentVariables_Wrapper* wrapper = qobject_cast<RDocumentVariables_Wrapper*>(obj);
          //RDocumentVariables_Wrapper* wrapper = dynamic_cast<RDocumentVariables_Wrapper*>(obj);
          //RDocumentVariables_Wrapper* wrapper = (RDocumentVariables_Wrapper*)(obj);
          //RDocumentVariables_Wrapper* wrapper = getWrapper<RDocumentVariables_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDocumentVariables_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RDocumentVariables(wrapper);
          return RDocumentVariables_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDocumentVariables_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDocumentVariables: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RDocumentVariables::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_REllipseEntity(RJSApi& handler, REllipseEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          REllipseEntity_Wrapper* ret = new REllipseEntity_Wrapper(handler, v, false);

          // JS: new REllipseEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("REllipseEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class REllipseEntity is undefined. Use REllipseEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new REllipseEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new REllipseEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      REllipseEntity* RJSHelper_qcad::js2cpp_REllipseEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_REllipseEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //REllipseEntity_Wrapper* wrapper = qobject_cast<REllipseEntity_Wrapper*>(obj);
          //REllipseEntity_Wrapper* wrapper = dynamic_cast<REllipseEntity_Wrapper*>(obj);
          //REllipseEntity_Wrapper* wrapper = (REllipseEntity_Wrapper*)(obj);
          //REllipseEntity_Wrapper* wrapper = getWrapper<REllipseEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_REllipseEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_REllipseEntity(wrapper);
          return REllipseEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_REllipseEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_REllipseEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_REllipseEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_REntity(RJSApi& handler, REntity* v) {

          
            // downcast to RArcEntity:
            {
                RArcEntity* o = dynamic_cast<RArcEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RArcEntity(handler, o);
                }
            }
          
            // downcast to RAttributeDefinitionEntity:
            {
                RAttributeDefinitionEntity* o = dynamic_cast<RAttributeDefinitionEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RAttributeDefinitionEntity(handler, o);
                }
            }
          
            // downcast to RAttributeEntity:
            {
                RAttributeEntity* o = dynamic_cast<RAttributeEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RAttributeEntity(handler, o);
                }
            }
          
            // downcast to RBlockReferenceEntity:
            {
                RBlockReferenceEntity* o = dynamic_cast<RBlockReferenceEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RBlockReferenceEntity(handler, o);
                }
            }
          
            // downcast to RCircleEntity:
            {
                RCircleEntity* o = dynamic_cast<RCircleEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RCircleEntity(handler, o);
                }
            }
          
            // downcast to RDimAlignedEntity:
            {
                RDimAlignedEntity* o = dynamic_cast<RDimAlignedEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimAlignedEntity(handler, o);
                }
            }
          
            // downcast to RDimAngular2LEntity:
            {
                RDimAngular2LEntity* o = dynamic_cast<RDimAngular2LEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimAngular2LEntity(handler, o);
                }
            }
          
            // downcast to RDimAngular3PEntity:
            {
                RDimAngular3PEntity* o = dynamic_cast<RDimAngular3PEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimAngular3PEntity(handler, o);
                }
            }
          
            // downcast to RDimAngularEntity:
            {
                RDimAngularEntity* o = dynamic_cast<RDimAngularEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimAngularEntity(handler, o);
                }
            }
          
            // downcast to RDimArcLengthEntity:
            {
                RDimArcLengthEntity* o = dynamic_cast<RDimArcLengthEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimArcLengthEntity(handler, o);
                }
            }
          
            // downcast to RDimDiametricEntity:
            {
                RDimDiametricEntity* o = dynamic_cast<RDimDiametricEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimDiametricEntity(handler, o);
                }
            }
          
            // downcast to RDimLinearEntity:
            {
                RDimLinearEntity* o = dynamic_cast<RDimLinearEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimLinearEntity(handler, o);
                }
            }
          
            // downcast to RDimOrdinateEntity:
            {
                RDimOrdinateEntity* o = dynamic_cast<RDimOrdinateEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimOrdinateEntity(handler, o);
                }
            }
          
            // downcast to RDimRadialEntity:
            {
                RDimRadialEntity* o = dynamic_cast<RDimRadialEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimRadialEntity(handler, o);
                }
            }
          
            // downcast to RDimRotatedEntity:
            {
                RDimRotatedEntity* o = dynamic_cast<RDimRotatedEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimRotatedEntity(handler, o);
                }
            }
          
            // downcast to RDimensionEntity:
            {
                RDimensionEntity* o = dynamic_cast<RDimensionEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimensionEntity(handler, o);
                }
            }
          
            // downcast to REllipseEntity:
            {
                REllipseEntity* o = dynamic_cast<REllipseEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_REllipseEntity(handler, o);
                }
            }
          
            // downcast to RFaceEntity:
            {
                RFaceEntity* o = dynamic_cast<RFaceEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RFaceEntity(handler, o);
                }
            }
          
            // downcast to RHatchEntity:
            {
                RHatchEntity* o = dynamic_cast<RHatchEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RHatchEntity(handler, o);
                }
            }
          
            // downcast to RImageEntity:
            {
                RImageEntity* o = dynamic_cast<RImageEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RImageEntity(handler, o);
                }
            }
          
            // downcast to RLeaderEntity:
            {
                RLeaderEntity* o = dynamic_cast<RLeaderEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RLeaderEntity(handler, o);
                }
            }
          
            // downcast to RLineEntity:
            {
                RLineEntity* o = dynamic_cast<RLineEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RLineEntity(handler, o);
                }
            }
          
            // downcast to RPointEntity:
            {
                RPointEntity* o = dynamic_cast<RPointEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RPointEntity(handler, o);
                }
            }
          
            // downcast to RPolylineEntity:
            {
                RPolylineEntity* o = dynamic_cast<RPolylineEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RPolylineEntity(handler, o);
                }
            }
          
            // downcast to RRayEntity:
            {
                RRayEntity* o = dynamic_cast<RRayEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RRayEntity(handler, o);
                }
            }
          
            // downcast to RSolidEntity:
            {
                RSolidEntity* o = dynamic_cast<RSolidEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSolidEntity(handler, o);
                }
            }
          
            // downcast to RSplineEntity:
            {
                RSplineEntity* o = dynamic_cast<RSplineEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSplineEntity(handler, o);
                }
            }
          
            // downcast to RTextBasedEntity:
            {
                RTextBasedEntity* o = dynamic_cast<RTextBasedEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RTextBasedEntity(handler, o);
                }
            }
          
            // downcast to RTextEntity:
            {
                RTextEntity* o = dynamic_cast<RTextEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RTextEntity(handler, o);
                }
            }
          
            // downcast to RToleranceEntity:
            {
                RToleranceEntity* o = dynamic_cast<RToleranceEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RToleranceEntity(handler, o);
                }
            }
          
            // downcast to RTraceEntity:
            {
                RTraceEntity* o = dynamic_cast<RTraceEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RTraceEntity(handler, o);
                }
            }
          
            // downcast to RViewportEntity:
            {
                RViewportEntity* o = dynamic_cast<RViewportEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RViewportEntity(handler, o);
                }
            }
          
            // downcast to RWipeoutEntity:
            {
                RWipeoutEntity* o = dynamic_cast<RWipeoutEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RWipeoutEntity(handler, o);
                }
            }
          
            // downcast to RXLineEntity:
            {
                RXLineEntity* o = dynamic_cast<RXLineEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RXLineEntity(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          REntity_Wrapper* ret = new REntity_Wrapper(handler, v, false);

          // JS: new REntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("REntity");
          if (cl.isUndefined()) {
              qWarning() << "Class REntity is undefined. Use REntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new REntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new REntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      REntity* RJSHelper_qcad::js2cpp_REntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_REntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //REntity_Wrapper* wrapper = qobject_cast<REntity_Wrapper*>(obj);
          //REntity_Wrapper* wrapper = dynamic_cast<REntity_Wrapper*>(obj);
          //REntity_Wrapper* wrapper = (REntity_Wrapper*)(obj);
          //REntity_Wrapper* wrapper = getWrapper<REntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_REntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_REntity(wrapper);
          return REntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_REntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_REntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_REntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_REntityData(RJSApi& handler, REntityData* v) {

          
            // downcast to RBlockReferenceData:
            {
                RBlockReferenceData* o = dynamic_cast<RBlockReferenceData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RBlockReferenceData(handler, o);
                }
            }
          
            // downcast to RDimensionData:
            {
                RDimensionData* o = dynamic_cast<RDimensionData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimensionData(handler, o);
                }
            }
          
            // downcast to RHatchData:
            {
                RHatchData* o = dynamic_cast<RHatchData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RHatchData(handler, o);
                }
            }
          
            // downcast to RImageData:
            {
                RImageData* o = dynamic_cast<RImageData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RImageData(handler, o);
                }
            }
          
            // downcast to RToleranceData:
            {
                RToleranceData* o = dynamic_cast<RToleranceData*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RToleranceData(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          REntityData_Wrapper* ret = new REntityData_Wrapper(handler, v, false);

          // JS: new REntityData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("REntityData");
          if (cl.isUndefined()) {
              qWarning() << "Class REntityData is undefined. Use REntityData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new REntityData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new REntityData(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      REntityData* RJSHelper_qcad::js2cpp_REntityData_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_REntityData: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //REntityData_Wrapper* wrapper = qobject_cast<REntityData_Wrapper*>(obj);
          //REntityData_Wrapper* wrapper = dynamic_cast<REntityData_Wrapper*>(obj);
          //REntityData_Wrapper* wrapper = (REntityData_Wrapper*)(obj);
          //REntityData_Wrapper* wrapper = getWrapper<REntityData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_REntityData_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_REntityData(wrapper);
          return REntityData_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_REntityData_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_REntityData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_REntityData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_REntityExportListener(RJSApi& handler, REntityExportListener* v) {

          

          QJSEngine* engine = handler.getEngine();
          REntityExportListener_Wrapper* ret = new REntityExportListener_Wrapper(handler, v, false);

          // JS: new REntityExportListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("REntityExportListener");
          if (cl.isUndefined()) {
              qWarning() << "Class REntityExportListener is undefined. Use REntityExportListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new REntityExportListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new REntityExportListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      REntityExportListener* RJSHelper_qcad::js2cpp_REntityExportListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_REntityExportListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //REntityExportListener_Wrapper* wrapper = qobject_cast<REntityExportListener_Wrapper*>(obj);
          //REntityExportListener_Wrapper* wrapper = dynamic_cast<REntityExportListener_Wrapper*>(obj);
          //REntityExportListener_Wrapper* wrapper = (REntityExportListener_Wrapper*)(obj);
          //REntityExportListener_Wrapper* wrapper = getWrapper<REntityExportListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_REntityExportListener_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_REntityExportListener(wrapper);
          return REntityExportListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_REntityExportListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_REntityExportListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_REntityExportListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_REntityPickEvent(RJSApi& handler, REntityPickEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          REntityPickEvent_Wrapper* ret = new REntityPickEvent_Wrapper(handler, v, false);

          // JS: new REntityPickEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("REntityPickEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class REntityPickEvent is undefined. Use REntityPickEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new REntityPickEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new REntityPickEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      REntityPickEvent* RJSHelper_qcad::js2cpp_REntityPickEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_REntityPickEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //REntityPickEvent_Wrapper* wrapper = qobject_cast<REntityPickEvent_Wrapper*>(obj);
          //REntityPickEvent_Wrapper* wrapper = dynamic_cast<REntityPickEvent_Wrapper*>(obj);
          //REntityPickEvent_Wrapper* wrapper = (REntityPickEvent_Wrapper*)(obj);
          //REntityPickEvent_Wrapper* wrapper = getWrapper<REntityPickEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_REntityPickEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_REntityPickEvent(wrapper);
          return REntityPickEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_REntityPickEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_REntityPickEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_REntityPickEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RExplodable(RJSApi& handler, RExplodable* v) {

          
            // downcast to RPolyline:
            {
                RPolyline* o = dynamic_cast<RPolyline*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RPolyline(handler, o);
                }
            }
          
            // downcast to RSpline:
            {
                RSpline* o = dynamic_cast<RSpline*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSpline(handler, o);
                }
            }
          
            // downcast to RTriangle:
            {
                RTriangle* o = dynamic_cast<RTriangle*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RTriangle(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RExplodable_Wrapper* ret = new RExplodable_Wrapper(handler, v, false);

          // JS: new RExplodable('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RExplodable");
          if (cl.isUndefined()) {
              qWarning() << "Class RExplodable is undefined. Use RExplodable_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RExplodable('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RExplodable(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RExplodable* RJSHelper_qcad::js2cpp_RExplodable_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RExplodable: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RExplodable_Wrapper* wrapper = qobject_cast<RExplodable_Wrapper*>(obj);
          //RExplodable_Wrapper* wrapper = dynamic_cast<RExplodable_Wrapper*>(obj);
          //RExplodable_Wrapper* wrapper = (RExplodable_Wrapper*)(obj);
          //RExplodable_Wrapper* wrapper = getWrapper<RExplodable_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RExplodable_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RExplodable(wrapper);
          return RExplodable_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RExplodable_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RExplodable: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RExplodable::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RExportListener(RJSApi& handler, RExportListener* v) {

          

          QJSEngine* engine = handler.getEngine();
          RExportListener_Wrapper* ret = new RExportListener_Wrapper(handler, v, false);

          // JS: new RExportListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RExportListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RExportListener is undefined. Use RExportListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RExportListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RExportListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RExportListener* RJSHelper_qcad::js2cpp_RExportListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RExportListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RExportListener_Wrapper* wrapper = qobject_cast<RExportListener_Wrapper*>(obj);
          //RExportListener_Wrapper* wrapper = dynamic_cast<RExportListener_Wrapper*>(obj);
          //RExportListener_Wrapper* wrapper = (RExportListener_Wrapper*)(obj);
          //RExportListener_Wrapper* wrapper = getWrapper<RExportListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RExportListener_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RExportListener(wrapper);
          return RExportListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RExportListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RExportListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RExportListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RExporter(RJSApi& handler, RExporter* v) {

          
            // downcast to RFileExporter:
            {
                RFileExporter* o = dynamic_cast<RFileExporter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RFileExporter(handler, o);
                }
            }
          
            // downcast to RGraphicsScene:
            {
                RGraphicsScene* o = dynamic_cast<RGraphicsScene*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RGraphicsScene(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RExporter_Wrapper* ret = new RExporter_Wrapper(handler, v, false);

          // JS: new RExporter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RExporter");
          if (cl.isUndefined()) {
              qWarning() << "Class RExporter is undefined. Use RExporter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RExporter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RExporter(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RExporter* RJSHelper_qcad::js2cpp_RExporter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RExporter: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RExporter_Wrapper* wrapper = qobject_cast<RExporter_Wrapper*>(obj);
          //RExporter_Wrapper* wrapper = dynamic_cast<RExporter_Wrapper*>(obj);
          //RExporter_Wrapper* wrapper = (RExporter_Wrapper*)(obj);
          //RExporter_Wrapper* wrapper = getWrapper<RExporter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RExporter_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RExporter(wrapper);
          return RExporter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RExporter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RExporter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RExporter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFaceEntity(RJSApi& handler, RFaceEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RFaceEntity_Wrapper* ret = new RFaceEntity_Wrapper(handler, v, false);

          // JS: new RFaceEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFaceEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RFaceEntity is undefined. Use RFaceEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFaceEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFaceEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RFaceEntity* RJSHelper_qcad::js2cpp_RFaceEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFaceEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RFaceEntity_Wrapper* wrapper = qobject_cast<RFaceEntity_Wrapper*>(obj);
          //RFaceEntity_Wrapper* wrapper = dynamic_cast<RFaceEntity_Wrapper*>(obj);
          //RFaceEntity_Wrapper* wrapper = (RFaceEntity_Wrapper*)(obj);
          //RFaceEntity_Wrapper* wrapper = getWrapper<RFaceEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFaceEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RFaceEntity(wrapper);
          return RFaceEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RFaceEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFaceEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RFaceEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFileExporter(RJSApi& handler, RFileExporter* v) {

          
            // downcast to RFileExporterAdapter:
            {
                RFileExporterAdapter* o = dynamic_cast<RFileExporterAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RFileExporterAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RFileExporter_Wrapper* ret = new RFileExporter_Wrapper(handler, v, false);

          // JS: new RFileExporter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileExporter");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileExporter is undefined. Use RFileExporter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileExporter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileExporter(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RFileExporter* RJSHelper_qcad::js2cpp_RFileExporter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFileExporter: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RFileExporter_Wrapper* wrapper = qobject_cast<RFileExporter_Wrapper*>(obj);
          //RFileExporter_Wrapper* wrapper = dynamic_cast<RFileExporter_Wrapper*>(obj);
          //RFileExporter_Wrapper* wrapper = (RFileExporter_Wrapper*)(obj);
          //RFileExporter_Wrapper* wrapper = getWrapper<RFileExporter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileExporter_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RFileExporter(wrapper);
          return RFileExporter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RFileExporter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFileExporter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RFileExporter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFileExporterFactory(RJSApi& handler, RFileExporterFactory* v) {

          
            // downcast to RFileExporterFactoryAdapter:
            {
                RFileExporterFactoryAdapter* o = dynamic_cast<RFileExporterFactoryAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RFileExporterFactoryAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RFileExporterFactory_Wrapper* ret = new RFileExporterFactory_Wrapper(handler, v, false);

          // JS: new RFileExporterFactory('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileExporterFactory");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileExporterFactory is undefined. Use RFileExporterFactory_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileExporterFactory('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileExporterFactory(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RFileExporterFactory* RJSHelper_qcad::js2cpp_RFileExporterFactory_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFileExporterFactory: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RFileExporterFactory_Wrapper* wrapper = qobject_cast<RFileExporterFactory_Wrapper*>(obj);
          //RFileExporterFactory_Wrapper* wrapper = dynamic_cast<RFileExporterFactory_Wrapper*>(obj);
          //RFileExporterFactory_Wrapper* wrapper = (RFileExporterFactory_Wrapper*)(obj);
          //RFileExporterFactory_Wrapper* wrapper = getWrapper<RFileExporterFactory_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileExporterFactory_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RFileExporterFactory(wrapper);
          return RFileExporterFactory_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RFileExporterFactory_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFileExporterFactory: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RFileExporterFactory::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFileImporter(RJSApi& handler, RFileImporter* v) {

          
            // downcast to RFileImporterAdapter:
            {
                RFileImporterAdapter* o = dynamic_cast<RFileImporterAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RFileImporterAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RFileImporter_Wrapper* ret = new RFileImporter_Wrapper(handler, v, false);

          // JS: new RFileImporter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileImporter");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileImporter is undefined. Use RFileImporter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileImporter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileImporter(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RFileImporter* RJSHelper_qcad::js2cpp_RFileImporter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFileImporter: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RFileImporter_Wrapper* wrapper = qobject_cast<RFileImporter_Wrapper*>(obj);
          //RFileImporter_Wrapper* wrapper = dynamic_cast<RFileImporter_Wrapper*>(obj);
          //RFileImporter_Wrapper* wrapper = (RFileImporter_Wrapper*)(obj);
          //RFileImporter_Wrapper* wrapper = getWrapper<RFileImporter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileImporter_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RFileImporter(wrapper);
          return RFileImporter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RFileImporter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFileImporter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RFileImporter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFileImporterFactory(RJSApi& handler, RFileImporterFactory* v) {

          
            // downcast to RFileImporterFactoryAdapter:
            {
                RFileImporterFactoryAdapter* o = dynamic_cast<RFileImporterFactoryAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RFileImporterFactoryAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RFileImporterFactory_Wrapper* ret = new RFileImporterFactory_Wrapper(handler, v, false);

          // JS: new RFileImporterFactory('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileImporterFactory");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileImporterFactory is undefined. Use RFileImporterFactory_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileImporterFactory('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileImporterFactory(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RFileImporterFactory* RJSHelper_qcad::js2cpp_RFileImporterFactory_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFileImporterFactory: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RFileImporterFactory_Wrapper* wrapper = qobject_cast<RFileImporterFactory_Wrapper*>(obj);
          //RFileImporterFactory_Wrapper* wrapper = dynamic_cast<RFileImporterFactory_Wrapper*>(obj);
          //RFileImporterFactory_Wrapper* wrapper = (RFileImporterFactory_Wrapper*)(obj);
          //RFileImporterFactory_Wrapper* wrapper = getWrapper<RFileImporterFactory_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileImporterFactory_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RFileImporterFactory(wrapper);
          return RFileImporterFactory_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RFileImporterFactory_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFileImporterFactory: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RFileImporterFactory::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFocusListener(RJSApi& handler, RFocusListener* v) {

          
            // downcast to RFocusListenerAdapter:
            {
                RFocusListenerAdapter* o = dynamic_cast<RFocusListenerAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RFocusListenerAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RFocusListener_Wrapper* ret = new RFocusListener_Wrapper(handler, v, false);

          // JS: new RFocusListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFocusListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RFocusListener is undefined. Use RFocusListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFocusListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFocusListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RFocusListener* RJSHelper_qcad::js2cpp_RFocusListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFocusListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RFocusListener_Wrapper* wrapper = qobject_cast<RFocusListener_Wrapper*>(obj);
          //RFocusListener_Wrapper* wrapper = dynamic_cast<RFocusListener_Wrapper*>(obj);
          //RFocusListener_Wrapper* wrapper = (RFocusListener_Wrapper*)(obj);
          //RFocusListener_Wrapper* wrapper = getWrapper<RFocusListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFocusListener_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RFocusListener(wrapper);
          return RFocusListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RFocusListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFocusListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RFocusListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RGraphicsScene(RJSApi& handler, RGraphicsScene* v) {

          
            // downcast to RGraphicsSceneQt:
            {
                RGraphicsSceneQt* o = dynamic_cast<RGraphicsSceneQt*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RGraphicsSceneQt(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RGraphicsScene_Wrapper* ret = new RGraphicsScene_Wrapper(handler, v, false);

          // JS: new RGraphicsScene('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RGraphicsScene");
          if (cl.isUndefined()) {
              qWarning() << "Class RGraphicsScene is undefined. Use RGraphicsScene_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RGraphicsScene('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RGraphicsScene(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RGraphicsScene* RJSHelper_qcad::js2cpp_RGraphicsScene_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RGraphicsScene: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RGraphicsScene_Wrapper* wrapper = qobject_cast<RGraphicsScene_Wrapper*>(obj);
          //RGraphicsScene_Wrapper* wrapper = dynamic_cast<RGraphicsScene_Wrapper*>(obj);
          //RGraphicsScene_Wrapper* wrapper = (RGraphicsScene_Wrapper*)(obj);
          //RGraphicsScene_Wrapper* wrapper = getWrapper<RGraphicsScene_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RGraphicsScene_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RGraphicsScene(wrapper);
          return RGraphicsScene_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RGraphicsScene_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RGraphicsScene: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RGraphicsScene::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RGraphicsSceneQt(RJSApi& handler, RGraphicsSceneQt* v) {

          

          QJSEngine* engine = handler.getEngine();
          RGraphicsSceneQt_Wrapper* ret = new RGraphicsSceneQt_Wrapper(handler, v, false);

          // JS: new RGraphicsSceneQt('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RGraphicsSceneQt");
          if (cl.isUndefined()) {
              qWarning() << "Class RGraphicsSceneQt is undefined. Use RGraphicsSceneQt_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RGraphicsSceneQt('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RGraphicsSceneQt(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RGraphicsSceneQt* RJSHelper_qcad::js2cpp_RGraphicsSceneQt_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RGraphicsSceneQt: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RGraphicsSceneQt_Wrapper* wrapper = qobject_cast<RGraphicsSceneQt_Wrapper*>(obj);
          //RGraphicsSceneQt_Wrapper* wrapper = dynamic_cast<RGraphicsSceneQt_Wrapper*>(obj);
          //RGraphicsSceneQt_Wrapper* wrapper = (RGraphicsSceneQt_Wrapper*)(obj);
          //RGraphicsSceneQt_Wrapper* wrapper = getWrapper<RGraphicsSceneQt_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RGraphicsSceneQt_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RGraphicsSceneQt(wrapper);
          return RGraphicsSceneQt_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RGraphicsSceneQt_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RGraphicsSceneQt: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RGraphicsSceneQt::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RGraphicsView(RJSApi& handler, RGraphicsView* v) {

          
            // downcast to RGraphicsViewImage:
            {
                RGraphicsViewImage* o = dynamic_cast<RGraphicsViewImage*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RGraphicsViewImage(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RGraphicsView_Wrapper* ret = new RGraphicsView_Wrapper(handler, v, false);

          // JS: new RGraphicsView('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RGraphicsView");
          if (cl.isUndefined()) {
              qWarning() << "Class RGraphicsView is undefined. Use RGraphicsView_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RGraphicsView('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RGraphicsView(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RGraphicsView* RJSHelper_qcad::js2cpp_RGraphicsView_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RGraphicsView: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RGraphicsView_Wrapper* wrapper = qobject_cast<RGraphicsView_Wrapper*>(obj);
          //RGraphicsView_Wrapper* wrapper = dynamic_cast<RGraphicsView_Wrapper*>(obj);
          //RGraphicsView_Wrapper* wrapper = (RGraphicsView_Wrapper*)(obj);
          //RGraphicsView_Wrapper* wrapper = getWrapper<RGraphicsView_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RGraphicsView_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RGraphicsView(wrapper);
          return RGraphicsView_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RGraphicsView_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RGraphicsView: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RGraphicsView::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RGrid(RJSApi& handler, RGrid* v) {

          
            // downcast to ROrthoGrid:
            {
                ROrthoGrid* o = dynamic_cast<ROrthoGrid*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_ROrthoGrid(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RGrid_Wrapper* ret = new RGrid_Wrapper(handler, v, false);

          // JS: new RGrid('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RGrid");
          if (cl.isUndefined()) {
              qWarning() << "Class RGrid is undefined. Use RGrid_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RGrid('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RGrid(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RGrid* RJSHelper_qcad::js2cpp_RGrid_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RGrid: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RGrid_Wrapper* wrapper = qobject_cast<RGrid_Wrapper*>(obj);
          //RGrid_Wrapper* wrapper = dynamic_cast<RGrid_Wrapper*>(obj);
          //RGrid_Wrapper* wrapper = (RGrid_Wrapper*)(obj);
          //RGrid_Wrapper* wrapper = getWrapper<RGrid_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RGrid_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RGrid(wrapper);
          return RGrid_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RGrid_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RGrid: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RGrid::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RHatchEntity(RJSApi& handler, RHatchEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RHatchEntity_Wrapper* ret = new RHatchEntity_Wrapper(handler, v, false);

          // JS: new RHatchEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RHatchEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RHatchEntity is undefined. Use RHatchEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RHatchEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RHatchEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RHatchEntity* RJSHelper_qcad::js2cpp_RHatchEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RHatchEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RHatchEntity_Wrapper* wrapper = qobject_cast<RHatchEntity_Wrapper*>(obj);
          //RHatchEntity_Wrapper* wrapper = dynamic_cast<RHatchEntity_Wrapper*>(obj);
          //RHatchEntity_Wrapper* wrapper = (RHatchEntity_Wrapper*)(obj);
          //RHatchEntity_Wrapper* wrapper = getWrapper<RHatchEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RHatchEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RHatchEntity(wrapper);
          return RHatchEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RHatchEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RHatchEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RHatchEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RImageEntity(RJSApi& handler, RImageEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RImageEntity_Wrapper* ret = new RImageEntity_Wrapper(handler, v, false);

          // JS: new RImageEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RImageEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RImageEntity is undefined. Use RImageEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RImageEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RImageEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RImageEntity* RJSHelper_qcad::js2cpp_RImageEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RImageEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RImageEntity_Wrapper* wrapper = qobject_cast<RImageEntity_Wrapper*>(obj);
          //RImageEntity_Wrapper* wrapper = dynamic_cast<RImageEntity_Wrapper*>(obj);
          //RImageEntity_Wrapper* wrapper = (RImageEntity_Wrapper*)(obj);
          //RImageEntity_Wrapper* wrapper = getWrapper<RImageEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RImageEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RImageEntity(wrapper);
          return RImageEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RImageEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RImageEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RImageEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RImportListener(RJSApi& handler, RImportListener* v) {

          

          QJSEngine* engine = handler.getEngine();
          RImportListener_Wrapper* ret = new RImportListener_Wrapper(handler, v, false);

          // JS: new RImportListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RImportListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RImportListener is undefined. Use RImportListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RImportListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RImportListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RImportListener* RJSHelper_qcad::js2cpp_RImportListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RImportListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RImportListener_Wrapper* wrapper = qobject_cast<RImportListener_Wrapper*>(obj);
          //RImportListener_Wrapper* wrapper = dynamic_cast<RImportListener_Wrapper*>(obj);
          //RImportListener_Wrapper* wrapper = (RImportListener_Wrapper*)(obj);
          //RImportListener_Wrapper* wrapper = getWrapper<RImportListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RImportListener_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RImportListener(wrapper);
          return RImportListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RImportListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RImportListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RImportListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RImporter(RJSApi& handler, RImporter* v) {

          
            // downcast to RFileImporter:
            {
                RFileImporter* o = dynamic_cast<RFileImporter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RFileImporter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RImporter_Wrapper* ret = new RImporter_Wrapper(handler, v, false);

          // JS: new RImporter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RImporter");
          if (cl.isUndefined()) {
              qWarning() << "Class RImporter is undefined. Use RImporter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RImporter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RImporter(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RImporter* RJSHelper_qcad::js2cpp_RImporter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RImporter: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RImporter_Wrapper* wrapper = qobject_cast<RImporter_Wrapper*>(obj);
          //RImporter_Wrapper* wrapper = dynamic_cast<RImporter_Wrapper*>(obj);
          //RImporter_Wrapper* wrapper = (RImporter_Wrapper*)(obj);
          //RImporter_Wrapper* wrapper = getWrapper<RImporter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RImporter_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RImporter(wrapper);
          return RImporter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RImporter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RImporter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RImporter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RInputEvent(RJSApi& handler, RInputEvent* v) {

          
            // downcast to RCoordinateEvent:
            {
                RCoordinateEvent* o = dynamic_cast<RCoordinateEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RCoordinateEvent(handler, o);
                }
            }
          
            // downcast to REntityPickEvent:
            {
                REntityPickEvent* o = dynamic_cast<REntityPickEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_REntityPickEvent(handler, o);
                }
            }
          
            // downcast to RMouseEvent:
            {
                RMouseEvent* o = dynamic_cast<RMouseEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RMouseEvent(handler, o);
                }
            }
          
            // downcast to RWheelEvent:
            {
                RWheelEvent* o = dynamic_cast<RWheelEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RWheelEvent(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RInputEvent_Wrapper* ret = new RInputEvent_Wrapper(handler, v, false);

          // JS: new RInputEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RInputEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class RInputEvent is undefined. Use RInputEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RInputEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RInputEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RInputEvent* RJSHelper_qcad::js2cpp_RInputEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RInputEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RInputEvent_Wrapper* wrapper = qobject_cast<RInputEvent_Wrapper*>(obj);
          //RInputEvent_Wrapper* wrapper = dynamic_cast<RInputEvent_Wrapper*>(obj);
          //RInputEvent_Wrapper* wrapper = (RInputEvent_Wrapper*)(obj);
          //RInputEvent_Wrapper* wrapper = getWrapper<RInputEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RInputEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RInputEvent(wrapper);
          return RInputEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RInputEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RInputEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RInputEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RInterTransactionListener(RJSApi& handler, RInterTransactionListener* v) {

          
            // downcast to RInterTransactionListenerAdapter:
            {
                RInterTransactionListenerAdapter* o = dynamic_cast<RInterTransactionListenerAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RInterTransactionListenerAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RInterTransactionListener_Wrapper* ret = new RInterTransactionListener_Wrapper(handler, v, false);

          // JS: new RInterTransactionListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RInterTransactionListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RInterTransactionListener is undefined. Use RInterTransactionListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RInterTransactionListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RInterTransactionListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RInterTransactionListener* RJSHelper_qcad::js2cpp_RInterTransactionListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RInterTransactionListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RInterTransactionListener_Wrapper* wrapper = qobject_cast<RInterTransactionListener_Wrapper*>(obj);
          //RInterTransactionListener_Wrapper* wrapper = dynamic_cast<RInterTransactionListener_Wrapper*>(obj);
          //RInterTransactionListener_Wrapper* wrapper = (RInterTransactionListener_Wrapper*)(obj);
          //RInterTransactionListener_Wrapper* wrapper = getWrapper<RInterTransactionListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RInterTransactionListener_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RInterTransactionListener(wrapper);
          return RInterTransactionListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RInterTransactionListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RInterTransactionListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RInterTransactionListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RKeyListener(RJSApi& handler, RKeyListener* v) {

          
            // downcast to RKeyListenerAdapter:
            {
                RKeyListenerAdapter* o = dynamic_cast<RKeyListenerAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RKeyListenerAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RKeyListener_Wrapper* ret = new RKeyListener_Wrapper(handler, v, false);

          // JS: new RKeyListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RKeyListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RKeyListener is undefined. Use RKeyListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RKeyListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RKeyListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RKeyListener* RJSHelper_qcad::js2cpp_RKeyListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RKeyListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RKeyListener_Wrapper* wrapper = qobject_cast<RKeyListener_Wrapper*>(obj);
          //RKeyListener_Wrapper* wrapper = dynamic_cast<RKeyListener_Wrapper*>(obj);
          //RKeyListener_Wrapper* wrapper = (RKeyListener_Wrapper*)(obj);
          //RKeyListener_Wrapper* wrapper = getWrapper<RKeyListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RKeyListener_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RKeyListener(wrapper);
          return RKeyListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RKeyListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RKeyListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RKeyListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLayer(RJSApi& handler, RLayer* v) {

          

          QJSEngine* engine = handler.getEngine();
          RLayer_Wrapper* ret = new RLayer_Wrapper(handler, v, false);

          // JS: new RLayer('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLayer");
          if (cl.isUndefined()) {
              qWarning() << "Class RLayer is undefined. Use RLayer_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLayer('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLayer(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RLayer* RJSHelper_qcad::js2cpp_RLayer_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLayer: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RLayer_Wrapper* wrapper = qobject_cast<RLayer_Wrapper*>(obj);
          //RLayer_Wrapper* wrapper = dynamic_cast<RLayer_Wrapper*>(obj);
          //RLayer_Wrapper* wrapper = (RLayer_Wrapper*)(obj);
          //RLayer_Wrapper* wrapper = getWrapper<RLayer_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLayer_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RLayer(wrapper);
          return RLayer_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RLayer_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLayer: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RLayer::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLayerListener(RJSApi& handler, RLayerListener* v) {

          
            // downcast to RLayerListenerAdapter:
            {
                RLayerListenerAdapter* o = dynamic_cast<RLayerListenerAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RLayerListenerAdapter(handler, o);
                }
            }
          
            // downcast to RPropertyEditor:
            {
                RPropertyEditor* o = dynamic_cast<RPropertyEditor*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RPropertyEditor(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RLayerListener_Wrapper* ret = new RLayerListener_Wrapper(handler, v, false);

          // JS: new RLayerListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLayerListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RLayerListener is undefined. Use RLayerListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLayerListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLayerListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RLayerListener* RJSHelper_qcad::js2cpp_RLayerListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLayerListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RLayerListener_Wrapper* wrapper = qobject_cast<RLayerListener_Wrapper*>(obj);
          //RLayerListener_Wrapper* wrapper = dynamic_cast<RLayerListener_Wrapper*>(obj);
          //RLayerListener_Wrapper* wrapper = (RLayerListener_Wrapper*)(obj);
          //RLayerListener_Wrapper* wrapper = getWrapper<RLayerListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLayerListener_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RLayerListener(wrapper);
          return RLayerListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RLayerListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLayerListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RLayerListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLayerState(RJSApi& handler, RLayerState* v) {

          

          QJSEngine* engine = handler.getEngine();
          RLayerState_Wrapper* ret = new RLayerState_Wrapper(handler, v, false);

          // JS: new RLayerState('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLayerState");
          if (cl.isUndefined()) {
              qWarning() << "Class RLayerState is undefined. Use RLayerState_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLayerState('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLayerState(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RLayerState* RJSHelper_qcad::js2cpp_RLayerState_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLayerState: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RLayerState_Wrapper* wrapper = qobject_cast<RLayerState_Wrapper*>(obj);
          //RLayerState_Wrapper* wrapper = dynamic_cast<RLayerState_Wrapper*>(obj);
          //RLayerState_Wrapper* wrapper = (RLayerState_Wrapper*)(obj);
          //RLayerState_Wrapper* wrapper = getWrapper<RLayerState_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLayerState_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RLayerState(wrapper);
          return RLayerState_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RLayerState_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLayerState: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RLayerState::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLayout(RJSApi& handler, RLayout* v) {

          

          QJSEngine* engine = handler.getEngine();
          RLayout_Wrapper* ret = new RLayout_Wrapper(handler, v, false);

          // JS: new RLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class RLayout is undefined. Use RLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLayout('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLayout(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RLayout* RJSHelper_qcad::js2cpp_RLayout_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLayout: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RLayout_Wrapper* wrapper = qobject_cast<RLayout_Wrapper*>(obj);
          //RLayout_Wrapper* wrapper = dynamic_cast<RLayout_Wrapper*>(obj);
          //RLayout_Wrapper* wrapper = (RLayout_Wrapper*)(obj);
          //RLayout_Wrapper* wrapper = getWrapper<RLayout_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLayout_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RLayout(wrapper);
          return RLayout_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RLayout_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLayout: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RLayout::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLeaderEntity(RJSApi& handler, RLeaderEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RLeaderEntity_Wrapper* ret = new RLeaderEntity_Wrapper(handler, v, false);

          // JS: new RLeaderEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLeaderEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RLeaderEntity is undefined. Use RLeaderEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLeaderEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLeaderEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RLeaderEntity* RJSHelper_qcad::js2cpp_RLeaderEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLeaderEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RLeaderEntity_Wrapper* wrapper = qobject_cast<RLeaderEntity_Wrapper*>(obj);
          //RLeaderEntity_Wrapper* wrapper = dynamic_cast<RLeaderEntity_Wrapper*>(obj);
          //RLeaderEntity_Wrapper* wrapper = (RLeaderEntity_Wrapper*)(obj);
          //RLeaderEntity_Wrapper* wrapper = getWrapper<RLeaderEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLeaderEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RLeaderEntity(wrapper);
          return RLeaderEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RLeaderEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLeaderEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RLeaderEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLineEntity(RJSApi& handler, RLineEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RLineEntity_Wrapper* ret = new RLineEntity_Wrapper(handler, v, false);

          // JS: new RLineEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLineEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RLineEntity is undefined. Use RLineEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLineEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLineEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RLineEntity* RJSHelper_qcad::js2cpp_RLineEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLineEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RLineEntity_Wrapper* wrapper = qobject_cast<RLineEntity_Wrapper*>(obj);
          //RLineEntity_Wrapper* wrapper = dynamic_cast<RLineEntity_Wrapper*>(obj);
          //RLineEntity_Wrapper* wrapper = (RLineEntity_Wrapper*)(obj);
          //RLineEntity_Wrapper* wrapper = getWrapper<RLineEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLineEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RLineEntity(wrapper);
          return RLineEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RLineEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLineEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RLineEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLinetype(RJSApi& handler, RLinetype* v) {

          

          QJSEngine* engine = handler.getEngine();
          RLinetype_Wrapper* ret = new RLinetype_Wrapper(handler, v, false);

          // JS: new RLinetype('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLinetype");
          if (cl.isUndefined()) {
              qWarning() << "Class RLinetype is undefined. Use RLinetype_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLinetype('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLinetype(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RLinetype* RJSHelper_qcad::js2cpp_RLinetype_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLinetype: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RLinetype_Wrapper* wrapper = qobject_cast<RLinetype_Wrapper*>(obj);
          //RLinetype_Wrapper* wrapper = dynamic_cast<RLinetype_Wrapper*>(obj);
          //RLinetype_Wrapper* wrapper = (RLinetype_Wrapper*)(obj);
          //RLinetype_Wrapper* wrapper = getWrapper<RLinetype_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLinetype_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RLinetype(wrapper);
          return RLinetype_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RLinetype_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLinetype: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RLinetype::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RMainWindow(RJSApi& handler, RMainWindow* v) {

          

          QJSEngine* engine = handler.getEngine();
          RMainWindow_Wrapper* ret = new RMainWindow_Wrapper(handler, v, false);

          // JS: new RMainWindow('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMainWindow");
          if (cl.isUndefined()) {
              qWarning() << "Class RMainWindow is undefined. Use RMainWindow_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMainWindow('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMainWindow(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RMainWindow* RJSHelper_qcad::js2cpp_RMainWindow_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RMainWindow: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RMainWindow_Wrapper* wrapper = qobject_cast<RMainWindow_Wrapper*>(obj);
          //RMainWindow_Wrapper* wrapper = dynamic_cast<RMainWindow_Wrapper*>(obj);
          //RMainWindow_Wrapper* wrapper = (RMainWindow_Wrapper*)(obj);
          //RMainWindow_Wrapper* wrapper = getWrapper<RMainWindow_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMainWindow_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RMainWindow(wrapper);
          return RMainWindow_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RMainWindow_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RMainWindow: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RMainWindow::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RMemoryStorage(RJSApi& handler, RMemoryStorage* v) {

          

          QJSEngine* engine = handler.getEngine();
          RMemoryStorage_Wrapper* ret = new RMemoryStorage_Wrapper(handler, v, false);

          // JS: new RMemoryStorage('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMemoryStorage");
          if (cl.isUndefined()) {
              qWarning() << "Class RMemoryStorage is undefined. Use RMemoryStorage_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMemoryStorage('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMemoryStorage(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RMemoryStorage* RJSHelper_qcad::js2cpp_RMemoryStorage_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RMemoryStorage: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RMemoryStorage_Wrapper* wrapper = qobject_cast<RMemoryStorage_Wrapper*>(obj);
          //RMemoryStorage_Wrapper* wrapper = dynamic_cast<RMemoryStorage_Wrapper*>(obj);
          //RMemoryStorage_Wrapper* wrapper = (RMemoryStorage_Wrapper*)(obj);
          //RMemoryStorage_Wrapper* wrapper = getWrapper<RMemoryStorage_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMemoryStorage_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RMemoryStorage(wrapper);
          return RMemoryStorage_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RMemoryStorage_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RMemoryStorage: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RMemoryStorage::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RMessageHandler(RJSApi& handler, RMessageHandler* v) {

          

          QJSEngine* engine = handler.getEngine();
          RMessageHandler_Wrapper* ret = new RMessageHandler_Wrapper(handler, v, false);

          // JS: new RMessageHandler('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMessageHandler");
          if (cl.isUndefined()) {
              qWarning() << "Class RMessageHandler is undefined. Use RMessageHandler_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMessageHandler('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMessageHandler(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RMessageHandler* RJSHelper_qcad::js2cpp_RMessageHandler_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RMessageHandler: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RMessageHandler_Wrapper* wrapper = qobject_cast<RMessageHandler_Wrapper*>(obj);
          //RMessageHandler_Wrapper* wrapper = dynamic_cast<RMessageHandler_Wrapper*>(obj);
          //RMessageHandler_Wrapper* wrapper = (RMessageHandler_Wrapper*)(obj);
          //RMessageHandler_Wrapper* wrapper = getWrapper<RMessageHandler_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMessageHandler_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RMessageHandler(wrapper);
          return RMessageHandler_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RMessageHandler_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RMessageHandler: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RMessageHandler::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RMixedOperation(RJSApi& handler, RMixedOperation* v) {

          

          QJSEngine* engine = handler.getEngine();
          RMixedOperation_Wrapper* ret = new RMixedOperation_Wrapper(handler, v, false);

          // JS: new RMixedOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMixedOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RMixedOperation is undefined. Use RMixedOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMixedOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMixedOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RMixedOperation* RJSHelper_qcad::js2cpp_RMixedOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RMixedOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RMixedOperation_Wrapper* wrapper = qobject_cast<RMixedOperation_Wrapper*>(obj);
          //RMixedOperation_Wrapper* wrapper = dynamic_cast<RMixedOperation_Wrapper*>(obj);
          //RMixedOperation_Wrapper* wrapper = (RMixedOperation_Wrapper*)(obj);
          //RMixedOperation_Wrapper* wrapper = getWrapper<RMixedOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMixedOperation_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RMixedOperation(wrapper);
          return RMixedOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RMixedOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RMixedOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RMixedOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RModifiedListener(RJSApi& handler, RModifiedListener* v) {

          

          QJSEngine* engine = handler.getEngine();
          RModifiedListener_Wrapper* ret = new RModifiedListener_Wrapper(handler, v, false);

          // JS: new RModifiedListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RModifiedListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RModifiedListener is undefined. Use RModifiedListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RModifiedListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RModifiedListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RModifiedListener* RJSHelper_qcad::js2cpp_RModifiedListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RModifiedListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RModifiedListener_Wrapper* wrapper = qobject_cast<RModifiedListener_Wrapper*>(obj);
          //RModifiedListener_Wrapper* wrapper = dynamic_cast<RModifiedListener_Wrapper*>(obj);
          //RModifiedListener_Wrapper* wrapper = (RModifiedListener_Wrapper*)(obj);
          //RModifiedListener_Wrapper* wrapper = getWrapper<RModifiedListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RModifiedListener_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RModifiedListener(wrapper);
          return RModifiedListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RModifiedListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RModifiedListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RModifiedListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RModifyObjectOperation(RJSApi& handler, RModifyObjectOperation* v) {

          

          QJSEngine* engine = handler.getEngine();
          RModifyObjectOperation_Wrapper* ret = new RModifyObjectOperation_Wrapper(handler, v, false);

          // JS: new RModifyObjectOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RModifyObjectOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RModifyObjectOperation is undefined. Use RModifyObjectOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RModifyObjectOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RModifyObjectOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RModifyObjectOperation* RJSHelper_qcad::js2cpp_RModifyObjectOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RModifyObjectOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RModifyObjectOperation_Wrapper* wrapper = qobject_cast<RModifyObjectOperation_Wrapper*>(obj);
          //RModifyObjectOperation_Wrapper* wrapper = dynamic_cast<RModifyObjectOperation_Wrapper*>(obj);
          //RModifyObjectOperation_Wrapper* wrapper = (RModifyObjectOperation_Wrapper*)(obj);
          //RModifyObjectOperation_Wrapper* wrapper = getWrapper<RModifyObjectOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RModifyObjectOperation_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RModifyObjectOperation(wrapper);
          return RModifyObjectOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RModifyObjectOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RModifyObjectOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RModifyObjectOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RModifyObjectsOperation(RJSApi& handler, RModifyObjectsOperation* v) {

          

          QJSEngine* engine = handler.getEngine();
          RModifyObjectsOperation_Wrapper* ret = new RModifyObjectsOperation_Wrapper(handler, v, false);

          // JS: new RModifyObjectsOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RModifyObjectsOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RModifyObjectsOperation is undefined. Use RModifyObjectsOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RModifyObjectsOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RModifyObjectsOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RModifyObjectsOperation* RJSHelper_qcad::js2cpp_RModifyObjectsOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RModifyObjectsOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RModifyObjectsOperation_Wrapper* wrapper = qobject_cast<RModifyObjectsOperation_Wrapper*>(obj);
          //RModifyObjectsOperation_Wrapper* wrapper = dynamic_cast<RModifyObjectsOperation_Wrapper*>(obj);
          //RModifyObjectsOperation_Wrapper* wrapper = (RModifyObjectsOperation_Wrapper*)(obj);
          //RModifyObjectsOperation_Wrapper* wrapper = getWrapper<RModifyObjectsOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RModifyObjectsOperation_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RModifyObjectsOperation(wrapper);
          return RModifyObjectsOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RModifyObjectsOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RModifyObjectsOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RModifyObjectsOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RMouseEvent(RJSApi& handler, RMouseEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          RMouseEvent_Wrapper* ret = new RMouseEvent_Wrapper(handler, v, false);

          // JS: new RMouseEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMouseEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class RMouseEvent is undefined. Use RMouseEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMouseEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMouseEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RMouseEvent* RJSHelper_qcad::js2cpp_RMouseEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RMouseEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RMouseEvent_Wrapper* wrapper = qobject_cast<RMouseEvent_Wrapper*>(obj);
          //RMouseEvent_Wrapper* wrapper = dynamic_cast<RMouseEvent_Wrapper*>(obj);
          //RMouseEvent_Wrapper* wrapper = (RMouseEvent_Wrapper*)(obj);
          //RMouseEvent_Wrapper* wrapper = getWrapper<RMouseEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMouseEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RMouseEvent(wrapper);
          return RMouseEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RMouseEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RMouseEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RMouseEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RMoveReferencePointOperation(RJSApi& handler, RMoveReferencePointOperation* v) {

          

          QJSEngine* engine = handler.getEngine();
          RMoveReferencePointOperation_Wrapper* ret = new RMoveReferencePointOperation_Wrapper(handler, v, false);

          // JS: new RMoveReferencePointOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMoveReferencePointOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RMoveReferencePointOperation is undefined. Use RMoveReferencePointOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMoveReferencePointOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMoveReferencePointOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RMoveReferencePointOperation* RJSHelper_qcad::js2cpp_RMoveReferencePointOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RMoveReferencePointOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RMoveReferencePointOperation_Wrapper* wrapper = qobject_cast<RMoveReferencePointOperation_Wrapper*>(obj);
          //RMoveReferencePointOperation_Wrapper* wrapper = dynamic_cast<RMoveReferencePointOperation_Wrapper*>(obj);
          //RMoveReferencePointOperation_Wrapper* wrapper = (RMoveReferencePointOperation_Wrapper*)(obj);
          //RMoveReferencePointOperation_Wrapper* wrapper = getWrapper<RMoveReferencePointOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMoveReferencePointOperation_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RMoveReferencePointOperation(wrapper);
          return RMoveReferencePointOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RMoveReferencePointOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RMoveReferencePointOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RMoveReferencePointOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RMoveSelectionOperation(RJSApi& handler, RMoveSelectionOperation* v) {

          

          QJSEngine* engine = handler.getEngine();
          RMoveSelectionOperation_Wrapper* ret = new RMoveSelectionOperation_Wrapper(handler, v, false);

          // JS: new RMoveSelectionOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMoveSelectionOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RMoveSelectionOperation is undefined. Use RMoveSelectionOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMoveSelectionOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMoveSelectionOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RMoveSelectionOperation* RJSHelper_qcad::js2cpp_RMoveSelectionOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RMoveSelectionOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RMoveSelectionOperation_Wrapper* wrapper = qobject_cast<RMoveSelectionOperation_Wrapper*>(obj);
          //RMoveSelectionOperation_Wrapper* wrapper = dynamic_cast<RMoveSelectionOperation_Wrapper*>(obj);
          //RMoveSelectionOperation_Wrapper* wrapper = (RMoveSelectionOperation_Wrapper*)(obj);
          //RMoveSelectionOperation_Wrapper* wrapper = getWrapper<RMoveSelectionOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMoveSelectionOperation_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RMoveSelectionOperation(wrapper);
          return RMoveSelectionOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RMoveSelectionOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RMoveSelectionOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RMoveSelectionOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RNewDocumentListener(RJSApi& handler, RNewDocumentListener* v) {

          

          QJSEngine* engine = handler.getEngine();
          RNewDocumentListener_Wrapper* ret = new RNewDocumentListener_Wrapper(handler, v, false);

          // JS: new RNewDocumentListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RNewDocumentListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RNewDocumentListener is undefined. Use RNewDocumentListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RNewDocumentListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RNewDocumentListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RNewDocumentListener* RJSHelper_qcad::js2cpp_RNewDocumentListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RNewDocumentListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RNewDocumentListener_Wrapper* wrapper = qobject_cast<RNewDocumentListener_Wrapper*>(obj);
          //RNewDocumentListener_Wrapper* wrapper = dynamic_cast<RNewDocumentListener_Wrapper*>(obj);
          //RNewDocumentListener_Wrapper* wrapper = (RNewDocumentListener_Wrapper*)(obj);
          //RNewDocumentListener_Wrapper* wrapper = getWrapper<RNewDocumentListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RNewDocumentListener_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RNewDocumentListener(wrapper);
          return RNewDocumentListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RNewDocumentListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RNewDocumentListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RNewDocumentListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RObject(RJSApi& handler, RObject* v) {

          
            // downcast to RBlock:
            {
                RBlock* o = dynamic_cast<RBlock*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RBlock(handler, o);
                }
            }
          
            // downcast to RDimStyle:
            {
                RDimStyle* o = dynamic_cast<RDimStyle*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDimStyle(handler, o);
                }
            }
          
            // downcast to RDocumentVariables:
            {
                RDocumentVariables* o = dynamic_cast<RDocumentVariables*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDocumentVariables(handler, o);
                }
            }
          
            // downcast to REntity:
            {
                REntity* o = dynamic_cast<REntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_REntity(handler, o);
                }
            }
          
            // downcast to RLayer:
            {
                RLayer* o = dynamic_cast<RLayer*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RLayer(handler, o);
                }
            }
          
            // downcast to RLayerState:
            {
                RLayerState* o = dynamic_cast<RLayerState*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RLayerState(handler, o);
                }
            }
          
            // downcast to RLayout:
            {
                RLayout* o = dynamic_cast<RLayout*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RLayout(handler, o);
                }
            }
          
            // downcast to RLinetype:
            {
                RLinetype* o = dynamic_cast<RLinetype*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RLinetype(handler, o);
                }
            }
          
            // downcast to RUcs:
            {
                RUcs* o = dynamic_cast<RUcs*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RUcs(handler, o);
                }
            }
          
            // downcast to RView:
            {
                RView* o = dynamic_cast<RView*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RView(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RObject_Wrapper* ret = new RObject_Wrapper(handler, v, false);

          // JS: new RObject('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RObject");
          if (cl.isUndefined()) {
              qWarning() << "Class RObject is undefined. Use RObject_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RObject('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RObject(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RObject* RJSHelper_qcad::js2cpp_RObject_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RObject: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RObject_Wrapper* wrapper = qobject_cast<RObject_Wrapper*>(obj);
          //RObject_Wrapper* wrapper = dynamic_cast<RObject_Wrapper*>(obj);
          //RObject_Wrapper* wrapper = (RObject_Wrapper*)(obj);
          //RObject_Wrapper* wrapper = getWrapper<RObject_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RObject_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RObject(wrapper);
          return RObject_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RObject_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RObject: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RObject::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_ROperation(RJSApi& handler, ROperation* v) {

          
            // downcast to RAddObjectsOperation:
            {
                RAddObjectsOperation* o = dynamic_cast<RAddObjectsOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RAddObjectsOperation(handler, o);
                }
            }
          
            // downcast to RChangePropertyOperation:
            {
                RChangePropertyOperation* o = dynamic_cast<RChangePropertyOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RChangePropertyOperation(handler, o);
                }
            }
          
            // downcast to RClickReferencePointOperation:
            {
                RClickReferencePointOperation* o = dynamic_cast<RClickReferencePointOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RClickReferencePointOperation(handler, o);
                }
            }
          
            // downcast to RClipboardOperation:
            {
                RClipboardOperation* o = dynamic_cast<RClipboardOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RClipboardOperation(handler, o);
                }
            }
          
            // downcast to RDeleteAllEntitiesOperation:
            {
                RDeleteAllEntitiesOperation* o = dynamic_cast<RDeleteAllEntitiesOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDeleteAllEntitiesOperation(handler, o);
                }
            }
          
            // downcast to RDeleteObjectsOperation:
            {
                RDeleteObjectsOperation* o = dynamic_cast<RDeleteObjectsOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RDeleteObjectsOperation(handler, o);
                }
            }
          
            // downcast to RMixedOperation:
            {
                RMixedOperation* o = dynamic_cast<RMixedOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RMixedOperation(handler, o);
                }
            }
          
            // downcast to RMoveReferencePointOperation:
            {
                RMoveReferencePointOperation* o = dynamic_cast<RMoveReferencePointOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RMoveReferencePointOperation(handler, o);
                }
            }
          
            // downcast to RMoveSelectionOperation:
            {
                RMoveSelectionOperation* o = dynamic_cast<RMoveSelectionOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RMoveSelectionOperation(handler, o);
                }
            }
          
            // downcast to RScaleSelectionOperation:
            {
                RScaleSelectionOperation* o = dynamic_cast<RScaleSelectionOperation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RScaleSelectionOperation(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          ROperation_Wrapper* ret = new ROperation_Wrapper(handler, v, false);

          // JS: new ROperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("ROperation");
          if (cl.isUndefined()) {
              qWarning() << "Class ROperation is undefined. Use ROperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new ROperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new ROperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      ROperation* RJSHelper_qcad::js2cpp_ROperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_ROperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //ROperation_Wrapper* wrapper = qobject_cast<ROperation_Wrapper*>(obj);
          //ROperation_Wrapper* wrapper = dynamic_cast<ROperation_Wrapper*>(obj);
          //ROperation_Wrapper* wrapper = (ROperation_Wrapper*)(obj);
          //ROperation_Wrapper* wrapper = getWrapper<ROperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_ROperation_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_ROperation(wrapper);
          return ROperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_ROperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_ROperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_ROperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_ROperationUtils(RJSApi& handler, ROperationUtils* v) {

          

          QJSEngine* engine = handler.getEngine();
          ROperationUtils_Wrapper* ret = new ROperationUtils_Wrapper(handler, v, false);

          // JS: new ROperationUtils('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("ROperationUtils");
          if (cl.isUndefined()) {
              qWarning() << "Class ROperationUtils is undefined. Use ROperationUtils_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new ROperationUtils('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new ROperationUtils(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      ROperationUtils* RJSHelper_qcad::js2cpp_ROperationUtils_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_ROperationUtils: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //ROperationUtils_Wrapper* wrapper = qobject_cast<ROperationUtils_Wrapper*>(obj);
          //ROperationUtils_Wrapper* wrapper = dynamic_cast<ROperationUtils_Wrapper*>(obj);
          //ROperationUtils_Wrapper* wrapper = (ROperationUtils_Wrapper*)(obj);
          //ROperationUtils_Wrapper* wrapper = getWrapper<ROperationUtils_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_ROperationUtils_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_ROperationUtils(wrapper);
          return ROperationUtils_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_ROperationUtils_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_ROperationUtils: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_ROperationUtils::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_ROrthoGrid(RJSApi& handler, ROrthoGrid* v) {

          

          QJSEngine* engine = handler.getEngine();
          ROrthoGrid_Wrapper* ret = new ROrthoGrid_Wrapper(handler, v, false);

          // JS: new ROrthoGrid('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("ROrthoGrid");
          if (cl.isUndefined()) {
              qWarning() << "Class ROrthoGrid is undefined. Use ROrthoGrid_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new ROrthoGrid('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new ROrthoGrid(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      ROrthoGrid* RJSHelper_qcad::js2cpp_ROrthoGrid_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_ROrthoGrid: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //ROrthoGrid_Wrapper* wrapper = qobject_cast<ROrthoGrid_Wrapper*>(obj);
          //ROrthoGrid_Wrapper* wrapper = dynamic_cast<ROrthoGrid_Wrapper*>(obj);
          //ROrthoGrid_Wrapper* wrapper = (ROrthoGrid_Wrapper*)(obj);
          //ROrthoGrid_Wrapper* wrapper = getWrapper<ROrthoGrid_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_ROrthoGrid_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_ROrthoGrid(wrapper);
          return ROrthoGrid_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_ROrthoGrid_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_ROrthoGrid: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_ROrthoGrid::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPaletteListener(RJSApi& handler, RPaletteListener* v) {

          
            // downcast to RPaletteListenerAdapter:
            {
                RPaletteListenerAdapter* o = dynamic_cast<RPaletteListenerAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RPaletteListenerAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RPaletteListener_Wrapper* ret = new RPaletteListener_Wrapper(handler, v, false);

          // JS: new RPaletteListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPaletteListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RPaletteListener is undefined. Use RPaletteListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPaletteListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPaletteListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RPaletteListener* RJSHelper_qcad::js2cpp_RPaletteListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPaletteListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPaletteListener_Wrapper* wrapper = qobject_cast<RPaletteListener_Wrapper*>(obj);
          //RPaletteListener_Wrapper* wrapper = dynamic_cast<RPaletteListener_Wrapper*>(obj);
          //RPaletteListener_Wrapper* wrapper = (RPaletteListener_Wrapper*)(obj);
          //RPaletteListener_Wrapper* wrapper = getWrapper<RPaletteListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPaletteListener_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RPaletteListener(wrapper);
          return RPaletteListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPaletteListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPaletteListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RPaletteListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPasteOperation(RJSApi& handler, RPasteOperation* v) {

          

          QJSEngine* engine = handler.getEngine();
          RPasteOperation_Wrapper* ret = new RPasteOperation_Wrapper(handler, v, false);

          // JS: new RPasteOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPasteOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RPasteOperation is undefined. Use RPasteOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPasteOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPasteOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RPasteOperation* RJSHelper_qcad::js2cpp_RPasteOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPasteOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPasteOperation_Wrapper* wrapper = qobject_cast<RPasteOperation_Wrapper*>(obj);
          //RPasteOperation_Wrapper* wrapper = dynamic_cast<RPasteOperation_Wrapper*>(obj);
          //RPasteOperation_Wrapper* wrapper = (RPasteOperation_Wrapper*)(obj);
          //RPasteOperation_Wrapper* wrapper = getWrapper<RPasteOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPasteOperation_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RPasteOperation(wrapper);
          return RPasteOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPasteOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPasteOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RPasteOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPenListener(RJSApi& handler, RPenListener* v) {

          
            // downcast to RPenListenerAdapter:
            {
                RPenListenerAdapter* o = dynamic_cast<RPenListenerAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RPenListenerAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RPenListener_Wrapper* ret = new RPenListener_Wrapper(handler, v, false);

          // JS: new RPenListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPenListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RPenListener is undefined. Use RPenListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPenListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPenListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RPenListener* RJSHelper_qcad::js2cpp_RPenListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPenListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPenListener_Wrapper* wrapper = qobject_cast<RPenListener_Wrapper*>(obj);
          //RPenListener_Wrapper* wrapper = dynamic_cast<RPenListener_Wrapper*>(obj);
          //RPenListener_Wrapper* wrapper = (RPenListener_Wrapper*)(obj);
          //RPenListener_Wrapper* wrapper = getWrapper<RPenListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPenListener_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RPenListener(wrapper);
          return RPenListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPenListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPenListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RPenListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPluginInterface(RJSApi& handler, RPluginInterface* v) {

          

          QJSEngine* engine = handler.getEngine();
          RPluginInterface_Wrapper* ret = new RPluginInterface_Wrapper(handler, v, false);

          // JS: new RPluginInterface('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPluginInterface");
          if (cl.isUndefined()) {
              qWarning() << "Class RPluginInterface is undefined. Use RPluginInterface_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPluginInterface('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPluginInterface(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RPluginInterface* RJSHelper_qcad::js2cpp_RPluginInterface_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPluginInterface: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPluginInterface_Wrapper* wrapper = qobject_cast<RPluginInterface_Wrapper*>(obj);
          //RPluginInterface_Wrapper* wrapper = dynamic_cast<RPluginInterface_Wrapper*>(obj);
          //RPluginInterface_Wrapper* wrapper = (RPluginInterface_Wrapper*)(obj);
          //RPluginInterface_Wrapper* wrapper = getWrapper<RPluginInterface_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPluginInterface_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RPluginInterface(wrapper);
          return RPluginInterface_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPluginInterface_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPluginInterface: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RPluginInterface::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPointEntity(RJSApi& handler, RPointEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RPointEntity_Wrapper* ret = new RPointEntity_Wrapper(handler, v, false);

          // JS: new RPointEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPointEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RPointEntity is undefined. Use RPointEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPointEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPointEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RPointEntity* RJSHelper_qcad::js2cpp_RPointEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPointEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPointEntity_Wrapper* wrapper = qobject_cast<RPointEntity_Wrapper*>(obj);
          //RPointEntity_Wrapper* wrapper = dynamic_cast<RPointEntity_Wrapper*>(obj);
          //RPointEntity_Wrapper* wrapper = (RPointEntity_Wrapper*)(obj);
          //RPointEntity_Wrapper* wrapper = getWrapper<RPointEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPointEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RPointEntity(wrapper);
          return RPointEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPointEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPointEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RPointEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPolylineEntity(RJSApi& handler, RPolylineEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RPolylineEntity_Wrapper* ret = new RPolylineEntity_Wrapper(handler, v, false);

          // JS: new RPolylineEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPolylineEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RPolylineEntity is undefined. Use RPolylineEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPolylineEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPolylineEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RPolylineEntity* RJSHelper_qcad::js2cpp_RPolylineEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPolylineEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPolylineEntity_Wrapper* wrapper = qobject_cast<RPolylineEntity_Wrapper*>(obj);
          //RPolylineEntity_Wrapper* wrapper = dynamic_cast<RPolylineEntity_Wrapper*>(obj);
          //RPolylineEntity_Wrapper* wrapper = (RPolylineEntity_Wrapper*)(obj);
          //RPolylineEntity_Wrapper* wrapper = getWrapper<RPolylineEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPolylineEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RPolylineEntity(wrapper);
          return RPolylineEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPolylineEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPolylineEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RPolylineEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPreferencesListener(RJSApi& handler, RPreferencesListener* v) {

          
            // downcast to RPreferencesListenerAdapter:
            {
                RPreferencesListenerAdapter* o = dynamic_cast<RPreferencesListenerAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RPreferencesListenerAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RPreferencesListener_Wrapper* ret = new RPreferencesListener_Wrapper(handler, v, false);

          // JS: new RPreferencesListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPreferencesListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RPreferencesListener is undefined. Use RPreferencesListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPreferencesListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPreferencesListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RPreferencesListener* RJSHelper_qcad::js2cpp_RPreferencesListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPreferencesListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPreferencesListener_Wrapper* wrapper = qobject_cast<RPreferencesListener_Wrapper*>(obj);
          //RPreferencesListener_Wrapper* wrapper = dynamic_cast<RPreferencesListener_Wrapper*>(obj);
          //RPreferencesListener_Wrapper* wrapper = (RPreferencesListener_Wrapper*)(obj);
          //RPreferencesListener_Wrapper* wrapper = getWrapper<RPreferencesListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPreferencesListener_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RPreferencesListener(wrapper);
          return RPreferencesListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPreferencesListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPreferencesListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RPreferencesListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RProgressHandler(RJSApi& handler, RProgressHandler* v) {

          

          QJSEngine* engine = handler.getEngine();
          RProgressHandler_Wrapper* ret = new RProgressHandler_Wrapper(handler, v, false);

          // JS: new RProgressHandler('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RProgressHandler");
          if (cl.isUndefined()) {
              qWarning() << "Class RProgressHandler is undefined. Use RProgressHandler_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RProgressHandler('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RProgressHandler(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RProgressHandler* RJSHelper_qcad::js2cpp_RProgressHandler_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RProgressHandler: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RProgressHandler_Wrapper* wrapper = qobject_cast<RProgressHandler_Wrapper*>(obj);
          //RProgressHandler_Wrapper* wrapper = dynamic_cast<RProgressHandler_Wrapper*>(obj);
          //RProgressHandler_Wrapper* wrapper = (RProgressHandler_Wrapper*)(obj);
          //RProgressHandler_Wrapper* wrapper = getWrapper<RProgressHandler_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RProgressHandler_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RProgressHandler(wrapper);
          return RProgressHandler_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RProgressHandler_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RProgressHandler: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RProgressHandler::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPropertyEvent(RJSApi& handler, RPropertyEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          RPropertyEvent_Wrapper* ret = new RPropertyEvent_Wrapper(handler, v, false);

          // JS: new RPropertyEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPropertyEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class RPropertyEvent is undefined. Use RPropertyEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPropertyEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPropertyEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RPropertyEvent* RJSHelper_qcad::js2cpp_RPropertyEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPropertyEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPropertyEvent_Wrapper* wrapper = qobject_cast<RPropertyEvent_Wrapper*>(obj);
          //RPropertyEvent_Wrapper* wrapper = dynamic_cast<RPropertyEvent_Wrapper*>(obj);
          //RPropertyEvent_Wrapper* wrapper = (RPropertyEvent_Wrapper*)(obj);
          //RPropertyEvent_Wrapper* wrapper = getWrapper<RPropertyEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPropertyEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RPropertyEvent(wrapper);
          return RPropertyEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPropertyEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPropertyEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RPropertyEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPropertyListener(RJSApi& handler, RPropertyListener* v) {

          
            // downcast to RPropertyListenerAdapter:
            {
                RPropertyListenerAdapter* o = dynamic_cast<RPropertyListenerAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RPropertyListenerAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RPropertyListener_Wrapper* ret = new RPropertyListener_Wrapper(handler, v, false);

          // JS: new RPropertyListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPropertyListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RPropertyListener is undefined. Use RPropertyListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPropertyListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPropertyListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RPropertyListener* RJSHelper_qcad::js2cpp_RPropertyListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPropertyListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPropertyListener_Wrapper* wrapper = qobject_cast<RPropertyListener_Wrapper*>(obj);
          //RPropertyListener_Wrapper* wrapper = dynamic_cast<RPropertyListener_Wrapper*>(obj);
          //RPropertyListener_Wrapper* wrapper = (RPropertyListener_Wrapper*)(obj);
          //RPropertyListener_Wrapper* wrapper = getWrapper<RPropertyListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPropertyListener_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RPropertyListener(wrapper);
          return RPropertyListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPropertyListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPropertyListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RPropertyListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RRayEntity(RJSApi& handler, RRayEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RRayEntity_Wrapper* ret = new RRayEntity_Wrapper(handler, v, false);

          // JS: new RRayEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRayEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RRayEntity is undefined. Use RRayEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RRayEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RRayEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RRayEntity* RJSHelper_qcad::js2cpp_RRayEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RRayEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RRayEntity_Wrapper* wrapper = qobject_cast<RRayEntity_Wrapper*>(obj);
          //RRayEntity_Wrapper* wrapper = dynamic_cast<RRayEntity_Wrapper*>(obj);
          //RRayEntity_Wrapper* wrapper = (RRayEntity_Wrapper*)(obj);
          //RRayEntity_Wrapper* wrapper = getWrapper<RRayEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RRayEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RRayEntity(wrapper);
          return RRayEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RRayEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RRayEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RRayEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RRestrictAngleLength(RJSApi& handler, RRestrictAngleLength* v) {

          

          QJSEngine* engine = handler.getEngine();
          RRestrictAngleLength_Wrapper* ret = new RRestrictAngleLength_Wrapper(handler, v, false);

          // JS: new RRestrictAngleLength('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRestrictAngleLength");
          if (cl.isUndefined()) {
              qWarning() << "Class RRestrictAngleLength is undefined. Use RRestrictAngleLength_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RRestrictAngleLength('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RRestrictAngleLength(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RRestrictAngleLength* RJSHelper_qcad::js2cpp_RRestrictAngleLength_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RRestrictAngleLength: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RRestrictAngleLength_Wrapper* wrapper = qobject_cast<RRestrictAngleLength_Wrapper*>(obj);
          //RRestrictAngleLength_Wrapper* wrapper = dynamic_cast<RRestrictAngleLength_Wrapper*>(obj);
          //RRestrictAngleLength_Wrapper* wrapper = (RRestrictAngleLength_Wrapper*)(obj);
          //RRestrictAngleLength_Wrapper* wrapper = getWrapper<RRestrictAngleLength_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RRestrictAngleLength_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RRestrictAngleLength(wrapper);
          return RRestrictAngleLength_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RRestrictAngleLength_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RRestrictAngleLength: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RRestrictAngleLength::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RRestrictHorizontal(RJSApi& handler, RRestrictHorizontal* v) {

          

          QJSEngine* engine = handler.getEngine();
          RRestrictHorizontal_Wrapper* ret = new RRestrictHorizontal_Wrapper(handler, v, false);

          // JS: new RRestrictHorizontal('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRestrictHorizontal");
          if (cl.isUndefined()) {
              qWarning() << "Class RRestrictHorizontal is undefined. Use RRestrictHorizontal_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RRestrictHorizontal('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RRestrictHorizontal(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RRestrictHorizontal* RJSHelper_qcad::js2cpp_RRestrictHorizontal_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RRestrictHorizontal: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RRestrictHorizontal_Wrapper* wrapper = qobject_cast<RRestrictHorizontal_Wrapper*>(obj);
          //RRestrictHorizontal_Wrapper* wrapper = dynamic_cast<RRestrictHorizontal_Wrapper*>(obj);
          //RRestrictHorizontal_Wrapper* wrapper = (RRestrictHorizontal_Wrapper*)(obj);
          //RRestrictHorizontal_Wrapper* wrapper = getWrapper<RRestrictHorizontal_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RRestrictHorizontal_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RRestrictHorizontal(wrapper);
          return RRestrictHorizontal_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RRestrictHorizontal_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RRestrictHorizontal: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RRestrictHorizontal::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RRestrictOff(RJSApi& handler, RRestrictOff* v) {

          

          QJSEngine* engine = handler.getEngine();
          RRestrictOff_Wrapper* ret = new RRestrictOff_Wrapper(handler, v, false);

          // JS: new RRestrictOff('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRestrictOff");
          if (cl.isUndefined()) {
              qWarning() << "Class RRestrictOff is undefined. Use RRestrictOff_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RRestrictOff('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RRestrictOff(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RRestrictOff* RJSHelper_qcad::js2cpp_RRestrictOff_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RRestrictOff: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RRestrictOff_Wrapper* wrapper = qobject_cast<RRestrictOff_Wrapper*>(obj);
          //RRestrictOff_Wrapper* wrapper = dynamic_cast<RRestrictOff_Wrapper*>(obj);
          //RRestrictOff_Wrapper* wrapper = (RRestrictOff_Wrapper*)(obj);
          //RRestrictOff_Wrapper* wrapper = getWrapper<RRestrictOff_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RRestrictOff_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RRestrictOff(wrapper);
          return RRestrictOff_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RRestrictOff_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RRestrictOff: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RRestrictOff::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RRestrictOrthogonal(RJSApi& handler, RRestrictOrthogonal* v) {

          
            // downcast to RRestrictHorizontal:
            {
                RRestrictHorizontal* o = dynamic_cast<RRestrictHorizontal*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RRestrictHorizontal(handler, o);
                }
            }
          
            // downcast to RRestrictVertical:
            {
                RRestrictVertical* o = dynamic_cast<RRestrictVertical*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RRestrictVertical(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RRestrictOrthogonal_Wrapper* ret = new RRestrictOrthogonal_Wrapper(handler, v, false);

          // JS: new RRestrictOrthogonal('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRestrictOrthogonal");
          if (cl.isUndefined()) {
              qWarning() << "Class RRestrictOrthogonal is undefined. Use RRestrictOrthogonal_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RRestrictOrthogonal('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RRestrictOrthogonal(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RRestrictOrthogonal* RJSHelper_qcad::js2cpp_RRestrictOrthogonal_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RRestrictOrthogonal: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RRestrictOrthogonal_Wrapper* wrapper = qobject_cast<RRestrictOrthogonal_Wrapper*>(obj);
          //RRestrictOrthogonal_Wrapper* wrapper = dynamic_cast<RRestrictOrthogonal_Wrapper*>(obj);
          //RRestrictOrthogonal_Wrapper* wrapper = (RRestrictOrthogonal_Wrapper*)(obj);
          //RRestrictOrthogonal_Wrapper* wrapper = getWrapper<RRestrictOrthogonal_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RRestrictOrthogonal_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RRestrictOrthogonal(wrapper);
          return RRestrictOrthogonal_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RRestrictOrthogonal_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RRestrictOrthogonal: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RRestrictOrthogonal::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RRestrictVertical(RJSApi& handler, RRestrictVertical* v) {

          

          QJSEngine* engine = handler.getEngine();
          RRestrictVertical_Wrapper* ret = new RRestrictVertical_Wrapper(handler, v, false);

          // JS: new RRestrictVertical('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRestrictVertical");
          if (cl.isUndefined()) {
              qWarning() << "Class RRestrictVertical is undefined. Use RRestrictVertical_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RRestrictVertical('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RRestrictVertical(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RRestrictVertical* RJSHelper_qcad::js2cpp_RRestrictVertical_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RRestrictVertical: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RRestrictVertical_Wrapper* wrapper = qobject_cast<RRestrictVertical_Wrapper*>(obj);
          //RRestrictVertical_Wrapper* wrapper = dynamic_cast<RRestrictVertical_Wrapper*>(obj);
          //RRestrictVertical_Wrapper* wrapper = (RRestrictVertical_Wrapper*)(obj);
          //RRestrictVertical_Wrapper* wrapper = getWrapper<RRestrictVertical_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RRestrictVertical_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RRestrictVertical(wrapper);
          return RRestrictVertical_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RRestrictVertical_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RRestrictVertical: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RRestrictVertical::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RRuler(RJSApi& handler, RRuler* v) {

          

          QJSEngine* engine = handler.getEngine();
          RRuler_Wrapper* ret = new RRuler_Wrapper(handler, v, false);

          // JS: new RRuler('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRuler");
          if (cl.isUndefined()) {
              qWarning() << "Class RRuler is undefined. Use RRuler_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RRuler('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RRuler(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RRuler* RJSHelper_qcad::js2cpp_RRuler_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RRuler: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RRuler_Wrapper* wrapper = qobject_cast<RRuler_Wrapper*>(obj);
          //RRuler_Wrapper* wrapper = dynamic_cast<RRuler_Wrapper*>(obj);
          //RRuler_Wrapper* wrapper = (RRuler_Wrapper*)(obj);
          //RRuler_Wrapper* wrapper = getWrapper<RRuler_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RRuler_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RRuler(wrapper);
          return RRuler_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RRuler_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RRuler: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RRuler::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RScaleSelectionOperation(RJSApi& handler, RScaleSelectionOperation* v) {

          

          QJSEngine* engine = handler.getEngine();
          RScaleSelectionOperation_Wrapper* ret = new RScaleSelectionOperation_Wrapper(handler, v, false);

          // JS: new RScaleSelectionOperation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RScaleSelectionOperation");
          if (cl.isUndefined()) {
              qWarning() << "Class RScaleSelectionOperation is undefined. Use RScaleSelectionOperation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RScaleSelectionOperation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RScaleSelectionOperation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RScaleSelectionOperation* RJSHelper_qcad::js2cpp_RScaleSelectionOperation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RScaleSelectionOperation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RScaleSelectionOperation_Wrapper* wrapper = qobject_cast<RScaleSelectionOperation_Wrapper*>(obj);
          //RScaleSelectionOperation_Wrapper* wrapper = dynamic_cast<RScaleSelectionOperation_Wrapper*>(obj);
          //RScaleSelectionOperation_Wrapper* wrapper = (RScaleSelectionOperation_Wrapper*)(obj);
          //RScaleSelectionOperation_Wrapper* wrapper = getWrapper<RScaleSelectionOperation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RScaleSelectionOperation_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RScaleSelectionOperation(wrapper);
          return RScaleSelectionOperation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RScaleSelectionOperation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RScaleSelectionOperation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RScaleSelectionOperation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSelectionListener(RJSApi& handler, RSelectionListener* v) {

          
            // downcast to RSelectionListenerAdapter:
            {
                RSelectionListenerAdapter* o = dynamic_cast<RSelectionListenerAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSelectionListenerAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RSelectionListener_Wrapper* ret = new RSelectionListener_Wrapper(handler, v, false);

          // JS: new RSelectionListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSelectionListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RSelectionListener is undefined. Use RSelectionListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSelectionListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSelectionListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSelectionListener* RJSHelper_qcad::js2cpp_RSelectionListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSelectionListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSelectionListener_Wrapper* wrapper = qobject_cast<RSelectionListener_Wrapper*>(obj);
          //RSelectionListener_Wrapper* wrapper = dynamic_cast<RSelectionListener_Wrapper*>(obj);
          //RSelectionListener_Wrapper* wrapper = (RSelectionListener_Wrapper*)(obj);
          //RSelectionListener_Wrapper* wrapper = getWrapper<RSelectionListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSelectionListener_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RSelectionListener(wrapper);
          return RSelectionListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSelectionListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSelectionListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSelectionListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnap(RJSApi& handler, RSnap* v) {

          
            // downcast to RSnapAuto:
            {
                RSnapAuto* o = dynamic_cast<RSnapAuto*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSnapAuto(handler, o);
                }
            }
          
            // downcast to RSnapEntityBase:
            {
                RSnapEntityBase* o = dynamic_cast<RSnapEntityBase*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSnapEntityBase(handler, o);
                }
            }
          
            // downcast to RSnapFree:
            {
                RSnapFree* o = dynamic_cast<RSnapFree*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSnapFree(handler, o);
                }
            }
          
            // downcast to RSnapGrid:
            {
                RSnapGrid* o = dynamic_cast<RSnapGrid*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSnapGrid(handler, o);
                }
            }
          
            // downcast to RSnapIntersection:
            {
                RSnapIntersection* o = dynamic_cast<RSnapIntersection*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSnapIntersection(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RSnap_Wrapper* ret = new RSnap_Wrapper(handler, v, false);

          // JS: new RSnap('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnap");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnap is undefined. Use RSnap_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnap('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnap(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnap* RJSHelper_qcad::js2cpp_RSnap_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnap: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnap_Wrapper* wrapper = qobject_cast<RSnap_Wrapper*>(obj);
          //RSnap_Wrapper* wrapper = dynamic_cast<RSnap_Wrapper*>(obj);
          //RSnap_Wrapper* wrapper = (RSnap_Wrapper*)(obj);
          //RSnap_Wrapper* wrapper = getWrapper<RSnap_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnap_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RSnap(wrapper);
          return RSnap_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnap_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnap: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnap::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapAuto(RJSApi& handler, RSnapAuto* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSnapAuto_Wrapper* ret = new RSnapAuto_Wrapper(handler, v, false);

          // JS: new RSnapAuto('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapAuto");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapAuto is undefined. Use RSnapAuto_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapAuto('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapAuto(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapAuto* RJSHelper_qcad::js2cpp_RSnapAuto_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapAuto: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapAuto_Wrapper* wrapper = qobject_cast<RSnapAuto_Wrapper*>(obj);
          //RSnapAuto_Wrapper* wrapper = dynamic_cast<RSnapAuto_Wrapper*>(obj);
          //RSnapAuto_Wrapper* wrapper = (RSnapAuto_Wrapper*)(obj);
          //RSnapAuto_Wrapper* wrapper = getWrapper<RSnapAuto_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapAuto_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RSnapAuto(wrapper);
          return RSnapAuto_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapAuto_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapAuto: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapAuto::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapCenter(RJSApi& handler, RSnapCenter* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSnapCenter_Wrapper* ret = new RSnapCenter_Wrapper(handler, v, false);

          // JS: new RSnapCenter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapCenter");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapCenter is undefined. Use RSnapCenter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapCenter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapCenter(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapCenter* RJSHelper_qcad::js2cpp_RSnapCenter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapCenter: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapCenter_Wrapper* wrapper = qobject_cast<RSnapCenter_Wrapper*>(obj);
          //RSnapCenter_Wrapper* wrapper = dynamic_cast<RSnapCenter_Wrapper*>(obj);
          //RSnapCenter_Wrapper* wrapper = (RSnapCenter_Wrapper*)(obj);
          //RSnapCenter_Wrapper* wrapper = getWrapper<RSnapCenter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapCenter_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RSnapCenter(wrapper);
          return RSnapCenter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapCenter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapCenter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapCenter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapDistance(RJSApi& handler, RSnapDistance* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSnapDistance_Wrapper* ret = new RSnapDistance_Wrapper(handler, v, false);

          // JS: new RSnapDistance('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapDistance");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapDistance is undefined. Use RSnapDistance_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapDistance('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapDistance(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapDistance* RJSHelper_qcad::js2cpp_RSnapDistance_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapDistance: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapDistance_Wrapper* wrapper = qobject_cast<RSnapDistance_Wrapper*>(obj);
          //RSnapDistance_Wrapper* wrapper = dynamic_cast<RSnapDistance_Wrapper*>(obj);
          //RSnapDistance_Wrapper* wrapper = (RSnapDistance_Wrapper*)(obj);
          //RSnapDistance_Wrapper* wrapper = getWrapper<RSnapDistance_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapDistance_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RSnapDistance(wrapper);
          return RSnapDistance_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapDistance_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapDistance: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapDistance::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapEnd(RJSApi& handler, RSnapEnd* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSnapEnd_Wrapper* ret = new RSnapEnd_Wrapper(handler, v, false);

          // JS: new RSnapEnd('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapEnd");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapEnd is undefined. Use RSnapEnd_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapEnd('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapEnd(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapEnd* RJSHelper_qcad::js2cpp_RSnapEnd_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapEnd: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapEnd_Wrapper* wrapper = qobject_cast<RSnapEnd_Wrapper*>(obj);
          //RSnapEnd_Wrapper* wrapper = dynamic_cast<RSnapEnd_Wrapper*>(obj);
          //RSnapEnd_Wrapper* wrapper = (RSnapEnd_Wrapper*)(obj);
          //RSnapEnd_Wrapper* wrapper = getWrapper<RSnapEnd_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapEnd_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RSnapEnd(wrapper);
          return RSnapEnd_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapEnd_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapEnd: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapEnd::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapEntityBase(RJSApi& handler, RSnapEntityBase* v) {

          
            // downcast to RSnapCenter:
            {
                RSnapCenter* o = dynamic_cast<RSnapCenter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSnapCenter(handler, o);
                }
            }
          
            // downcast to RSnapDistance:
            {
                RSnapDistance* o = dynamic_cast<RSnapDistance*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSnapDistance(handler, o);
                }
            }
          
            // downcast to RSnapEnd:
            {
                RSnapEnd* o = dynamic_cast<RSnapEnd*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSnapEnd(handler, o);
                }
            }
          
            // downcast to RSnapMiddle:
            {
                RSnapMiddle* o = dynamic_cast<RSnapMiddle*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSnapMiddle(handler, o);
                }
            }
          
            // downcast to RSnapOnEntity:
            {
                RSnapOnEntity* o = dynamic_cast<RSnapOnEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSnapOnEntity(handler, o);
                }
            }
          
            // downcast to RSnapPerpendicular:
            {
                RSnapPerpendicular* o = dynamic_cast<RSnapPerpendicular*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSnapPerpendicular(handler, o);
                }
            }
          
            // downcast to RSnapReference:
            {
                RSnapReference* o = dynamic_cast<RSnapReference*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSnapReference(handler, o);
                }
            }
          
            // downcast to RSnapTangential:
            {
                RSnapTangential* o = dynamic_cast<RSnapTangential*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSnapTangential(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RSnapEntityBase_Wrapper* ret = new RSnapEntityBase_Wrapper(handler, v, false);

          // JS: new RSnapEntityBase('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapEntityBase");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapEntityBase is undefined. Use RSnapEntityBase_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapEntityBase('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapEntityBase(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapEntityBase* RJSHelper_qcad::js2cpp_RSnapEntityBase_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapEntityBase: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapEntityBase_Wrapper* wrapper = qobject_cast<RSnapEntityBase_Wrapper*>(obj);
          //RSnapEntityBase_Wrapper* wrapper = dynamic_cast<RSnapEntityBase_Wrapper*>(obj);
          //RSnapEntityBase_Wrapper* wrapper = (RSnapEntityBase_Wrapper*)(obj);
          //RSnapEntityBase_Wrapper* wrapper = getWrapper<RSnapEntityBase_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapEntityBase_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RSnapEntityBase(wrapper);
          return RSnapEntityBase_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapEntityBase_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapEntityBase: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapEntityBase::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapFree(RJSApi& handler, RSnapFree* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSnapFree_Wrapper* ret = new RSnapFree_Wrapper(handler, v, false);

          // JS: new RSnapFree('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapFree");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapFree is undefined. Use RSnapFree_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapFree('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapFree(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapFree* RJSHelper_qcad::js2cpp_RSnapFree_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapFree: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapFree_Wrapper* wrapper = qobject_cast<RSnapFree_Wrapper*>(obj);
          //RSnapFree_Wrapper* wrapper = dynamic_cast<RSnapFree_Wrapper*>(obj);
          //RSnapFree_Wrapper* wrapper = (RSnapFree_Wrapper*)(obj);
          //RSnapFree_Wrapper* wrapper = getWrapper<RSnapFree_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapFree_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RSnapFree(wrapper);
          return RSnapFree_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapFree_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapFree: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapFree::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapGrid(RJSApi& handler, RSnapGrid* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSnapGrid_Wrapper* ret = new RSnapGrid_Wrapper(handler, v, false);

          // JS: new RSnapGrid('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapGrid");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapGrid is undefined. Use RSnapGrid_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapGrid('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapGrid(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapGrid* RJSHelper_qcad::js2cpp_RSnapGrid_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapGrid: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapGrid_Wrapper* wrapper = qobject_cast<RSnapGrid_Wrapper*>(obj);
          //RSnapGrid_Wrapper* wrapper = dynamic_cast<RSnapGrid_Wrapper*>(obj);
          //RSnapGrid_Wrapper* wrapper = (RSnapGrid_Wrapper*)(obj);
          //RSnapGrid_Wrapper* wrapper = getWrapper<RSnapGrid_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapGrid_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RSnapGrid(wrapper);
          return RSnapGrid_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapGrid_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapGrid: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapGrid::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapIntersection(RJSApi& handler, RSnapIntersection* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSnapIntersection_Wrapper* ret = new RSnapIntersection_Wrapper(handler, v, false);

          // JS: new RSnapIntersection('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapIntersection");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapIntersection is undefined. Use RSnapIntersection_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapIntersection('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapIntersection(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapIntersection* RJSHelper_qcad::js2cpp_RSnapIntersection_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapIntersection: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapIntersection_Wrapper* wrapper = qobject_cast<RSnapIntersection_Wrapper*>(obj);
          //RSnapIntersection_Wrapper* wrapper = dynamic_cast<RSnapIntersection_Wrapper*>(obj);
          //RSnapIntersection_Wrapper* wrapper = (RSnapIntersection_Wrapper*)(obj);
          //RSnapIntersection_Wrapper* wrapper = getWrapper<RSnapIntersection_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapIntersection_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RSnapIntersection(wrapper);
          return RSnapIntersection_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapIntersection_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapIntersection: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapIntersection::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapListener(RJSApi& handler, RSnapListener* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSnapListener_Wrapper* ret = new RSnapListener_Wrapper(handler, v, false);

          // JS: new RSnapListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapListener is undefined. Use RSnapListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapListener* RJSHelper_qcad::js2cpp_RSnapListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapListener_Wrapper* wrapper = qobject_cast<RSnapListener_Wrapper*>(obj);
          //RSnapListener_Wrapper* wrapper = dynamic_cast<RSnapListener_Wrapper*>(obj);
          //RSnapListener_Wrapper* wrapper = (RSnapListener_Wrapper*)(obj);
          //RSnapListener_Wrapper* wrapper = getWrapper<RSnapListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapListener_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RSnapListener(wrapper);
          return RSnapListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapMiddle(RJSApi& handler, RSnapMiddle* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSnapMiddle_Wrapper* ret = new RSnapMiddle_Wrapper(handler, v, false);

          // JS: new RSnapMiddle('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapMiddle");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapMiddle is undefined. Use RSnapMiddle_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapMiddle('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapMiddle(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapMiddle* RJSHelper_qcad::js2cpp_RSnapMiddle_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapMiddle: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapMiddle_Wrapper* wrapper = qobject_cast<RSnapMiddle_Wrapper*>(obj);
          //RSnapMiddle_Wrapper* wrapper = dynamic_cast<RSnapMiddle_Wrapper*>(obj);
          //RSnapMiddle_Wrapper* wrapper = (RSnapMiddle_Wrapper*)(obj);
          //RSnapMiddle_Wrapper* wrapper = getWrapper<RSnapMiddle_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapMiddle_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RSnapMiddle(wrapper);
          return RSnapMiddle_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapMiddle_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapMiddle: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapMiddle::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapOnEntity(RJSApi& handler, RSnapOnEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSnapOnEntity_Wrapper* ret = new RSnapOnEntity_Wrapper(handler, v, false);

          // JS: new RSnapOnEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapOnEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapOnEntity is undefined. Use RSnapOnEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapOnEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapOnEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapOnEntity* RJSHelper_qcad::js2cpp_RSnapOnEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapOnEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapOnEntity_Wrapper* wrapper = qobject_cast<RSnapOnEntity_Wrapper*>(obj);
          //RSnapOnEntity_Wrapper* wrapper = dynamic_cast<RSnapOnEntity_Wrapper*>(obj);
          //RSnapOnEntity_Wrapper* wrapper = (RSnapOnEntity_Wrapper*)(obj);
          //RSnapOnEntity_Wrapper* wrapper = getWrapper<RSnapOnEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapOnEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RSnapOnEntity(wrapper);
          return RSnapOnEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapOnEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapOnEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapOnEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapPerpendicular(RJSApi& handler, RSnapPerpendicular* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSnapPerpendicular_Wrapper* ret = new RSnapPerpendicular_Wrapper(handler, v, false);

          // JS: new RSnapPerpendicular('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapPerpendicular");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapPerpendicular is undefined. Use RSnapPerpendicular_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapPerpendicular('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapPerpendicular(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapPerpendicular* RJSHelper_qcad::js2cpp_RSnapPerpendicular_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapPerpendicular: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapPerpendicular_Wrapper* wrapper = qobject_cast<RSnapPerpendicular_Wrapper*>(obj);
          //RSnapPerpendicular_Wrapper* wrapper = dynamic_cast<RSnapPerpendicular_Wrapper*>(obj);
          //RSnapPerpendicular_Wrapper* wrapper = (RSnapPerpendicular_Wrapper*)(obj);
          //RSnapPerpendicular_Wrapper* wrapper = getWrapper<RSnapPerpendicular_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapPerpendicular_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RSnapPerpendicular(wrapper);
          return RSnapPerpendicular_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapPerpendicular_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapPerpendicular: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapPerpendicular::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapReference(RJSApi& handler, RSnapReference* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSnapReference_Wrapper* ret = new RSnapReference_Wrapper(handler, v, false);

          // JS: new RSnapReference('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapReference");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapReference is undefined. Use RSnapReference_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapReference('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapReference(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapReference* RJSHelper_qcad::js2cpp_RSnapReference_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapReference: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapReference_Wrapper* wrapper = qobject_cast<RSnapReference_Wrapper*>(obj);
          //RSnapReference_Wrapper* wrapper = dynamic_cast<RSnapReference_Wrapper*>(obj);
          //RSnapReference_Wrapper* wrapper = (RSnapReference_Wrapper*)(obj);
          //RSnapReference_Wrapper* wrapper = getWrapper<RSnapReference_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapReference_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RSnapReference(wrapper);
          return RSnapReference_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapReference_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapReference: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapReference::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapRestriction(RJSApi& handler, RSnapRestriction* v) {

          
            // downcast to RRestrictAngleLength:
            {
                RRestrictAngleLength* o = dynamic_cast<RRestrictAngleLength*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RRestrictAngleLength(handler, o);
                }
            }
          
            // downcast to RRestrictOff:
            {
                RRestrictOff* o = dynamic_cast<RRestrictOff*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RRestrictOff(handler, o);
                }
            }
          
            // downcast to RRestrictOrthogonal:
            {
                RRestrictOrthogonal* o = dynamic_cast<RRestrictOrthogonal*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RRestrictOrthogonal(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RSnapRestriction_Wrapper* ret = new RSnapRestriction_Wrapper(handler, v, false);

          // JS: new RSnapRestriction('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapRestriction");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapRestriction is undefined. Use RSnapRestriction_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapRestriction('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapRestriction(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapRestriction* RJSHelper_qcad::js2cpp_RSnapRestriction_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapRestriction: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapRestriction_Wrapper* wrapper = qobject_cast<RSnapRestriction_Wrapper*>(obj);
          //RSnapRestriction_Wrapper* wrapper = dynamic_cast<RSnapRestriction_Wrapper*>(obj);
          //RSnapRestriction_Wrapper* wrapper = (RSnapRestriction_Wrapper*)(obj);
          //RSnapRestriction_Wrapper* wrapper = getWrapper<RSnapRestriction_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapRestriction_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RSnapRestriction(wrapper);
          return RSnapRestriction_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapRestriction_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapRestriction: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapRestriction::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSnapTangential(RJSApi& handler, RSnapTangential* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSnapTangential_Wrapper* ret = new RSnapTangential_Wrapper(handler, v, false);

          // JS: new RSnapTangential('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSnapTangential");
          if (cl.isUndefined()) {
              qWarning() << "Class RSnapTangential is undefined. Use RSnapTangential_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSnapTangential('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSnapTangential(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSnapTangential* RJSHelper_qcad::js2cpp_RSnapTangential_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSnapTangential: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSnapTangential_Wrapper* wrapper = qobject_cast<RSnapTangential_Wrapper*>(obj);
          //RSnapTangential_Wrapper* wrapper = dynamic_cast<RSnapTangential_Wrapper*>(obj);
          //RSnapTangential_Wrapper* wrapper = (RSnapTangential_Wrapper*)(obj);
          //RSnapTangential_Wrapper* wrapper = getWrapper<RSnapTangential_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSnapTangential_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RSnapTangential(wrapper);
          return RSnapTangential_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSnapTangential_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSnapTangential: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSnapTangential::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSolidEntity(RJSApi& handler, RSolidEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSolidEntity_Wrapper* ret = new RSolidEntity_Wrapper(handler, v, false);

          // JS: new RSolidEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSolidEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RSolidEntity is undefined. Use RSolidEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSolidEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSolidEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSolidEntity* RJSHelper_qcad::js2cpp_RSolidEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSolidEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSolidEntity_Wrapper* wrapper = qobject_cast<RSolidEntity_Wrapper*>(obj);
          //RSolidEntity_Wrapper* wrapper = dynamic_cast<RSolidEntity_Wrapper*>(obj);
          //RSolidEntity_Wrapper* wrapper = (RSolidEntity_Wrapper*)(obj);
          //RSolidEntity_Wrapper* wrapper = getWrapper<RSolidEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSolidEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RSolidEntity(wrapper);
          return RSolidEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSolidEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSolidEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSolidEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSpatialIndex(RJSApi& handler, RSpatialIndex* v) {

          
            // downcast to RSpatialIndexNavel:
            {
                RSpatialIndexNavel* o = dynamic_cast<RSpatialIndexNavel*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSpatialIndexNavel(handler, o);
                }
            }
          
            // downcast to RSpatialIndexSimple:
            {
                RSpatialIndexSimple* o = dynamic_cast<RSpatialIndexSimple*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSpatialIndexSimple(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RSpatialIndex_Wrapper* ret = new RSpatialIndex_Wrapper(handler, v, false);

          // JS: new RSpatialIndex('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSpatialIndex");
          if (cl.isUndefined()) {
              qWarning() << "Class RSpatialIndex is undefined. Use RSpatialIndex_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSpatialIndex('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSpatialIndex(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSpatialIndex* RJSHelper_qcad::js2cpp_RSpatialIndex_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSpatialIndex: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSpatialIndex_Wrapper* wrapper = qobject_cast<RSpatialIndex_Wrapper*>(obj);
          //RSpatialIndex_Wrapper* wrapper = dynamic_cast<RSpatialIndex_Wrapper*>(obj);
          //RSpatialIndex_Wrapper* wrapper = (RSpatialIndex_Wrapper*)(obj);
          //RSpatialIndex_Wrapper* wrapper = getWrapper<RSpatialIndex_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSpatialIndex_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RSpatialIndex(wrapper);
          return RSpatialIndex_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSpatialIndex_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSpatialIndex: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSpatialIndex::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSpatialIndexSimple(RJSApi& handler, RSpatialIndexSimple* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSpatialIndexSimple_Wrapper* ret = new RSpatialIndexSimple_Wrapper(handler, v, false);

          // JS: new RSpatialIndexSimple('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSpatialIndexSimple");
          if (cl.isUndefined()) {
              qWarning() << "Class RSpatialIndexSimple is undefined. Use RSpatialIndexSimple_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSpatialIndexSimple('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSpatialIndexSimple(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSpatialIndexSimple* RJSHelper_qcad::js2cpp_RSpatialIndexSimple_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSpatialIndexSimple: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSpatialIndexSimple_Wrapper* wrapper = qobject_cast<RSpatialIndexSimple_Wrapper*>(obj);
          //RSpatialIndexSimple_Wrapper* wrapper = dynamic_cast<RSpatialIndexSimple_Wrapper*>(obj);
          //RSpatialIndexSimple_Wrapper* wrapper = (RSpatialIndexSimple_Wrapper*)(obj);
          //RSpatialIndexSimple_Wrapper* wrapper = getWrapper<RSpatialIndexSimple_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSpatialIndexSimple_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RSpatialIndexSimple(wrapper);
          return RSpatialIndexSimple_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSpatialIndexSimple_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSpatialIndexSimple: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSpatialIndexSimple::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSpatialIndexVisitor(RJSApi& handler, RSpatialIndexVisitor* v) {

          
            // downcast to RSpatialIndexVisitorAdapter:
            {
                RSpatialIndexVisitorAdapter* o = dynamic_cast<RSpatialIndexVisitorAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RSpatialIndexVisitorAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RSpatialIndexVisitor_Wrapper* ret = new RSpatialIndexVisitor_Wrapper(handler, v, false);

          // JS: new RSpatialIndexVisitor('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSpatialIndexVisitor");
          if (cl.isUndefined()) {
              qWarning() << "Class RSpatialIndexVisitor is undefined. Use RSpatialIndexVisitor_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSpatialIndexVisitor('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSpatialIndexVisitor(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSpatialIndexVisitor* RJSHelper_qcad::js2cpp_RSpatialIndexVisitor_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSpatialIndexVisitor: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSpatialIndexVisitor_Wrapper* wrapper = qobject_cast<RSpatialIndexVisitor_Wrapper*>(obj);
          //RSpatialIndexVisitor_Wrapper* wrapper = dynamic_cast<RSpatialIndexVisitor_Wrapper*>(obj);
          //RSpatialIndexVisitor_Wrapper* wrapper = (RSpatialIndexVisitor_Wrapper*)(obj);
          //RSpatialIndexVisitor_Wrapper* wrapper = getWrapper<RSpatialIndexVisitor_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSpatialIndexVisitor_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RSpatialIndexVisitor(wrapper);
          return RSpatialIndexVisitor_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSpatialIndexVisitor_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSpatialIndexVisitor: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSpatialIndexVisitor::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSplineEntity(RJSApi& handler, RSplineEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RSplineEntity_Wrapper* ret = new RSplineEntity_Wrapper(handler, v, false);

          // JS: new RSplineEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSplineEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RSplineEntity is undefined. Use RSplineEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSplineEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSplineEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RSplineEntity* RJSHelper_qcad::js2cpp_RSplineEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSplineEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSplineEntity_Wrapper* wrapper = qobject_cast<RSplineEntity_Wrapper*>(obj);
          //RSplineEntity_Wrapper* wrapper = dynamic_cast<RSplineEntity_Wrapper*>(obj);
          //RSplineEntity_Wrapper* wrapper = (RSplineEntity_Wrapper*)(obj);
          //RSplineEntity_Wrapper* wrapper = getWrapper<RSplineEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSplineEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RSplineEntity(wrapper);
          return RSplineEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSplineEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSplineEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RSplineEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RStorage(RJSApi& handler, RStorage* v) {

          
            // downcast to RMemoryStorage:
            {
                RMemoryStorage* o = dynamic_cast<RMemoryStorage*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RMemoryStorage(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RStorage_Wrapper* ret = new RStorage_Wrapper(handler, v, false);

          // JS: new RStorage('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RStorage");
          if (cl.isUndefined()) {
              qWarning() << "Class RStorage is undefined. Use RStorage_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RStorage('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RStorage(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RStorage* RJSHelper_qcad::js2cpp_RStorage_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RStorage: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RStorage_Wrapper* wrapper = qobject_cast<RStorage_Wrapper*>(obj);
          //RStorage_Wrapper* wrapper = dynamic_cast<RStorage_Wrapper*>(obj);
          //RStorage_Wrapper* wrapper = (RStorage_Wrapper*)(obj);
          //RStorage_Wrapper* wrapper = getWrapper<RStorage_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RStorage_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RStorage(wrapper);
          return RStorage_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RStorage_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RStorage: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RStorage::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTabletEvent(RJSApi& handler, RTabletEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          RTabletEvent_Wrapper* ret = new RTabletEvent_Wrapper(handler, v, false);

          // JS: new RTabletEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTabletEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class RTabletEvent is undefined. Use RTabletEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTabletEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTabletEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RTabletEvent* RJSHelper_qcad::js2cpp_RTabletEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTabletEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RTabletEvent_Wrapper* wrapper = qobject_cast<RTabletEvent_Wrapper*>(obj);
          //RTabletEvent_Wrapper* wrapper = dynamic_cast<RTabletEvent_Wrapper*>(obj);
          //RTabletEvent_Wrapper* wrapper = (RTabletEvent_Wrapper*)(obj);
          //RTabletEvent_Wrapper* wrapper = getWrapper<RTabletEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTabletEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RTabletEvent(wrapper);
          return RTabletEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RTabletEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTabletEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RTabletEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTerminateEvent(RJSApi& handler, RTerminateEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          RTerminateEvent_Wrapper* ret = new RTerminateEvent_Wrapper(handler, v, false);

          // JS: new RTerminateEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTerminateEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class RTerminateEvent is undefined. Use RTerminateEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTerminateEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTerminateEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RTerminateEvent* RJSHelper_qcad::js2cpp_RTerminateEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTerminateEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RTerminateEvent_Wrapper* wrapper = qobject_cast<RTerminateEvent_Wrapper*>(obj);
          //RTerminateEvent_Wrapper* wrapper = dynamic_cast<RTerminateEvent_Wrapper*>(obj);
          //RTerminateEvent_Wrapper* wrapper = (RTerminateEvent_Wrapper*)(obj);
          //RTerminateEvent_Wrapper* wrapper = getWrapper<RTerminateEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTerminateEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RTerminateEvent(wrapper);
          return RTerminateEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RTerminateEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTerminateEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RTerminateEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTextBasedEntity(RJSApi& handler, RTextBasedEntity* v) {

          
            // downcast to RAttributeDefinitionEntity:
            {
                RAttributeDefinitionEntity* o = dynamic_cast<RAttributeDefinitionEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RAttributeDefinitionEntity(handler, o);
                }
            }
          
            // downcast to RAttributeEntity:
            {
                RAttributeEntity* o = dynamic_cast<RAttributeEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RAttributeEntity(handler, o);
                }
            }
          
            // downcast to RTextEntity:
            {
                RTextEntity* o = dynamic_cast<RTextEntity*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RTextEntity(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RTextBasedEntity_Wrapper* ret = new RTextBasedEntity_Wrapper(handler, v, false);

          // JS: new RTextBasedEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTextBasedEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RTextBasedEntity is undefined. Use RTextBasedEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTextBasedEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTextBasedEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RTextBasedEntity* RJSHelper_qcad::js2cpp_RTextBasedEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTextBasedEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RTextBasedEntity_Wrapper* wrapper = qobject_cast<RTextBasedEntity_Wrapper*>(obj);
          //RTextBasedEntity_Wrapper* wrapper = dynamic_cast<RTextBasedEntity_Wrapper*>(obj);
          //RTextBasedEntity_Wrapper* wrapper = (RTextBasedEntity_Wrapper*)(obj);
          //RTextBasedEntity_Wrapper* wrapper = getWrapper<RTextBasedEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTextBasedEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RTextBasedEntity(wrapper);
          return RTextBasedEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RTextBasedEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTextBasedEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RTextBasedEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTextEntity(RJSApi& handler, RTextEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RTextEntity_Wrapper* ret = new RTextEntity_Wrapper(handler, v, false);

          // JS: new RTextEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTextEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RTextEntity is undefined. Use RTextEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTextEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTextEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RTextEntity* RJSHelper_qcad::js2cpp_RTextEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTextEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RTextEntity_Wrapper* wrapper = qobject_cast<RTextEntity_Wrapper*>(obj);
          //RTextEntity_Wrapper* wrapper = dynamic_cast<RTextEntity_Wrapper*>(obj);
          //RTextEntity_Wrapper* wrapper = (RTextEntity_Wrapper*)(obj);
          //RTextEntity_Wrapper* wrapper = getWrapper<RTextEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTextEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RTextEntity(wrapper);
          return RTextEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RTextEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTextEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RTextEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTextRenderer(RJSApi& handler, RTextRenderer* v) {

          

          QJSEngine* engine = handler.getEngine();
          RTextRenderer_Wrapper* ret = new RTextRenderer_Wrapper(handler, v, false);

          // JS: new RTextRenderer('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTextRenderer");
          if (cl.isUndefined()) {
              qWarning() << "Class RTextRenderer is undefined. Use RTextRenderer_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTextRenderer('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTextRenderer(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RTextRenderer* RJSHelper_qcad::js2cpp_RTextRenderer_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTextRenderer: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RTextRenderer_Wrapper* wrapper = qobject_cast<RTextRenderer_Wrapper*>(obj);
          //RTextRenderer_Wrapper* wrapper = dynamic_cast<RTextRenderer_Wrapper*>(obj);
          //RTextRenderer_Wrapper* wrapper = (RTextRenderer_Wrapper*)(obj);
          //RTextRenderer_Wrapper* wrapper = getWrapper<RTextRenderer_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTextRenderer_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RTextRenderer(wrapper);
          return RTextRenderer_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RTextRenderer_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTextRenderer: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RTextRenderer::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RToleranceEntity(RJSApi& handler, RToleranceEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RToleranceEntity_Wrapper* ret = new RToleranceEntity_Wrapper(handler, v, false);

          // JS: new RToleranceEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RToleranceEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RToleranceEntity is undefined. Use RToleranceEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RToleranceEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RToleranceEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RToleranceEntity* RJSHelper_qcad::js2cpp_RToleranceEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RToleranceEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RToleranceEntity_Wrapper* wrapper = qobject_cast<RToleranceEntity_Wrapper*>(obj);
          //RToleranceEntity_Wrapper* wrapper = dynamic_cast<RToleranceEntity_Wrapper*>(obj);
          //RToleranceEntity_Wrapper* wrapper = (RToleranceEntity_Wrapper*)(obj);
          //RToleranceEntity_Wrapper* wrapper = getWrapper<RToleranceEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RToleranceEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RToleranceEntity(wrapper);
          return RToleranceEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RToleranceEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RToleranceEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RToleranceEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTraceEntity(RJSApi& handler, RTraceEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RTraceEntity_Wrapper* ret = new RTraceEntity_Wrapper(handler, v, false);

          // JS: new RTraceEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTraceEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RTraceEntity is undefined. Use RTraceEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTraceEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTraceEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RTraceEntity* RJSHelper_qcad::js2cpp_RTraceEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTraceEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RTraceEntity_Wrapper* wrapper = qobject_cast<RTraceEntity_Wrapper*>(obj);
          //RTraceEntity_Wrapper* wrapper = dynamic_cast<RTraceEntity_Wrapper*>(obj);
          //RTraceEntity_Wrapper* wrapper = (RTraceEntity_Wrapper*)(obj);
          //RTraceEntity_Wrapper* wrapper = getWrapper<RTraceEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTraceEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RTraceEntity(wrapper);
          return RTraceEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RTraceEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTraceEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RTraceEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTransaction(RJSApi& handler, RTransaction* v) {

          

          QJSEngine* engine = handler.getEngine();
          RTransaction_Wrapper* ret = new RTransaction_Wrapper(handler, v, false);

          // JS: new RTransaction('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTransaction");
          if (cl.isUndefined()) {
              qWarning() << "Class RTransaction is undefined. Use RTransaction_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTransaction('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTransaction(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RTransaction* RJSHelper_qcad::js2cpp_RTransaction_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTransaction: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RTransaction_Wrapper* wrapper = qobject_cast<RTransaction_Wrapper*>(obj);
          //RTransaction_Wrapper* wrapper = dynamic_cast<RTransaction_Wrapper*>(obj);
          //RTransaction_Wrapper* wrapper = (RTransaction_Wrapper*)(obj);
          //RTransaction_Wrapper* wrapper = getWrapper<RTransaction_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTransaction_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RTransaction(wrapper);
          return RTransaction_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RTransaction_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTransaction: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RTransaction::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTransactionListener(RJSApi& handler, RTransactionListener* v) {

          
            // downcast to RTransactionListenerAdapter:
            {
                RTransactionListenerAdapter* o = dynamic_cast<RTransactionListenerAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RTransactionListenerAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RTransactionListener_Wrapper* ret = new RTransactionListener_Wrapper(handler, v, false);

          // JS: new RTransactionListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTransactionListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RTransactionListener is undefined. Use RTransactionListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTransactionListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTransactionListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RTransactionListener* RJSHelper_qcad::js2cpp_RTransactionListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTransactionListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RTransactionListener_Wrapper* wrapper = qobject_cast<RTransactionListener_Wrapper*>(obj);
          //RTransactionListener_Wrapper* wrapper = dynamic_cast<RTransactionListener_Wrapper*>(obj);
          //RTransactionListener_Wrapper* wrapper = (RTransactionListener_Wrapper*)(obj);
          //RTransactionListener_Wrapper* wrapper = getWrapper<RTransactionListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTransactionListener_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RTransactionListener(wrapper);
          return RTransactionListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RTransactionListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTransactionListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RTransactionListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTransactionStack(RJSApi& handler, RTransactionStack* v) {

          

          QJSEngine* engine = handler.getEngine();
          RTransactionStack_Wrapper* ret = new RTransactionStack_Wrapper(handler, v, false);

          // JS: new RTransactionStack('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTransactionStack");
          if (cl.isUndefined()) {
              qWarning() << "Class RTransactionStack is undefined. Use RTransactionStack_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTransactionStack('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTransactionStack(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RTransactionStack* RJSHelper_qcad::js2cpp_RTransactionStack_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTransactionStack: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RTransactionStack_Wrapper* wrapper = qobject_cast<RTransactionStack_Wrapper*>(obj);
          //RTransactionStack_Wrapper* wrapper = dynamic_cast<RTransactionStack_Wrapper*>(obj);
          //RTransactionStack_Wrapper* wrapper = (RTransactionStack_Wrapper*)(obj);
          //RTransactionStack_Wrapper* wrapper = getWrapper<RTransactionStack_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTransactionStack_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RTransactionStack(wrapper);
          return RTransactionStack_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RTransactionStack_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTransactionStack: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RTransactionStack::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTransformation(RJSApi& handler, RTransformation* v) {

          
            // downcast to RTranslation:
            {
                RTranslation* o = dynamic_cast<RTranslation*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RTranslation(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RTransformation_Wrapper* ret = new RTransformation_Wrapper(handler, v, false);

          // JS: new RTransformation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTransformation");
          if (cl.isUndefined()) {
              qWarning() << "Class RTransformation is undefined. Use RTransformation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTransformation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTransformation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RTransformation* RJSHelper_qcad::js2cpp_RTransformation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTransformation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RTransformation_Wrapper* wrapper = qobject_cast<RTransformation_Wrapper*>(obj);
          //RTransformation_Wrapper* wrapper = dynamic_cast<RTransformation_Wrapper*>(obj);
          //RTransformation_Wrapper* wrapper = (RTransformation_Wrapper*)(obj);
          //RTransformation_Wrapper* wrapper = getWrapper<RTransformation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTransformation_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RTransformation(wrapper);
          return RTransformation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RTransformation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTransformation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RTransformation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTranslation(RJSApi& handler, RTranslation* v) {

          

          QJSEngine* engine = handler.getEngine();
          RTranslation_Wrapper* ret = new RTranslation_Wrapper(handler, v, false);

          // JS: new RTranslation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTranslation");
          if (cl.isUndefined()) {
              qWarning() << "Class RTranslation is undefined. Use RTranslation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTranslation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTranslation(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RTranslation* RJSHelper_qcad::js2cpp_RTranslation_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTranslation: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RTranslation_Wrapper* wrapper = qobject_cast<RTranslation_Wrapper*>(obj);
          //RTranslation_Wrapper* wrapper = dynamic_cast<RTranslation_Wrapper*>(obj);
          //RTranslation_Wrapper* wrapper = (RTranslation_Wrapper*)(obj);
          //RTranslation_Wrapper* wrapper = getWrapper<RTranslation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTranslation_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RTranslation(wrapper);
          return RTranslation_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RTranslation_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTranslation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RTranslation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RUcs(RJSApi& handler, RUcs* v) {

          

          QJSEngine* engine = handler.getEngine();
          RUcs_Wrapper* ret = new RUcs_Wrapper(handler, v, false);

          // JS: new RUcs('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RUcs");
          if (cl.isUndefined()) {
              qWarning() << "Class RUcs is undefined. Use RUcs_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RUcs('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RUcs(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RUcs* RJSHelper_qcad::js2cpp_RUcs_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RUcs: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RUcs_Wrapper* wrapper = qobject_cast<RUcs_Wrapper*>(obj);
          //RUcs_Wrapper* wrapper = dynamic_cast<RUcs_Wrapper*>(obj);
          //RUcs_Wrapper* wrapper = (RUcs_Wrapper*)(obj);
          //RUcs_Wrapper* wrapper = getWrapper<RUcs_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RUcs_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RUcs(wrapper);
          return RUcs_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RUcs_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RUcs: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RUcs::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RUcsListener(RJSApi& handler, RUcsListener* v) {

          

          QJSEngine* engine = handler.getEngine();
          RUcsListener_Wrapper* ret = new RUcsListener_Wrapper(handler, v, false);

          // JS: new RUcsListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RUcsListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RUcsListener is undefined. Use RUcsListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RUcsListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RUcsListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RUcsListener* RJSHelper_qcad::js2cpp_RUcsListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RUcsListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RUcsListener_Wrapper* wrapper = qobject_cast<RUcsListener_Wrapper*>(obj);
          //RUcsListener_Wrapper* wrapper = dynamic_cast<RUcsListener_Wrapper*>(obj);
          //RUcsListener_Wrapper* wrapper = (RUcsListener_Wrapper*)(obj);
          //RUcsListener_Wrapper* wrapper = getWrapper<RUcsListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RUcsListener_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RUcsListener(wrapper);
          return RUcsListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RUcsListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RUcsListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RUcsListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RView(RJSApi& handler, RView* v) {

          

          QJSEngine* engine = handler.getEngine();
          RView_Wrapper* ret = new RView_Wrapper(handler, v, false);

          // JS: new RView('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RView");
          if (cl.isUndefined()) {
              qWarning() << "Class RView is undefined. Use RView_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RView('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RView(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RView* RJSHelper_qcad::js2cpp_RView_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RView: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RView_Wrapper* wrapper = qobject_cast<RView_Wrapper*>(obj);
          //RView_Wrapper* wrapper = dynamic_cast<RView_Wrapper*>(obj);
          //RView_Wrapper* wrapper = (RView_Wrapper*)(obj);
          //RView_Wrapper* wrapper = getWrapper<RView_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RView_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RView(wrapper);
          return RView_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RView_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RView: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RView::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RViewFocusListener(RJSApi& handler, RViewFocusListener* v) {

          
            // downcast to RViewFocusListenerAdapter:
            {
                RViewFocusListenerAdapter* o = dynamic_cast<RViewFocusListenerAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RViewFocusListenerAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RViewFocusListener_Wrapper* ret = new RViewFocusListener_Wrapper(handler, v, false);

          // JS: new RViewFocusListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RViewFocusListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RViewFocusListener is undefined. Use RViewFocusListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RViewFocusListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RViewFocusListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RViewFocusListener* RJSHelper_qcad::js2cpp_RViewFocusListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RViewFocusListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RViewFocusListener_Wrapper* wrapper = qobject_cast<RViewFocusListener_Wrapper*>(obj);
          //RViewFocusListener_Wrapper* wrapper = dynamic_cast<RViewFocusListener_Wrapper*>(obj);
          //RViewFocusListener_Wrapper* wrapper = (RViewFocusListener_Wrapper*)(obj);
          //RViewFocusListener_Wrapper* wrapper = getWrapper<RViewFocusListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RViewFocusListener_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RViewFocusListener(wrapper);
          return RViewFocusListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RViewFocusListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RViewFocusListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RViewFocusListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RViewListener(RJSApi& handler, RViewListener* v) {

          
            // downcast to RViewListenerAdapter:
            {
                RViewListenerAdapter* o = dynamic_cast<RViewListenerAdapter*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RViewListenerAdapter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          RViewListener_Wrapper* ret = new RViewListener_Wrapper(handler, v, false);

          // JS: new RViewListener('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RViewListener");
          if (cl.isUndefined()) {
              qWarning() << "Class RViewListener is undefined. Use RViewListener_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RViewListener('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RViewListener(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RViewListener* RJSHelper_qcad::js2cpp_RViewListener_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RViewListener: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RViewListener_Wrapper* wrapper = qobject_cast<RViewListener_Wrapper*>(obj);
          //RViewListener_Wrapper* wrapper = dynamic_cast<RViewListener_Wrapper*>(obj);
          //RViewListener_Wrapper* wrapper = (RViewListener_Wrapper*)(obj);
          //RViewListener_Wrapper* wrapper = getWrapper<RViewListener_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RViewListener_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RViewListener(wrapper);
          return RViewListener_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RViewListener_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RViewListener: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RViewListener::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RViewportEntity(RJSApi& handler, RViewportEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RViewportEntity_Wrapper* ret = new RViewportEntity_Wrapper(handler, v, false);

          // JS: new RViewportEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RViewportEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RViewportEntity is undefined. Use RViewportEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RViewportEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RViewportEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RViewportEntity* RJSHelper_qcad::js2cpp_RViewportEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RViewportEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RViewportEntity_Wrapper* wrapper = qobject_cast<RViewportEntity_Wrapper*>(obj);
          //RViewportEntity_Wrapper* wrapper = dynamic_cast<RViewportEntity_Wrapper*>(obj);
          //RViewportEntity_Wrapper* wrapper = (RViewportEntity_Wrapper*)(obj);
          //RViewportEntity_Wrapper* wrapper = getWrapper<RViewportEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RViewportEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RViewportEntity(wrapper);
          return RViewportEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RViewportEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RViewportEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RViewportEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RWipeoutEntity(RJSApi& handler, RWipeoutEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RWipeoutEntity_Wrapper* ret = new RWipeoutEntity_Wrapper(handler, v, false);

          // JS: new RWipeoutEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RWipeoutEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RWipeoutEntity is undefined. Use RWipeoutEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RWipeoutEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RWipeoutEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RWipeoutEntity* RJSHelper_qcad::js2cpp_RWipeoutEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RWipeoutEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RWipeoutEntity_Wrapper* wrapper = qobject_cast<RWipeoutEntity_Wrapper*>(obj);
          //RWipeoutEntity_Wrapper* wrapper = dynamic_cast<RWipeoutEntity_Wrapper*>(obj);
          //RWipeoutEntity_Wrapper* wrapper = (RWipeoutEntity_Wrapper*)(obj);
          //RWipeoutEntity_Wrapper* wrapper = getWrapper<RWipeoutEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RWipeoutEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RWipeoutEntity(wrapper);
          return RWipeoutEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RWipeoutEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RWipeoutEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RWipeoutEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RWheelEvent(RJSApi& handler, RWheelEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          RWheelEvent_Wrapper* ret = new RWheelEvent_Wrapper(handler, v, false);

          // JS: new RWheelEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RWheelEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class RWheelEvent is undefined. Use RWheelEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RWheelEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RWheelEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RWheelEvent* RJSHelper_qcad::js2cpp_RWheelEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RWheelEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RWheelEvent_Wrapper* wrapper = qobject_cast<RWheelEvent_Wrapper*>(obj);
          //RWheelEvent_Wrapper* wrapper = dynamic_cast<RWheelEvent_Wrapper*>(obj);
          //RWheelEvent_Wrapper* wrapper = (RWheelEvent_Wrapper*)(obj);
          //RWheelEvent_Wrapper* wrapper = getWrapper<RWheelEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RWheelEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RWheelEvent(wrapper);
          return RWheelEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RWheelEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RWheelEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RWheelEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RXLineEntity(RJSApi& handler, RXLineEntity* v) {

          

          QJSEngine* engine = handler.getEngine();
          RXLineEntity_Wrapper* ret = new RXLineEntity_Wrapper(handler, v, false);

          // JS: new RXLineEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RXLineEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RXLineEntity is undefined. Use RXLineEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RXLineEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RXLineEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      RXLineEntity* RJSHelper_qcad::js2cpp_RXLineEntity_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RXLineEntity: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RXLineEntity_Wrapper* wrapper = qobject_cast<RXLineEntity_Wrapper*>(obj);
          //RXLineEntity_Wrapper* wrapper = dynamic_cast<RXLineEntity_Wrapper*>(obj);
          //RXLineEntity_Wrapper* wrapper = (RXLineEntity_Wrapper*)(obj);
          //RXLineEntity_Wrapper* wrapper = getWrapper<RXLineEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RXLineEntity_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_RXLineEntity(wrapper);
          return RXLineEntity_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RXLineEntity_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RXLineEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_RXLineEntity::getIdStatic())).toBool();
      }
    