
  // Automatically generated, do not edit
  
          #include "RJSHelper_qcad.h"
        
          #include "header_qcad_cpp.h"
        
        #include "raction_wrapper.h"
        
        #include "ractionadapter_wrapper.h"
        
          #include "raction_wrapper.h"
        
        #include "raddobjectoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "raddobjectsoperation_wrapper.h"
        
        #include "raddobjectsoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
        #include "rarc_wrapper.h"
        
          #include "rshape_wrapper.h"
        
        #include "rarcdata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rarc_wrapper.h"
        
        #include "rarcentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rattributedata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rtextbaseddata_wrapper.h"
        
        #include "rattributedefinitiondata_wrapper.h"
        
          #include "rtextbaseddata_wrapper.h"
        
        #include "rattributedefinitionentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rtextbasedentity_wrapper.h"
        
        #include "rattributeentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rtextbasedentity_wrapper.h"
        
        #include "rautoloadjs_wrapper.h"
        
        #include "rblock_wrapper.h"
        
          #include "robject_wrapper.h"
        
        #include "rblocklistener_wrapper.h"
        
        #include "rblocklisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rblocklistener_wrapper.h"
        
        #include "rblockreferencedata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
        #include "rblockreferenceentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rbox_wrapper.h"
        
        #include "rcadtoolbar_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qtoolbar_wrapper.h"
        
        #include "rcadtoolbarpanel_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rwidget_wrapper.h"
        
        #include "rchangepropertyoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
        #include "rcharacterwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "rcircle_wrapper.h"
        
          #include "rshape_wrapper.h"
        
        #include "rcircledata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rcircle_wrapper.h"
        
        #include "rcircleentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rclickreferencepointoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
        #include "rclipboardoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
        #include "rclosecurrentevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
        #include "rcolor_wrapper.h"
        
          #include "qcolor_wrapper.h"
        
        #include "rcolorcombo_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
        #include "rcombobox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
        #include "rcommandevent_wrapper.h"
        
        #include "rcommandline_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qlineedit_wrapper.h"
        
        #include "rcoordinateevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "rinputevent_wrapper.h"
        
        #include "rcoordinatelistener_wrapper.h"
        
        #include "rcoordinatelisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rcoordinatelistener_wrapper.h"
        
        #include "rcopyoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rclipboardoperation_wrapper.h"
        
        #include "rdebug_wrapper.h"
        
        #include "rdeleteallentitiesoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
        #include "rdeleteobjectoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rdeleteobjectsoperation_wrapper.h"
        
        #include "rdeleteobjectsoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
        #include "rdeleteselectionoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rclipboardoperation_wrapper.h"
        
        #include "rdimaligneddata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimlineardata_wrapper.h"
        
        #include "rdimalignedentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimlinearentity_wrapper.h"
        
        #include "rdimangular2ldata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimangulardata_wrapper.h"
        
        #include "rdimangular2lentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimangularentity_wrapper.h"
        
        #include "rdimangular3pdata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimangulardata_wrapper.h"
        
        #include "rdimangular3pentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimangularentity_wrapper.h"
        
        #include "rdimangulardata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
        #include "rdimangularentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
        #include "rdimarclengthdata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimangulardata_wrapper.h"
        
        #include "rdimarclengthentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimangularentity_wrapper.h"
        
        #include "rdimdiametricdata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
        #include "rdimdiametricentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
        #include "rdimensiondata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
        #include "rdimensionentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rdimlineardata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
        #include "rdimlinearentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
        #include "rdimordinatedata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
        #include "rdimordinateentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
        #include "rdimradialdata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
        #include "rdimradialentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
        #include "rdimrotateddata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimlineardata_wrapper.h"
        
        #include "rdimrotatedentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimlinearentity_wrapper.h"
        
        #include "rdimstyle_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rdimstyledata_wrapper.h"
        
        #include "rdimstyledata_wrapper.h"
        
        #include "rdirected_wrapper.h"
        
        #include "rdockwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qdockwidget_wrapper.h"
        
        #include "rdocument_wrapper.h"
        
        #include "rdocumentinterface_wrapper.h"
        
        #include "rdocumentvariables_wrapper.h"
        
          #include "robject_wrapper.h"
        
        #include "rdxfservices_wrapper.h"
        
        #include "rellipse_wrapper.h"
        
          #include "rshape_wrapper.h"
        
        #include "rellipsedata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rellipse_wrapper.h"
        
        #include "rellipseentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
        #include "rentitydata_wrapper.h"
        
        #include "rentityexportlistener_wrapper.h"
        
        #include "rentitypickevent_wrapper.h"
        
          #include "rinputevent_wrapper.h"
        
        #include "reventfilter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "reventhandler_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "rexplodable_wrapper.h"
        
        #include "rexporter_wrapper.h"
        
        #include "rexportlistener_wrapper.h"
        
        #include "rexportlisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rexportlistener_wrapper.h"
        
        #include "rfacedata_wrapper.h"
        
          #include "rsoliddata_wrapper.h"
        
        #include "rfaceentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rfilecache_wrapper.h"
        
        #include "rfileexporter_wrapper.h"
        
          #include "rexporter_wrapper.h"
        
        #include "rfileexporteradapter_wrapper.h"
        
          #include "rexporter_wrapper.h"
        
          #include "rfileexporter_wrapper.h"
        
        #include "rfileexporterfactory_wrapper.h"
        
        #include "rfileexporterfactoryadapter_wrapper.h"
        
          #include "rfileexporterfactory_wrapper.h"
        
        #include "rfileexporterregistry_wrapper.h"
        
        #include "rfileimporter_wrapper.h"
        
          #include "rimporter_wrapper.h"
        
        #include "rfileimporteradapter_wrapper.h"
        
          #include "rimporter_wrapper.h"
        
          #include "rfileimporter_wrapper.h"
        
        #include "rfileimporterfactory_wrapper.h"
        
        #include "rfileimporterfactoryadapter_wrapper.h"
        
          #include "rfileimporterfactory_wrapper.h"
        
        #include "rfileimporterregistry_wrapper.h"
        
        #include "rfilesystemmodel_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemmodel_wrapper.h"
        
          #include "qfilesystemmodel_wrapper.h"
        
        #include "rflowlayout_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
          #include "qlayout_wrapper.h"
        
        #include "rfocuslistener_wrapper.h"
        
        #include "rfocuslisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rfocuslistener_wrapper.h"
        
        #include "rfont_wrapper.h"
        
        #include "rfontchooserwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "rfontlist_wrapper.h"
        
        #include "rgraphicsscene_wrapper.h"
        
          #include "rexporter_wrapper.h"
        
        #include "rgraphicsscenedrawable_wrapper.h"
        
        #include "rgraphicssceneqt_wrapper.h"
        
          #include "rexporter_wrapper.h"
        
          #include "rgraphicsscene_wrapper.h"
        
        #include "rgraphicsview_wrapper.h"
        
        #include "rgraphicsviewimage_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rgraphicsview_wrapper.h"
        
        #include "rgraphicsviewqt_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "rgraphicsviewworker_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "rgrid_wrapper.h"
        
        #include "rguiaction_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rfocuslistener_wrapper.h"
        
          #include "rtransactionlistener_wrapper.h"
        
          #include "rselectionlistener_wrapper.h"
        
          #include "qaction_wrapper.h"
        
        #include "rhatchdata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
        #include "rhatchentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rimagedata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
        #include "rimageentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rimporter_wrapper.h"
        
        #include "rimportlistener_wrapper.h"
        
        #include "rimportlisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rimportlistener_wrapper.h"
        
        #include "rinputevent_wrapper.h"
        
        #include "rintertransactionlistener_wrapper.h"
        
        #include "rintertransactionlisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rintertransactionlistener_wrapper.h"
        
        #include "rkeylistener_wrapper.h"
        
        #include "rkeylisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rkeylistener_wrapper.h"
        
        #include "rlayer_wrapper.h"
        
          #include "robject_wrapper.h"
        
        #include "rlayerlistener_wrapper.h"
        
        #include "rlayerlisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rlayerlistener_wrapper.h"
        
        #include "rlayerstate_wrapper.h"
        
          #include "robject_wrapper.h"
        
        #include "rlayout_wrapper.h"
        
          #include "robject_wrapper.h"
        
        #include "rleaderdata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpolyline_wrapper.h"
        
        #include "rleaderentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rline_wrapper.h"
        
          #include "rshape_wrapper.h"
        
        #include "rlinedata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rline_wrapper.h"
        
        #include "rlineentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rlinetype_wrapper.h"
        
          #include "robject_wrapper.h"
        
        #include "rlinetypecombo_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
        #include "rlinetypepattern_wrapper.h"
        
        #include "rlineweight_wrapper.h"
        
        #include "rlineweightcombo_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
        #include "rlistview_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qlistview_wrapper.h"
        
        #include "rlistwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qlistview_wrapper.h"
        
          #include "qlistwidget_wrapper.h"
        
        #include "rmainwindow_wrapper.h"
        
        #include "rmainwindowqt_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rmainwindow_wrapper.h"
        
          #include "qmainwindow_wrapper.h"
        
        #include "rmath_wrapper.h"
        
        #include "rmathcombobox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
        #include "rmathlineedit_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qlineedit_wrapper.h"
        
        #include "rmatrix_wrapper.h"
        
        #include "rmdiarea_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qmdiarea_wrapper.h"
        
        #include "rmdichildqt_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rmodifiedlistener_wrapper.h"
        
          #include "qmdisubwindow_wrapper.h"
        
        #include "rmemorystorage_wrapper.h"
        
          #include "rstorage_wrapper.h"
        
        #include "rmessagehandler_wrapper.h"
        
        #include "rmixedoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
        #include "rmodifiedlistener_wrapper.h"
        
        #include "rmodifyobjectoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "raddobjectoperation_wrapper.h"
        
        #include "rmodifyobjectsoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "raddobjectsoperation_wrapper.h"
        
        #include "rmousecoordinatelistener_wrapper.h"
        
        #include "rmouseevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qinputevent_wrapper.h"
        
          #include "qpointerevent_wrapper.h"
        
          #include "qsinglepointevent_wrapper.h"
        
          #include "qmouseevent_wrapper.h"
        
          #include "rinputevent_wrapper.h"
        
        #include "rmovereferencepointoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
        #include "rmoveselectionoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
        #include "rnewdocumentlistener_wrapper.h"
        
        #include "robject_wrapper.h"
        
        #include "roperation_wrapper.h"
        
        #include "roperationutils_wrapper.h"
        
        #include "rorthogrid_wrapper.h"
        
          #include "rgrid_wrapper.h"
        
        #include "rpainterpath_wrapper.h"
        
          #include "qpainterpath_wrapper.h"
        
        #include "rpainterpathsource_wrapper.h"
        
        #include "rpalettelistener_wrapper.h"
        
        #include "rpalettelisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpalettelistener_wrapper.h"
        
        #include "rpasteoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rclipboardoperation_wrapper.h"
        
        #include "rpattern_wrapper.h"
        
        #include "rpatternline_wrapper.h"
        
        #include "rpatternlist_wrapper.h"
        
        #include "rpatternlistimperial_wrapper.h"
        
          #include "rpatternlist_wrapper.h"
        
        #include "rpatternlistmetric_wrapper.h"
        
          #include "rpatternlist_wrapper.h"
        
        #include "rpenlistener_wrapper.h"
        
        #include "rpenlisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpenlistener_wrapper.h"
        
        #include "rplugininfo_wrapper.h"
        
        #include "rplugininterface_wrapper.h"
        
        #include "rpluginloader_wrapper.h"
        
        #include "rpoint_wrapper.h"
        
          #include "rshape_wrapper.h"
        
        #include "rpointdata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpoint_wrapper.h"
        
        #include "rpointentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rpolyline_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rexplodable_wrapper.h"
        
        #include "rpolylinedata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpolyline_wrapper.h"
        
        #include "rpolylineentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rpreferenceslistener_wrapper.h"
        
        #include "rpreferenceslisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpreferenceslistener_wrapper.h"
        
        #include "rprogresshandler_wrapper.h"
        
        #include "rpropertyattributes_wrapper.h"
        
        #include "rpropertychange_wrapper.h"
        
        #include "rpropertyeditor_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpropertylistener_wrapper.h"
        
          #include "rlayerlistener_wrapper.h"
        
        #include "rpropertyevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
        #include "rpropertylistener_wrapper.h"
        
        #include "rpropertylisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpropertylistener_wrapper.h"
        
        #include "rpropertytypeid_wrapper.h"
        
        #include "rray_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rxline_wrapper.h"
        
        #include "rraydata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rray_wrapper.h"
        
        #include "rrayentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rrefpoint_wrapper.h"
        
          #include "rvector_wrapper.h"
        
        #include "rrestrictanglelength_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
        #include "rrestricthorizontal_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
          #include "rrestrictorthogonal_wrapper.h"
        
        #include "rrestrictoff_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
        #include "rrestrictorthogonal_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
        #include "rrestrictvertical_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
          #include "rrestrictorthogonal_wrapper.h"
        
        #include "rruler_wrapper.h"
        
        #include "rrulerqt_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rruler_wrapper.h"
        
          #include "rcoordinatelistener_wrapper.h"
        
          #include "rpalettelistener_wrapper.h"
        
          #include "qframe_wrapper.h"
        
        #include "rs_wrapper.h"
        
        #include "rscaleselectionoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
        #include "rselectionlistener_wrapper.h"
        
        #include "rselectionlisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rselectionlistener_wrapper.h"
        
        #include "rsettings_wrapper.h"
        
        #include "rshape_wrapper.h"
        
        #include "rsingleapplication_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qcoreapplication_wrapper.h"
        
          #include "qguiapplication_wrapper.h"
        
          #include "qapplication_wrapper.h"
        
        #include "rsnap_wrapper.h"
        
        #include "rsnapauto_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
        #include "rsnapcenter_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
        #include "rsnapdistance_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
        #include "rsnapend_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
        #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
        #include "rsnapfree_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
        #include "rsnapgrid_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
        #include "rsnapintersection_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
        #include "rsnaplistener_wrapper.h"
        
        #include "rsnapmiddle_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
        #include "rsnaponentity_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
        #include "rsnapperpendicular_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
        #include "rsnapreference_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
        #include "rsnaprestriction_wrapper.h"
        
        #include "rsnaptangential_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
        #include "rsoliddata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpolyline_wrapper.h"
        
        #include "rsolidentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rspatialindex_wrapper.h"
        
        #include "rspatialindexnavel_wrapper.h"
        
          #include "rspatialindex_wrapper.h"
        
        #include "rspatialindexsimple_wrapper.h"
        
          #include "rspatialindex_wrapper.h"
        
        #include "rspatialindexvisitor_wrapper.h"
        
        #include "rspatialindexvisitoradapter_wrapper.h"
        
          #include "rspatialindexvisitor_wrapper.h"
        
        #include "rspline_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rexplodable_wrapper.h"
        
        #include "rsplinedata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rspline_wrapper.h"
        
        #include "rsplineentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rstemmer_wrapper.h"
        
        #include "rstorage_wrapper.h"
        
        #include "rtabletevent_wrapper.h"
        
        #include "rterminateevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
        #include "rtextbaseddata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpainterpathsource_wrapper.h"
        
        #include "rtextbasedentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rtextdata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rtextbaseddata_wrapper.h"
        
        #include "rtextedit_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qtextedit_wrapper.h"
        
          #include "qtextbrowser_wrapper.h"
        
        #include "rtextentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rtextbasedentity_wrapper.h"
        
        #include "rtextlabel_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rpoint_wrapper.h"
        
        #include "rtextlayout_wrapper.h"
        
        #include "rtextrenderer_wrapper.h"
        
        #include "rtolerancedata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
        #include "rtoleranceentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rtoolbutton_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qtoolbutton_wrapper.h"
        
        #include "rtoolmatrixitemdelegate_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemdelegate_wrapper.h"
        
          #include "qitemdelegate_wrapper.h"
        
        #include "rtooloptioneventfilter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "rtracedata_wrapper.h"
        
          #include "rsoliddata_wrapper.h"
        
        #include "rtraceentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rtransaction_wrapper.h"
        
        #include "rtransactionlistener_wrapper.h"
        
        #include "rtransactionlisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rtransactionlistener_wrapper.h"
        
        #include "rtransactionstack_wrapper.h"
        
        #include "rtransform_wrapper.h"
        
          #include "qtransform_wrapper.h"
        
        #include "rtransformation_wrapper.h"
        
        #include "rtransformop_wrapper.h"
        
        #include "rtranslation_wrapper.h"
        
          #include "rtransformation_wrapper.h"
        
        #include "rtreewidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qtreeview_wrapper.h"
        
          #include "qtreewidget_wrapper.h"
        
        #include "rtriangle_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rexplodable_wrapper.h"
        
        #include "rucs_wrapper.h"
        
          #include "robject_wrapper.h"
        
        #include "rucslistener_wrapper.h"
        
        #include "runit_wrapper.h"
        
        #include "rvector_wrapper.h"
        
        #include "rview_wrapper.h"
        
          #include "robject_wrapper.h"
        
        #include "rviewfocuslistener_wrapper.h"
        
        #include "rviewfocuslisteneradapter_wrapper.h"
        
          #include "rviewfocuslistener_wrapper.h"
        
        #include "rviewlistener_wrapper.h"
        
        #include "rviewlisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rviewlistener_wrapper.h"
        
        #include "rviewportdata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpoint_wrapper.h"
        
        #include "rviewportentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rwheelevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qinputevent_wrapper.h"
        
          #include "qpointerevent_wrapper.h"
        
          #include "qsinglepointevent_wrapper.h"
        
          #include "qwheelevent_wrapper.h"
        
          #include "rinputevent_wrapper.h"
        
        #include "rwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "rwipeoutdata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpolylinedata_wrapper.h"
        
        #include "rwipeoutentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rxline_wrapper.h"
        
          #include "rshape_wrapper.h"
        
        #include "rxlinedata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rxline_wrapper.h"
        
        #include "rxlineentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
  // --------------
  // wrapped types:
  // --------------
  
      QJSValue RJSHelper_qcad::cpp2js_RArc(RJSApi& handler, const RArc* v) {
          QJSEngine* engine = handler.getEngine();
          RArc_Wrapper* ret;

          if (v==nullptr) {
              ret = new RArc_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RArc object:
              ret = new RArc_Wrapper(handler, new RArc(*v), true);
          }

          // JS: new RArc('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RArc");
          if (cl.isUndefined()) {
              qWarning() << "Class RArc is undefined. Use RArc_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RArc('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RArc(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RArc(RJSApi& handler, const RArc& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RArc object:
          RArc_Wrapper* ret = new RArc_Wrapper(handler, new RArc(v), true);

          // JS: new RArc('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RArc");
          if (cl.isUndefined()) {
              qWarning() << "Class RArc is undefined. Use RArc_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RArc('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RArc(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RArc RJSHelper_qcad::js2cpp_RArc(RJSApi& handler, const QJSValue& v) {
          /*
          RArc_Wrapper* wrapper = getWrapper<RArc_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RArc: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RArc();
          }
          //return *(RArc*)wrapper->getWrappedVoid();
          RArc* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RArc: wrapped pointer is NULL";
              return RArc();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RArc: not a QObject";
              return RArc();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RArc_ptr: no wrapper";
              handler.trace();
              return RArc();
          }
          //RArc* ret = getWrapped_RArc(wrapper);
          RArc* ret = RArc_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RArc();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RArc(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RArc: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RArc::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RArcData(RJSApi& handler, const RArcData* v) {
          QJSEngine* engine = handler.getEngine();
          RArcData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RArcData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RArcData object:
              ret = new RArcData_Wrapper(handler, new RArcData(*v), true);
          }

          // JS: new RArcData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RArcData");
          if (cl.isUndefined()) {
              qWarning() << "Class RArcData is undefined. Use RArcData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RArcData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RArcData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RArcData(RJSApi& handler, const RArcData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RArcData object:
          RArcData_Wrapper* ret = new RArcData_Wrapper(handler, new RArcData(v), true);

          // JS: new RArcData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RArcData");
          if (cl.isUndefined()) {
              qWarning() << "Class RArcData is undefined. Use RArcData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RArcData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RArcData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RArcData RJSHelper_qcad::js2cpp_RArcData(RJSApi& handler, const QJSValue& v) {
          /*
          RArcData_Wrapper* wrapper = getWrapper<RArcData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RArcData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RArcData();
          }
          //return *(RArcData*)wrapper->getWrappedVoid();
          RArcData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RArcData: wrapped pointer is NULL";
              return RArcData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RArcData: not a QObject";
              return RArcData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RArcData_ptr: no wrapper";
              handler.trace();
              return RArcData();
          }
          //RArcData* ret = getWrapped_RArcData(wrapper);
          RArcData* ret = RArcData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RArcData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RArcData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RArcData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RArcData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RAttributeData(RJSApi& handler, const RAttributeData* v) {
          QJSEngine* engine = handler.getEngine();
          RAttributeData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RAttributeData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RAttributeData object:
              ret = new RAttributeData_Wrapper(handler, new RAttributeData(*v), true);
          }

          // JS: new RAttributeData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RAttributeData");
          if (cl.isUndefined()) {
              qWarning() << "Class RAttributeData is undefined. Use RAttributeData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RAttributeData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RAttributeData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RAttributeData(RJSApi& handler, const RAttributeData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RAttributeData object:
          RAttributeData_Wrapper* ret = new RAttributeData_Wrapper(handler, new RAttributeData(v), true);

          // JS: new RAttributeData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RAttributeData");
          if (cl.isUndefined()) {
              qWarning() << "Class RAttributeData is undefined. Use RAttributeData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RAttributeData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RAttributeData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RAttributeData RJSHelper_qcad::js2cpp_RAttributeData(RJSApi& handler, const QJSValue& v) {
          /*
          RAttributeData_Wrapper* wrapper = getWrapper<RAttributeData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RAttributeData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RAttributeData();
          }
          //return *(RAttributeData*)wrapper->getWrappedVoid();
          RAttributeData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RAttributeData: wrapped pointer is NULL";
              return RAttributeData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RAttributeData: not a QObject";
              return RAttributeData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RAttributeData_ptr: no wrapper";
              handler.trace();
              return RAttributeData();
          }
          //RAttributeData* ret = getWrapped_RAttributeData(wrapper);
          RAttributeData* ret = RAttributeData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RAttributeData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RAttributeData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RAttributeData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RAttributeData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RAttributeDefinitionData(RJSApi& handler, const RAttributeDefinitionData* v) {
          QJSEngine* engine = handler.getEngine();
          RAttributeDefinitionData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RAttributeDefinitionData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RAttributeDefinitionData object:
              ret = new RAttributeDefinitionData_Wrapper(handler, new RAttributeDefinitionData(*v), true);
          }

          // JS: new RAttributeDefinitionData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RAttributeDefinitionData");
          if (cl.isUndefined()) {
              qWarning() << "Class RAttributeDefinitionData is undefined. Use RAttributeDefinitionData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RAttributeDefinitionData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RAttributeDefinitionData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RAttributeDefinitionData(RJSApi& handler, const RAttributeDefinitionData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RAttributeDefinitionData object:
          RAttributeDefinitionData_Wrapper* ret = new RAttributeDefinitionData_Wrapper(handler, new RAttributeDefinitionData(v), true);

          // JS: new RAttributeDefinitionData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RAttributeDefinitionData");
          if (cl.isUndefined()) {
              qWarning() << "Class RAttributeDefinitionData is undefined. Use RAttributeDefinitionData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RAttributeDefinitionData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RAttributeDefinitionData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RAttributeDefinitionData RJSHelper_qcad::js2cpp_RAttributeDefinitionData(RJSApi& handler, const QJSValue& v) {
          /*
          RAttributeDefinitionData_Wrapper* wrapper = getWrapper<RAttributeDefinitionData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RAttributeDefinitionData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RAttributeDefinitionData();
          }
          //return *(RAttributeDefinitionData*)wrapper->getWrappedVoid();
          RAttributeDefinitionData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RAttributeDefinitionData: wrapped pointer is NULL";
              return RAttributeDefinitionData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RAttributeDefinitionData: not a QObject";
              return RAttributeDefinitionData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RAttributeDefinitionData_ptr: no wrapper";
              handler.trace();
              return RAttributeDefinitionData();
          }
          //RAttributeDefinitionData* ret = getWrapped_RAttributeDefinitionData(wrapper);
          RAttributeDefinitionData* ret = RAttributeDefinitionData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RAttributeDefinitionData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RAttributeDefinitionData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RAttributeDefinitionData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RAttributeDefinitionData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RAutoLoadJs(RJSApi& handler, const RAutoLoadJs* v) {
          QJSEngine* engine = handler.getEngine();
          RAutoLoadJs_Wrapper* ret;

          if (v==nullptr) {
              ret = new RAutoLoadJs_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RAutoLoadJs object:
              ret = new RAutoLoadJs_Wrapper(handler, new RAutoLoadJs(*v), true);
          }

          // JS: new RAutoLoadJs('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RAutoLoadJs");
          if (cl.isUndefined()) {
              qWarning() << "Class RAutoLoadJs is undefined. Use RAutoLoadJs_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RAutoLoadJs('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RAutoLoadJs(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RAutoLoadJs(RJSApi& handler, const RAutoLoadJs& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RAutoLoadJs object:
          RAutoLoadJs_Wrapper* ret = new RAutoLoadJs_Wrapper(handler, new RAutoLoadJs(v), true);

          // JS: new RAutoLoadJs('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RAutoLoadJs");
          if (cl.isUndefined()) {
              qWarning() << "Class RAutoLoadJs is undefined. Use RAutoLoadJs_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RAutoLoadJs('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RAutoLoadJs(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RAutoLoadJs RJSHelper_qcad::js2cpp_RAutoLoadJs(RJSApi& handler, const QJSValue& v) {
          /*
          RAutoLoadJs_Wrapper* wrapper = getWrapper<RAutoLoadJs_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RAutoLoadJs: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RAutoLoadJs();
          }
          //return *(RAutoLoadJs*)wrapper->getWrappedVoid();
          RAutoLoadJs* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RAutoLoadJs: wrapped pointer is NULL";
              return RAutoLoadJs();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RAutoLoadJs: not a QObject";
              return RAutoLoadJs();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RAutoLoadJs_ptr: no wrapper";
              handler.trace();
              return RAutoLoadJs();
          }
          //RAutoLoadJs* ret = getWrapped_RAutoLoadJs(wrapper);
          RAutoLoadJs* ret = RAutoLoadJs_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RAutoLoadJs();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RAutoLoadJs(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RAutoLoadJs: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RAutoLoadJs::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RBlockReferenceData(RJSApi& handler, const RBlockReferenceData* v) {
          QJSEngine* engine = handler.getEngine();
          RBlockReferenceData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RBlockReferenceData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RBlockReferenceData object:
              ret = new RBlockReferenceData_Wrapper(handler, new RBlockReferenceData(*v), true);
          }

          // JS: new RBlockReferenceData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RBlockReferenceData");
          if (cl.isUndefined()) {
              qWarning() << "Class RBlockReferenceData is undefined. Use RBlockReferenceData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RBlockReferenceData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RBlockReferenceData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RBlockReferenceData(RJSApi& handler, const RBlockReferenceData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RBlockReferenceData object:
          RBlockReferenceData_Wrapper* ret = new RBlockReferenceData_Wrapper(handler, new RBlockReferenceData(v), true);

          // JS: new RBlockReferenceData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RBlockReferenceData");
          if (cl.isUndefined()) {
              qWarning() << "Class RBlockReferenceData is undefined. Use RBlockReferenceData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RBlockReferenceData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RBlockReferenceData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RBlockReferenceData RJSHelper_qcad::js2cpp_RBlockReferenceData(RJSApi& handler, const QJSValue& v) {
          /*
          RBlockReferenceData_Wrapper* wrapper = getWrapper<RBlockReferenceData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RBlockReferenceData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RBlockReferenceData();
          }
          //return *(RBlockReferenceData*)wrapper->getWrappedVoid();
          RBlockReferenceData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RBlockReferenceData: wrapped pointer is NULL";
              return RBlockReferenceData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RBlockReferenceData: not a QObject";
              return RBlockReferenceData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RBlockReferenceData_ptr: no wrapper";
              handler.trace();
              return RBlockReferenceData();
          }
          //RBlockReferenceData* ret = getWrapped_RBlockReferenceData(wrapper);
          RBlockReferenceData* ret = RBlockReferenceData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RBlockReferenceData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RBlockReferenceData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RBlockReferenceData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RBlockReferenceData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RBox(RJSApi& handler, const RBox* v) {
          QJSEngine* engine = handler.getEngine();
          RBox_Wrapper* ret;

          if (v==nullptr) {
              ret = new RBox_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RBox object:
              ret = new RBox_Wrapper(handler, new RBox(*v), true);
          }

          // JS: new RBox('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RBox");
          if (cl.isUndefined()) {
              qWarning() << "Class RBox is undefined. Use RBox_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RBox('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RBox(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RBox(RJSApi& handler, const RBox& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RBox object:
          RBox_Wrapper* ret = new RBox_Wrapper(handler, new RBox(v), true);

          // JS: new RBox('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RBox");
          if (cl.isUndefined()) {
              qWarning() << "Class RBox is undefined. Use RBox_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RBox('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RBox(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RBox RJSHelper_qcad::js2cpp_RBox(RJSApi& handler, const QJSValue& v) {
          /*
          RBox_Wrapper* wrapper = getWrapper<RBox_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RBox: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RBox();
          }
          //return *(RBox*)wrapper->getWrappedVoid();
          RBox* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RBox: wrapped pointer is NULL";
              return RBox();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RBox: not a QObject";
              return RBox();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RBox_ptr: no wrapper";
              handler.trace();
              return RBox();
          }
          //RBox* ret = getWrapped_RBox(wrapper);
          RBox* ret = RBox_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RBox();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RBox(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RBox: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RBox::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RCircle(RJSApi& handler, const RCircle* v) {
          QJSEngine* engine = handler.getEngine();
          RCircle_Wrapper* ret;

          if (v==nullptr) {
              ret = new RCircle_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RCircle object:
              ret = new RCircle_Wrapper(handler, new RCircle(*v), true);
          }

          // JS: new RCircle('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCircle");
          if (cl.isUndefined()) {
              qWarning() << "Class RCircle is undefined. Use RCircle_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCircle('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCircle(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RCircle(RJSApi& handler, const RCircle& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RCircle object:
          RCircle_Wrapper* ret = new RCircle_Wrapper(handler, new RCircle(v), true);

          // JS: new RCircle('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCircle");
          if (cl.isUndefined()) {
              qWarning() << "Class RCircle is undefined. Use RCircle_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCircle('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCircle(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RCircle RJSHelper_qcad::js2cpp_RCircle(RJSApi& handler, const QJSValue& v) {
          /*
          RCircle_Wrapper* wrapper = getWrapper<RCircle_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCircle: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RCircle();
          }
          //return *(RCircle*)wrapper->getWrappedVoid();
          RCircle* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RCircle: wrapped pointer is NULL";
              return RCircle();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RCircle: not a QObject";
              return RCircle();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCircle_ptr: no wrapper";
              handler.trace();
              return RCircle();
          }
          //RCircle* ret = getWrapped_RCircle(wrapper);
          RCircle* ret = RCircle_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RCircle();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RCircle(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RCircle: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RCircle::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RCircleData(RJSApi& handler, const RCircleData* v) {
          QJSEngine* engine = handler.getEngine();
          RCircleData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RCircleData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RCircleData object:
              ret = new RCircleData_Wrapper(handler, new RCircleData(*v), true);
          }

          // JS: new RCircleData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCircleData");
          if (cl.isUndefined()) {
              qWarning() << "Class RCircleData is undefined. Use RCircleData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCircleData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCircleData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RCircleData(RJSApi& handler, const RCircleData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RCircleData object:
          RCircleData_Wrapper* ret = new RCircleData_Wrapper(handler, new RCircleData(v), true);

          // JS: new RCircleData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCircleData");
          if (cl.isUndefined()) {
              qWarning() << "Class RCircleData is undefined. Use RCircleData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCircleData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCircleData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RCircleData RJSHelper_qcad::js2cpp_RCircleData(RJSApi& handler, const QJSValue& v) {
          /*
          RCircleData_Wrapper* wrapper = getWrapper<RCircleData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCircleData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RCircleData();
          }
          //return *(RCircleData*)wrapper->getWrappedVoid();
          RCircleData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RCircleData: wrapped pointer is NULL";
              return RCircleData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RCircleData: not a QObject";
              return RCircleData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCircleData_ptr: no wrapper";
              handler.trace();
              return RCircleData();
          }
          //RCircleData* ret = getWrapped_RCircleData(wrapper);
          RCircleData* ret = RCircleData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RCircleData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RCircleData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RCircleData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RCircleData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RColor(RJSApi& handler, const RColor* v) {
          QJSEngine* engine = handler.getEngine();
          RColor_Wrapper* ret;

          if (v==nullptr) {
              ret = new RColor_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RColor object:
              ret = new RColor_Wrapper(handler, new RColor(*v), true);
          }

          // JS: new RColor('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RColor");
          if (cl.isUndefined()) {
              qWarning() << "Class RColor is undefined. Use RColor_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RColor('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RColor(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RColor(RJSApi& handler, const RColor& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RColor object:
          RColor_Wrapper* ret = new RColor_Wrapper(handler, new RColor(v), true);

          // JS: new RColor('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RColor");
          if (cl.isUndefined()) {
              qWarning() << "Class RColor is undefined. Use RColor_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RColor('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RColor(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RColor RJSHelper_qcad::js2cpp_RColor(RJSApi& handler, const QJSValue& v) {
          /*
          RColor_Wrapper* wrapper = getWrapper<RColor_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RColor: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RColor();
          }
          //return *(RColor*)wrapper->getWrappedVoid();
          RColor* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RColor: wrapped pointer is NULL";
              return RColor();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RColor: not a QObject";
              return RColor();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RColor_ptr: no wrapper";
              handler.trace();
              return RColor();
          }
          //RColor* ret = getWrapped_RColor(wrapper);
          RColor* ret = RColor_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RColor();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RColor(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RColor: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RColor::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDebug(RJSApi& handler, const RDebug* v) {
          QJSEngine* engine = handler.getEngine();
          RDebug_Wrapper* ret;

          if (v==nullptr) {
              ret = new RDebug_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RDebug object:
              ret = new RDebug_Wrapper(handler, new RDebug(*v), true);
          }

          // JS: new RDebug('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDebug");
          if (cl.isUndefined()) {
              qWarning() << "Class RDebug is undefined. Use RDebug_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDebug('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDebug(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RDebug(RJSApi& handler, const RDebug& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RDebug object:
          RDebug_Wrapper* ret = new RDebug_Wrapper(handler, new RDebug(v), true);

          // JS: new RDebug('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDebug");
          if (cl.isUndefined()) {
              qWarning() << "Class RDebug is undefined. Use RDebug_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDebug('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDebug(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RDebug RJSHelper_qcad::js2cpp_RDebug(RJSApi& handler, const QJSValue& v) {
          /*
          RDebug_Wrapper* wrapper = getWrapper<RDebug_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDebug: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RDebug();
          }
          //return *(RDebug*)wrapper->getWrappedVoid();
          RDebug* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RDebug: wrapped pointer is NULL";
              return RDebug();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDebug: not a QObject";
              return RDebug();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDebug_ptr: no wrapper";
              handler.trace();
              return RDebug();
          }
          //RDebug* ret = getWrapped_RDebug(wrapper);
          RDebug* ret = RDebug_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RDebug();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RDebug(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDebug: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RDebug::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimAlignedData(RJSApi& handler, const RDimAlignedData* v) {
          QJSEngine* engine = handler.getEngine();
          RDimAlignedData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RDimAlignedData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RDimAlignedData object:
              ret = new RDimAlignedData_Wrapper(handler, new RDimAlignedData(*v), true);
          }

          // JS: new RDimAlignedData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAlignedData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAlignedData is undefined. Use RDimAlignedData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimAlignedData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimAlignedData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RDimAlignedData(RJSApi& handler, const RDimAlignedData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RDimAlignedData object:
          RDimAlignedData_Wrapper* ret = new RDimAlignedData_Wrapper(handler, new RDimAlignedData(v), true);

          // JS: new RDimAlignedData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAlignedData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAlignedData is undefined. Use RDimAlignedData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimAlignedData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimAlignedData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RDimAlignedData RJSHelper_qcad::js2cpp_RDimAlignedData(RJSApi& handler, const QJSValue& v) {
          /*
          RDimAlignedData_Wrapper* wrapper = getWrapper<RDimAlignedData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimAlignedData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RDimAlignedData();
          }
          //return *(RDimAlignedData*)wrapper->getWrappedVoid();
          RDimAlignedData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RDimAlignedData: wrapped pointer is NULL";
              return RDimAlignedData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimAlignedData: not a QObject";
              return RDimAlignedData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimAlignedData_ptr: no wrapper";
              handler.trace();
              return RDimAlignedData();
          }
          //RDimAlignedData* ret = getWrapped_RDimAlignedData(wrapper);
          RDimAlignedData* ret = RDimAlignedData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RDimAlignedData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RDimAlignedData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimAlignedData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RDimAlignedData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimAngular2LData(RJSApi& handler, const RDimAngular2LData* v) {
          QJSEngine* engine = handler.getEngine();
          RDimAngular2LData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RDimAngular2LData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RDimAngular2LData object:
              ret = new RDimAngular2LData_Wrapper(handler, new RDimAngular2LData(*v), true);
          }

          // JS: new RDimAngular2LData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAngular2LData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAngular2LData is undefined. Use RDimAngular2LData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimAngular2LData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimAngular2LData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RDimAngular2LData(RJSApi& handler, const RDimAngular2LData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RDimAngular2LData object:
          RDimAngular2LData_Wrapper* ret = new RDimAngular2LData_Wrapper(handler, new RDimAngular2LData(v), true);

          // JS: new RDimAngular2LData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAngular2LData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAngular2LData is undefined. Use RDimAngular2LData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimAngular2LData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimAngular2LData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RDimAngular2LData RJSHelper_qcad::js2cpp_RDimAngular2LData(RJSApi& handler, const QJSValue& v) {
          /*
          RDimAngular2LData_Wrapper* wrapper = getWrapper<RDimAngular2LData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimAngular2LData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RDimAngular2LData();
          }
          //return *(RDimAngular2LData*)wrapper->getWrappedVoid();
          RDimAngular2LData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RDimAngular2LData: wrapped pointer is NULL";
              return RDimAngular2LData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimAngular2LData: not a QObject";
              return RDimAngular2LData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimAngular2LData_ptr: no wrapper";
              handler.trace();
              return RDimAngular2LData();
          }
          //RDimAngular2LData* ret = getWrapped_RDimAngular2LData(wrapper);
          RDimAngular2LData* ret = RDimAngular2LData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RDimAngular2LData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RDimAngular2LData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimAngular2LData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RDimAngular2LData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimAngular3PData(RJSApi& handler, const RDimAngular3PData* v) {
          QJSEngine* engine = handler.getEngine();
          RDimAngular3PData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RDimAngular3PData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RDimAngular3PData object:
              ret = new RDimAngular3PData_Wrapper(handler, new RDimAngular3PData(*v), true);
          }

          // JS: new RDimAngular3PData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAngular3PData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAngular3PData is undefined. Use RDimAngular3PData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimAngular3PData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimAngular3PData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RDimAngular3PData(RJSApi& handler, const RDimAngular3PData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RDimAngular3PData object:
          RDimAngular3PData_Wrapper* ret = new RDimAngular3PData_Wrapper(handler, new RDimAngular3PData(v), true);

          // JS: new RDimAngular3PData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAngular3PData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAngular3PData is undefined. Use RDimAngular3PData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimAngular3PData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimAngular3PData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RDimAngular3PData RJSHelper_qcad::js2cpp_RDimAngular3PData(RJSApi& handler, const QJSValue& v) {
          /*
          RDimAngular3PData_Wrapper* wrapper = getWrapper<RDimAngular3PData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimAngular3PData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RDimAngular3PData();
          }
          //return *(RDimAngular3PData*)wrapper->getWrappedVoid();
          RDimAngular3PData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RDimAngular3PData: wrapped pointer is NULL";
              return RDimAngular3PData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimAngular3PData: not a QObject";
              return RDimAngular3PData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimAngular3PData_ptr: no wrapper";
              handler.trace();
              return RDimAngular3PData();
          }
          //RDimAngular3PData* ret = getWrapped_RDimAngular3PData(wrapper);
          RDimAngular3PData* ret = RDimAngular3PData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RDimAngular3PData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RDimAngular3PData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimAngular3PData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RDimAngular3PData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimArcLengthData(RJSApi& handler, const RDimArcLengthData* v) {
          QJSEngine* engine = handler.getEngine();
          RDimArcLengthData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RDimArcLengthData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RDimArcLengthData object:
              ret = new RDimArcLengthData_Wrapper(handler, new RDimArcLengthData(*v), true);
          }

          // JS: new RDimArcLengthData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimArcLengthData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimArcLengthData is undefined. Use RDimArcLengthData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimArcLengthData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimArcLengthData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RDimArcLengthData(RJSApi& handler, const RDimArcLengthData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RDimArcLengthData object:
          RDimArcLengthData_Wrapper* ret = new RDimArcLengthData_Wrapper(handler, new RDimArcLengthData(v), true);

          // JS: new RDimArcLengthData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimArcLengthData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimArcLengthData is undefined. Use RDimArcLengthData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimArcLengthData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimArcLengthData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RDimArcLengthData RJSHelper_qcad::js2cpp_RDimArcLengthData(RJSApi& handler, const QJSValue& v) {
          /*
          RDimArcLengthData_Wrapper* wrapper = getWrapper<RDimArcLengthData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimArcLengthData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RDimArcLengthData();
          }
          //return *(RDimArcLengthData*)wrapper->getWrappedVoid();
          RDimArcLengthData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RDimArcLengthData: wrapped pointer is NULL";
              return RDimArcLengthData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimArcLengthData: not a QObject";
              return RDimArcLengthData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimArcLengthData_ptr: no wrapper";
              handler.trace();
              return RDimArcLengthData();
          }
          //RDimArcLengthData* ret = getWrapped_RDimArcLengthData(wrapper);
          RDimArcLengthData* ret = RDimArcLengthData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RDimArcLengthData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RDimArcLengthData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimArcLengthData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RDimArcLengthData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimDiametricData(RJSApi& handler, const RDimDiametricData* v) {
          QJSEngine* engine = handler.getEngine();
          RDimDiametricData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RDimDiametricData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RDimDiametricData object:
              ret = new RDimDiametricData_Wrapper(handler, new RDimDiametricData(*v), true);
          }

          // JS: new RDimDiametricData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimDiametricData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimDiametricData is undefined. Use RDimDiametricData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimDiametricData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimDiametricData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RDimDiametricData(RJSApi& handler, const RDimDiametricData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RDimDiametricData object:
          RDimDiametricData_Wrapper* ret = new RDimDiametricData_Wrapper(handler, new RDimDiametricData(v), true);

          // JS: new RDimDiametricData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimDiametricData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimDiametricData is undefined. Use RDimDiametricData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimDiametricData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimDiametricData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RDimDiametricData RJSHelper_qcad::js2cpp_RDimDiametricData(RJSApi& handler, const QJSValue& v) {
          /*
          RDimDiametricData_Wrapper* wrapper = getWrapper<RDimDiametricData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimDiametricData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RDimDiametricData();
          }
          //return *(RDimDiametricData*)wrapper->getWrappedVoid();
          RDimDiametricData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RDimDiametricData: wrapped pointer is NULL";
              return RDimDiametricData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimDiametricData: not a QObject";
              return RDimDiametricData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimDiametricData_ptr: no wrapper";
              handler.trace();
              return RDimDiametricData();
          }
          //RDimDiametricData* ret = getWrapped_RDimDiametricData(wrapper);
          RDimDiametricData* ret = RDimDiametricData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RDimDiametricData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RDimDiametricData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimDiametricData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RDimDiametricData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimOrdinateData(RJSApi& handler, const RDimOrdinateData* v) {
          QJSEngine* engine = handler.getEngine();
          RDimOrdinateData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RDimOrdinateData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RDimOrdinateData object:
              ret = new RDimOrdinateData_Wrapper(handler, new RDimOrdinateData(*v), true);
          }

          // JS: new RDimOrdinateData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimOrdinateData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimOrdinateData is undefined. Use RDimOrdinateData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimOrdinateData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimOrdinateData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RDimOrdinateData(RJSApi& handler, const RDimOrdinateData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RDimOrdinateData object:
          RDimOrdinateData_Wrapper* ret = new RDimOrdinateData_Wrapper(handler, new RDimOrdinateData(v), true);

          // JS: new RDimOrdinateData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimOrdinateData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimOrdinateData is undefined. Use RDimOrdinateData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimOrdinateData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimOrdinateData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RDimOrdinateData RJSHelper_qcad::js2cpp_RDimOrdinateData(RJSApi& handler, const QJSValue& v) {
          /*
          RDimOrdinateData_Wrapper* wrapper = getWrapper<RDimOrdinateData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimOrdinateData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RDimOrdinateData();
          }
          //return *(RDimOrdinateData*)wrapper->getWrappedVoid();
          RDimOrdinateData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RDimOrdinateData: wrapped pointer is NULL";
              return RDimOrdinateData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimOrdinateData: not a QObject";
              return RDimOrdinateData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimOrdinateData_ptr: no wrapper";
              handler.trace();
              return RDimOrdinateData();
          }
          //RDimOrdinateData* ret = getWrapped_RDimOrdinateData(wrapper);
          RDimOrdinateData* ret = RDimOrdinateData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RDimOrdinateData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RDimOrdinateData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimOrdinateData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RDimOrdinateData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimRadialData(RJSApi& handler, const RDimRadialData* v) {
          QJSEngine* engine = handler.getEngine();
          RDimRadialData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RDimRadialData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RDimRadialData object:
              ret = new RDimRadialData_Wrapper(handler, new RDimRadialData(*v), true);
          }

          // JS: new RDimRadialData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimRadialData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimRadialData is undefined. Use RDimRadialData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimRadialData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimRadialData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RDimRadialData(RJSApi& handler, const RDimRadialData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RDimRadialData object:
          RDimRadialData_Wrapper* ret = new RDimRadialData_Wrapper(handler, new RDimRadialData(v), true);

          // JS: new RDimRadialData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimRadialData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimRadialData is undefined. Use RDimRadialData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimRadialData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimRadialData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RDimRadialData RJSHelper_qcad::js2cpp_RDimRadialData(RJSApi& handler, const QJSValue& v) {
          /*
          RDimRadialData_Wrapper* wrapper = getWrapper<RDimRadialData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimRadialData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RDimRadialData();
          }
          //return *(RDimRadialData*)wrapper->getWrappedVoid();
          RDimRadialData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RDimRadialData: wrapped pointer is NULL";
              return RDimRadialData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimRadialData: not a QObject";
              return RDimRadialData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimRadialData_ptr: no wrapper";
              handler.trace();
              return RDimRadialData();
          }
          //RDimRadialData* ret = getWrapped_RDimRadialData(wrapper);
          RDimRadialData* ret = RDimRadialData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RDimRadialData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RDimRadialData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimRadialData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RDimRadialData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimRotatedData(RJSApi& handler, const RDimRotatedData* v) {
          QJSEngine* engine = handler.getEngine();
          RDimRotatedData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RDimRotatedData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RDimRotatedData object:
              ret = new RDimRotatedData_Wrapper(handler, new RDimRotatedData(*v), true);
          }

          // JS: new RDimRotatedData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimRotatedData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimRotatedData is undefined. Use RDimRotatedData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimRotatedData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimRotatedData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RDimRotatedData(RJSApi& handler, const RDimRotatedData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RDimRotatedData object:
          RDimRotatedData_Wrapper* ret = new RDimRotatedData_Wrapper(handler, new RDimRotatedData(v), true);

          // JS: new RDimRotatedData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimRotatedData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimRotatedData is undefined. Use RDimRotatedData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimRotatedData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimRotatedData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RDimRotatedData RJSHelper_qcad::js2cpp_RDimRotatedData(RJSApi& handler, const QJSValue& v) {
          /*
          RDimRotatedData_Wrapper* wrapper = getWrapper<RDimRotatedData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimRotatedData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RDimRotatedData();
          }
          //return *(RDimRotatedData*)wrapper->getWrappedVoid();
          RDimRotatedData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RDimRotatedData: wrapped pointer is NULL";
              return RDimRotatedData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimRotatedData: not a QObject";
              return RDimRotatedData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimRotatedData_ptr: no wrapper";
              handler.trace();
              return RDimRotatedData();
          }
          //RDimRotatedData* ret = getWrapped_RDimRotatedData(wrapper);
          RDimRotatedData* ret = RDimRotatedData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RDimRotatedData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RDimRotatedData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimRotatedData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RDimRotatedData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDimStyleData(RJSApi& handler, const RDimStyleData* v) {
          QJSEngine* engine = handler.getEngine();
          RDimStyleData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RDimStyleData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RDimStyleData object:
              ret = new RDimStyleData_Wrapper(handler, new RDimStyleData(*v), true);
          }

          // JS: new RDimStyleData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimStyleData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimStyleData is undefined. Use RDimStyleData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimStyleData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimStyleData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RDimStyleData(RJSApi& handler, const RDimStyleData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RDimStyleData object:
          RDimStyleData_Wrapper* ret = new RDimStyleData_Wrapper(handler, new RDimStyleData(v), true);

          // JS: new RDimStyleData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimStyleData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimStyleData is undefined. Use RDimStyleData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDimStyleData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDimStyleData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RDimStyleData RJSHelper_qcad::js2cpp_RDimStyleData(RJSApi& handler, const QJSValue& v) {
          /*
          RDimStyleData_Wrapper* wrapper = getWrapper<RDimStyleData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimStyleData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RDimStyleData();
          }
          //return *(RDimStyleData*)wrapper->getWrappedVoid();
          RDimStyleData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RDimStyleData: wrapped pointer is NULL";
              return RDimStyleData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDimStyleData: not a QObject";
              return RDimStyleData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDimStyleData_ptr: no wrapper";
              handler.trace();
              return RDimStyleData();
          }
          //RDimStyleData* ret = getWrapped_RDimStyleData(wrapper);
          RDimStyleData* ret = RDimStyleData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RDimStyleData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RDimStyleData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDimStyleData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RDimStyleData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RDxfServices(RJSApi& handler, const RDxfServices* v) {
          QJSEngine* engine = handler.getEngine();
          RDxfServices_Wrapper* ret;

          if (v==nullptr) {
              ret = new RDxfServices_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RDxfServices object:
              ret = new RDxfServices_Wrapper(handler, new RDxfServices(*v), true);
          }

          // JS: new RDxfServices('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDxfServices");
          if (cl.isUndefined()) {
              qWarning() << "Class RDxfServices is undefined. Use RDxfServices_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDxfServices('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDxfServices(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RDxfServices(RJSApi& handler, const RDxfServices& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RDxfServices object:
          RDxfServices_Wrapper* ret = new RDxfServices_Wrapper(handler, new RDxfServices(v), true);

          // JS: new RDxfServices('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDxfServices");
          if (cl.isUndefined()) {
              qWarning() << "Class RDxfServices is undefined. Use RDxfServices_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDxfServices('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDxfServices(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RDxfServices RJSHelper_qcad::js2cpp_RDxfServices(RJSApi& handler, const QJSValue& v) {
          /*
          RDxfServices_Wrapper* wrapper = getWrapper<RDxfServices_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDxfServices: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RDxfServices();
          }
          //return *(RDxfServices*)wrapper->getWrappedVoid();
          RDxfServices* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RDxfServices: wrapped pointer is NULL";
              return RDxfServices();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDxfServices: not a QObject";
              return RDxfServices();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDxfServices_ptr: no wrapper";
              handler.trace();
              return RDxfServices();
          }
          //RDxfServices* ret = getWrapped_RDxfServices(wrapper);
          RDxfServices* ret = RDxfServices_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RDxfServices();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RDxfServices(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDxfServices: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RDxfServices::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_REllipse(RJSApi& handler, const REllipse* v) {
          QJSEngine* engine = handler.getEngine();
          REllipse_Wrapper* ret;

          if (v==nullptr) {
              ret = new REllipse_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of REllipse object:
              ret = new REllipse_Wrapper(handler, new REllipse(*v), true);
          }

          // JS: new REllipse('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("REllipse");
          if (cl.isUndefined()) {
              qWarning() << "Class REllipse is undefined. Use REllipse_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new REllipse('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new REllipse(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_REllipse(RJSApi& handler, const REllipse& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the REllipse object:
          REllipse_Wrapper* ret = new REllipse_Wrapper(handler, new REllipse(v), true);

          // JS: new REllipse('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("REllipse");
          if (cl.isUndefined()) {
              qWarning() << "Class REllipse is undefined. Use REllipse_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new REllipse('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new REllipse(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      REllipse RJSHelper_qcad::js2cpp_REllipse(RJSApi& handler, const QJSValue& v) {
          /*
          REllipse_Wrapper* wrapper = getWrapper<REllipse_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_REllipse: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return REllipse();
          }
          //return *(REllipse*)wrapper->getWrappedVoid();
          REllipse* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_REllipse: wrapped pointer is NULL";
              return REllipse();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_REllipse: not a QObject";
              return REllipse();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_REllipse_ptr: no wrapper";
              handler.trace();
              return REllipse();
          }
          //REllipse* ret = getWrapped_REllipse(wrapper);
          REllipse* ret = REllipse_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return REllipse();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_REllipse(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_REllipse: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_REllipse::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_REllipseData(RJSApi& handler, const REllipseData* v) {
          QJSEngine* engine = handler.getEngine();
          REllipseData_Wrapper* ret;

          if (v==nullptr) {
              ret = new REllipseData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of REllipseData object:
              ret = new REllipseData_Wrapper(handler, new REllipseData(*v), true);
          }

          // JS: new REllipseData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("REllipseData");
          if (cl.isUndefined()) {
              qWarning() << "Class REllipseData is undefined. Use REllipseData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new REllipseData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new REllipseData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_REllipseData(RJSApi& handler, const REllipseData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the REllipseData object:
          REllipseData_Wrapper* ret = new REllipseData_Wrapper(handler, new REllipseData(v), true);

          // JS: new REllipseData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("REllipseData");
          if (cl.isUndefined()) {
              qWarning() << "Class REllipseData is undefined. Use REllipseData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new REllipseData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new REllipseData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      REllipseData RJSHelper_qcad::js2cpp_REllipseData(RJSApi& handler, const QJSValue& v) {
          /*
          REllipseData_Wrapper* wrapper = getWrapper<REllipseData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_REllipseData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return REllipseData();
          }
          //return *(REllipseData*)wrapper->getWrappedVoid();
          REllipseData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_REllipseData: wrapped pointer is NULL";
              return REllipseData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_REllipseData: not a QObject";
              return REllipseData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_REllipseData_ptr: no wrapper";
              handler.trace();
              return REllipseData();
          }
          //REllipseData* ret = getWrapped_REllipseData(wrapper);
          REllipseData* ret = REllipseData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return REllipseData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_REllipseData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_REllipseData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_REllipseData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFaceData(RJSApi& handler, const RFaceData* v) {
          QJSEngine* engine = handler.getEngine();
          RFaceData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RFaceData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RFaceData object:
              ret = new RFaceData_Wrapper(handler, new RFaceData(*v), true);
          }

          // JS: new RFaceData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFaceData");
          if (cl.isUndefined()) {
              qWarning() << "Class RFaceData is undefined. Use RFaceData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFaceData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFaceData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RFaceData(RJSApi& handler, const RFaceData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RFaceData object:
          RFaceData_Wrapper* ret = new RFaceData_Wrapper(handler, new RFaceData(v), true);

          // JS: new RFaceData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFaceData");
          if (cl.isUndefined()) {
              qWarning() << "Class RFaceData is undefined. Use RFaceData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFaceData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFaceData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RFaceData RJSHelper_qcad::js2cpp_RFaceData(RJSApi& handler, const QJSValue& v) {
          /*
          RFaceData_Wrapper* wrapper = getWrapper<RFaceData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFaceData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RFaceData();
          }
          //return *(RFaceData*)wrapper->getWrappedVoid();
          RFaceData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RFaceData: wrapped pointer is NULL";
              return RFaceData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFaceData: not a QObject";
              return RFaceData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFaceData_ptr: no wrapper";
              handler.trace();
              return RFaceData();
          }
          //RFaceData* ret = getWrapped_RFaceData(wrapper);
          RFaceData* ret = RFaceData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RFaceData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RFaceData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFaceData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RFaceData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFileCache(RJSApi& handler, const RFileCache* v) {
          QJSEngine* engine = handler.getEngine();
          RFileCache_Wrapper* ret;

          if (v==nullptr) {
              ret = new RFileCache_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RFileCache object:
              ret = new RFileCache_Wrapper(handler, new RFileCache(*v), true);
          }

          // JS: new RFileCache('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileCache");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileCache is undefined. Use RFileCache_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileCache('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileCache(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RFileCache(RJSApi& handler, const RFileCache& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RFileCache object:
          RFileCache_Wrapper* ret = new RFileCache_Wrapper(handler, new RFileCache(v), true);

          // JS: new RFileCache('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileCache");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileCache is undefined. Use RFileCache_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileCache('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileCache(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RFileCache RJSHelper_qcad::js2cpp_RFileCache(RJSApi& handler, const QJSValue& v) {
          /*
          RFileCache_Wrapper* wrapper = getWrapper<RFileCache_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileCache: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RFileCache();
          }
          //return *(RFileCache*)wrapper->getWrappedVoid();
          RFileCache* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RFileCache: wrapped pointer is NULL";
              return RFileCache();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFileCache: not a QObject";
              return RFileCache();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileCache_ptr: no wrapper";
              handler.trace();
              return RFileCache();
          }
          //RFileCache* ret = getWrapped_RFileCache(wrapper);
          RFileCache* ret = RFileCache_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RFileCache();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RFileCache(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFileCache: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RFileCache::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFileExporterAdapter(RJSApi& handler, const RFileExporterAdapter* v) {
          QJSEngine* engine = handler.getEngine();
          RFileExporterAdapter_Wrapper* ret;

          if (v==nullptr) {
              ret = new RFileExporterAdapter_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RFileExporterAdapter object:
              ret = new RFileExporterAdapter_Wrapper(handler, new RFileExporterAdapter(*v), true);
          }

          // JS: new RFileExporterAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileExporterAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileExporterAdapter is undefined. Use RFileExporterAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileExporterAdapter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileExporterAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RFileExporterAdapter(RJSApi& handler, const RFileExporterAdapter& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RFileExporterAdapter object:
          RFileExporterAdapter_Wrapper* ret = new RFileExporterAdapter_Wrapper(handler, new RFileExporterAdapter(v), true);

          // JS: new RFileExporterAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileExporterAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileExporterAdapter is undefined. Use RFileExporterAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileExporterAdapter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileExporterAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RFileExporterAdapter RJSHelper_qcad::js2cpp_RFileExporterAdapter(RJSApi& handler, const QJSValue& v) {
          /*
          RFileExporterAdapter_Wrapper* wrapper = getWrapper<RFileExporterAdapter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileExporterAdapter: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RFileExporterAdapter();
          }
          //return *(RFileExporterAdapter*)wrapper->getWrappedVoid();
          RFileExporterAdapter* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RFileExporterAdapter: wrapped pointer is NULL";
              return RFileExporterAdapter();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFileExporterAdapter: not a QObject";
              return RFileExporterAdapter();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileExporterAdapter_ptr: no wrapper";
              handler.trace();
              return RFileExporterAdapter();
          }
          //RFileExporterAdapter* ret = getWrapped_RFileExporterAdapter(wrapper);
          RFileExporterAdapter* ret = RFileExporterAdapter_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RFileExporterAdapter();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RFileExporterAdapter(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFileExporterAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RFileExporterAdapter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFileExporterFactoryAdapter(RJSApi& handler, const RFileExporterFactoryAdapter* v) {
          QJSEngine* engine = handler.getEngine();
          RFileExporterFactoryAdapter_Wrapper* ret;

          if (v==nullptr) {
              ret = new RFileExporterFactoryAdapter_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RFileExporterFactoryAdapter object:
              ret = new RFileExporterFactoryAdapter_Wrapper(handler, new RFileExporterFactoryAdapter(*v), true);
          }

          // JS: new RFileExporterFactoryAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileExporterFactoryAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileExporterFactoryAdapter is undefined. Use RFileExporterFactoryAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileExporterFactoryAdapter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileExporterFactoryAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RFileExporterFactoryAdapter(RJSApi& handler, const RFileExporterFactoryAdapter& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RFileExporterFactoryAdapter object:
          RFileExporterFactoryAdapter_Wrapper* ret = new RFileExporterFactoryAdapter_Wrapper(handler, new RFileExporterFactoryAdapter(v), true);

          // JS: new RFileExporterFactoryAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileExporterFactoryAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileExporterFactoryAdapter is undefined. Use RFileExporterFactoryAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileExporterFactoryAdapter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileExporterFactoryAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RFileExporterFactoryAdapter RJSHelper_qcad::js2cpp_RFileExporterFactoryAdapter(RJSApi& handler, const QJSValue& v) {
          /*
          RFileExporterFactoryAdapter_Wrapper* wrapper = getWrapper<RFileExporterFactoryAdapter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileExporterFactoryAdapter: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RFileExporterFactoryAdapter();
          }
          //return *(RFileExporterFactoryAdapter*)wrapper->getWrappedVoid();
          RFileExporterFactoryAdapter* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RFileExporterFactoryAdapter: wrapped pointer is NULL";
              return RFileExporterFactoryAdapter();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFileExporterFactoryAdapter: not a QObject";
              return RFileExporterFactoryAdapter();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileExporterFactoryAdapter_ptr: no wrapper";
              handler.trace();
              return RFileExporterFactoryAdapter();
          }
          //RFileExporterFactoryAdapter* ret = getWrapped_RFileExporterFactoryAdapter(wrapper);
          RFileExporterFactoryAdapter* ret = RFileExporterFactoryAdapter_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RFileExporterFactoryAdapter();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RFileExporterFactoryAdapter(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFileExporterFactoryAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RFileExporterFactoryAdapter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFileExporterRegistry(RJSApi& handler, const RFileExporterRegistry* v) {
          QJSEngine* engine = handler.getEngine();
          RFileExporterRegistry_Wrapper* ret;

          if (v==nullptr) {
              ret = new RFileExporterRegistry_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RFileExporterRegistry object:
              ret = new RFileExporterRegistry_Wrapper(handler, new RFileExporterRegistry(*v), true);
          }

          // JS: new RFileExporterRegistry('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileExporterRegistry");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileExporterRegistry is undefined. Use RFileExporterRegistry_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileExporterRegistry('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileExporterRegistry(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RFileExporterRegistry(RJSApi& handler, const RFileExporterRegistry& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RFileExporterRegistry object:
          RFileExporterRegistry_Wrapper* ret = new RFileExporterRegistry_Wrapper(handler, new RFileExporterRegistry(v), true);

          // JS: new RFileExporterRegistry('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileExporterRegistry");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileExporterRegistry is undefined. Use RFileExporterRegistry_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileExporterRegistry('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileExporterRegistry(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RFileExporterRegistry RJSHelper_qcad::js2cpp_RFileExporterRegistry(RJSApi& handler, const QJSValue& v) {
          /*
          RFileExporterRegistry_Wrapper* wrapper = getWrapper<RFileExporterRegistry_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileExporterRegistry: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RFileExporterRegistry();
          }
          //return *(RFileExporterRegistry*)wrapper->getWrappedVoid();
          RFileExporterRegistry* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RFileExporterRegistry: wrapped pointer is NULL";
              return RFileExporterRegistry();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFileExporterRegistry: not a QObject";
              return RFileExporterRegistry();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileExporterRegistry_ptr: no wrapper";
              handler.trace();
              return RFileExporterRegistry();
          }
          //RFileExporterRegistry* ret = getWrapped_RFileExporterRegistry(wrapper);
          RFileExporterRegistry* ret = RFileExporterRegistry_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RFileExporterRegistry();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RFileExporterRegistry(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFileExporterRegistry: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RFileExporterRegistry::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFileImporterAdapter(RJSApi& handler, const RFileImporterAdapter* v) {
          QJSEngine* engine = handler.getEngine();
          RFileImporterAdapter_Wrapper* ret;

          if (v==nullptr) {
              ret = new RFileImporterAdapter_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RFileImporterAdapter object:
              ret = new RFileImporterAdapter_Wrapper(handler, new RFileImporterAdapter(*v), true);
          }

          // JS: new RFileImporterAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileImporterAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileImporterAdapter is undefined. Use RFileImporterAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileImporterAdapter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileImporterAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RFileImporterAdapter(RJSApi& handler, const RFileImporterAdapter& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RFileImporterAdapter object:
          RFileImporterAdapter_Wrapper* ret = new RFileImporterAdapter_Wrapper(handler, new RFileImporterAdapter(v), true);

          // JS: new RFileImporterAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileImporterAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileImporterAdapter is undefined. Use RFileImporterAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileImporterAdapter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileImporterAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RFileImporterAdapter RJSHelper_qcad::js2cpp_RFileImporterAdapter(RJSApi& handler, const QJSValue& v) {
          /*
          RFileImporterAdapter_Wrapper* wrapper = getWrapper<RFileImporterAdapter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileImporterAdapter: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RFileImporterAdapter();
          }
          //return *(RFileImporterAdapter*)wrapper->getWrappedVoid();
          RFileImporterAdapter* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RFileImporterAdapter: wrapped pointer is NULL";
              return RFileImporterAdapter();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFileImporterAdapter: not a QObject";
              return RFileImporterAdapter();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileImporterAdapter_ptr: no wrapper";
              handler.trace();
              return RFileImporterAdapter();
          }
          //RFileImporterAdapter* ret = getWrapped_RFileImporterAdapter(wrapper);
          RFileImporterAdapter* ret = RFileImporterAdapter_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RFileImporterAdapter();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RFileImporterAdapter(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFileImporterAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RFileImporterAdapter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFileImporterFactoryAdapter(RJSApi& handler, const RFileImporterFactoryAdapter* v) {
          QJSEngine* engine = handler.getEngine();
          RFileImporterFactoryAdapter_Wrapper* ret;

          if (v==nullptr) {
              ret = new RFileImporterFactoryAdapter_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RFileImporterFactoryAdapter object:
              ret = new RFileImporterFactoryAdapter_Wrapper(handler, new RFileImporterFactoryAdapter(*v), true);
          }

          // JS: new RFileImporterFactoryAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileImporterFactoryAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileImporterFactoryAdapter is undefined. Use RFileImporterFactoryAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileImporterFactoryAdapter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileImporterFactoryAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RFileImporterFactoryAdapter(RJSApi& handler, const RFileImporterFactoryAdapter& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RFileImporterFactoryAdapter object:
          RFileImporterFactoryAdapter_Wrapper* ret = new RFileImporterFactoryAdapter_Wrapper(handler, new RFileImporterFactoryAdapter(v), true);

          // JS: new RFileImporterFactoryAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileImporterFactoryAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileImporterFactoryAdapter is undefined. Use RFileImporterFactoryAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileImporterFactoryAdapter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileImporterFactoryAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RFileImporterFactoryAdapter RJSHelper_qcad::js2cpp_RFileImporterFactoryAdapter(RJSApi& handler, const QJSValue& v) {
          /*
          RFileImporterFactoryAdapter_Wrapper* wrapper = getWrapper<RFileImporterFactoryAdapter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileImporterFactoryAdapter: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RFileImporterFactoryAdapter();
          }
          //return *(RFileImporterFactoryAdapter*)wrapper->getWrappedVoid();
          RFileImporterFactoryAdapter* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RFileImporterFactoryAdapter: wrapped pointer is NULL";
              return RFileImporterFactoryAdapter();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFileImporterFactoryAdapter: not a QObject";
              return RFileImporterFactoryAdapter();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileImporterFactoryAdapter_ptr: no wrapper";
              handler.trace();
              return RFileImporterFactoryAdapter();
          }
          //RFileImporterFactoryAdapter* ret = getWrapped_RFileImporterFactoryAdapter(wrapper);
          RFileImporterFactoryAdapter* ret = RFileImporterFactoryAdapter_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RFileImporterFactoryAdapter();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RFileImporterFactoryAdapter(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFileImporterFactoryAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RFileImporterFactoryAdapter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFileImporterRegistry(RJSApi& handler, const RFileImporterRegistry* v) {
          QJSEngine* engine = handler.getEngine();
          RFileImporterRegistry_Wrapper* ret;

          if (v==nullptr) {
              ret = new RFileImporterRegistry_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RFileImporterRegistry object:
              ret = new RFileImporterRegistry_Wrapper(handler, new RFileImporterRegistry(*v), true);
          }

          // JS: new RFileImporterRegistry('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileImporterRegistry");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileImporterRegistry is undefined. Use RFileImporterRegistry_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileImporterRegistry('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileImporterRegistry(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RFileImporterRegistry(RJSApi& handler, const RFileImporterRegistry& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RFileImporterRegistry object:
          RFileImporterRegistry_Wrapper* ret = new RFileImporterRegistry_Wrapper(handler, new RFileImporterRegistry(v), true);

          // JS: new RFileImporterRegistry('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileImporterRegistry");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileImporterRegistry is undefined. Use RFileImporterRegistry_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileImporterRegistry('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileImporterRegistry(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RFileImporterRegistry RJSHelper_qcad::js2cpp_RFileImporterRegistry(RJSApi& handler, const QJSValue& v) {
          /*
          RFileImporterRegistry_Wrapper* wrapper = getWrapper<RFileImporterRegistry_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileImporterRegistry: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RFileImporterRegistry();
          }
          //return *(RFileImporterRegistry*)wrapper->getWrappedVoid();
          RFileImporterRegistry* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RFileImporterRegistry: wrapped pointer is NULL";
              return RFileImporterRegistry();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFileImporterRegistry: not a QObject";
              return RFileImporterRegistry();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileImporterRegistry_ptr: no wrapper";
              handler.trace();
              return RFileImporterRegistry();
          }
          //RFileImporterRegistry* ret = getWrapped_RFileImporterRegistry(wrapper);
          RFileImporterRegistry* ret = RFileImporterRegistry_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RFileImporterRegistry();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RFileImporterRegistry(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFileImporterRegistry: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RFileImporterRegistry::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFont(RJSApi& handler, const RFont* v) {
          QJSEngine* engine = handler.getEngine();
          RFont_Wrapper* ret;

          if (v==nullptr) {
              ret = new RFont_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RFont object:
              ret = new RFont_Wrapper(handler, new RFont(*v), true);
          }

          // JS: new RFont('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFont");
          if (cl.isUndefined()) {
              qWarning() << "Class RFont is undefined. Use RFont_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFont('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFont(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RFont(RJSApi& handler, const RFont& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RFont object:
          RFont_Wrapper* ret = new RFont_Wrapper(handler, new RFont(v), true);

          // JS: new RFont('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFont");
          if (cl.isUndefined()) {
              qWarning() << "Class RFont is undefined. Use RFont_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFont('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFont(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RFont RJSHelper_qcad::js2cpp_RFont(RJSApi& handler, const QJSValue& v) {
          /*
          RFont_Wrapper* wrapper = getWrapper<RFont_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFont: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RFont();
          }
          //return *(RFont*)wrapper->getWrappedVoid();
          RFont* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RFont: wrapped pointer is NULL";
              return RFont();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFont: not a QObject";
              return RFont();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFont_ptr: no wrapper";
              handler.trace();
              return RFont();
          }
          //RFont* ret = getWrapped_RFont(wrapper);
          RFont* ret = RFont_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RFont();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RFont(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFont: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RFont::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RFontList(RJSApi& handler, const RFontList* v) {
          QJSEngine* engine = handler.getEngine();
          RFontList_Wrapper* ret;

          if (v==nullptr) {
              ret = new RFontList_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RFontList object:
              ret = new RFontList_Wrapper(handler, new RFontList(*v), true);
          }

          // JS: new RFontList('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFontList");
          if (cl.isUndefined()) {
              qWarning() << "Class RFontList is undefined. Use RFontList_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFontList('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFontList(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RFontList(RJSApi& handler, const RFontList& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RFontList object:
          RFontList_Wrapper* ret = new RFontList_Wrapper(handler, new RFontList(v), true);

          // JS: new RFontList('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFontList");
          if (cl.isUndefined()) {
              qWarning() << "Class RFontList is undefined. Use RFontList_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFontList('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFontList(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RFontList RJSHelper_qcad::js2cpp_RFontList(RJSApi& handler, const QJSValue& v) {
          /*
          RFontList_Wrapper* wrapper = getWrapper<RFontList_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFontList: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RFontList();
          }
          //return *(RFontList*)wrapper->getWrappedVoid();
          RFontList* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RFontList: wrapped pointer is NULL";
              return RFontList();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFontList: not a QObject";
              return RFontList();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFontList_ptr: no wrapper";
              handler.trace();
              return RFontList();
          }
          //RFontList* ret = getWrapped_RFontList(wrapper);
          RFontList* ret = RFontList_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RFontList();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RFontList(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFontList: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RFontList::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RGraphicsSceneDrawable(RJSApi& handler, const RGraphicsSceneDrawable* v) {
          QJSEngine* engine = handler.getEngine();
          RGraphicsSceneDrawable_Wrapper* ret;

          if (v==nullptr) {
              ret = new RGraphicsSceneDrawable_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RGraphicsSceneDrawable object:
              ret = new RGraphicsSceneDrawable_Wrapper(handler, new RGraphicsSceneDrawable(*v), true);
          }

          // JS: new RGraphicsSceneDrawable('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RGraphicsSceneDrawable");
          if (cl.isUndefined()) {
              qWarning() << "Class RGraphicsSceneDrawable is undefined. Use RGraphicsSceneDrawable_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RGraphicsSceneDrawable('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RGraphicsSceneDrawable(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RGraphicsSceneDrawable(RJSApi& handler, const RGraphicsSceneDrawable& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RGraphicsSceneDrawable object:
          RGraphicsSceneDrawable_Wrapper* ret = new RGraphicsSceneDrawable_Wrapper(handler, new RGraphicsSceneDrawable(v), true);

          // JS: new RGraphicsSceneDrawable('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RGraphicsSceneDrawable");
          if (cl.isUndefined()) {
              qWarning() << "Class RGraphicsSceneDrawable is undefined. Use RGraphicsSceneDrawable_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RGraphicsSceneDrawable('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RGraphicsSceneDrawable(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RGraphicsSceneDrawable RJSHelper_qcad::js2cpp_RGraphicsSceneDrawable(RJSApi& handler, const QJSValue& v) {
          /*
          RGraphicsSceneDrawable_Wrapper* wrapper = getWrapper<RGraphicsSceneDrawable_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RGraphicsSceneDrawable: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RGraphicsSceneDrawable();
          }
          //return *(RGraphicsSceneDrawable*)wrapper->getWrappedVoid();
          RGraphicsSceneDrawable* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RGraphicsSceneDrawable: wrapped pointer is NULL";
              return RGraphicsSceneDrawable();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RGraphicsSceneDrawable: not a QObject";
              return RGraphicsSceneDrawable();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RGraphicsSceneDrawable_ptr: no wrapper";
              handler.trace();
              return RGraphicsSceneDrawable();
          }
          //RGraphicsSceneDrawable* ret = getWrapped_RGraphicsSceneDrawable(wrapper);
          RGraphicsSceneDrawable* ret = RGraphicsSceneDrawable_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RGraphicsSceneDrawable();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RGraphicsSceneDrawable(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RGraphicsSceneDrawable: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RGraphicsSceneDrawable::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RHatchData(RJSApi& handler, const RHatchData* v) {
          QJSEngine* engine = handler.getEngine();
          RHatchData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RHatchData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RHatchData object:
              ret = new RHatchData_Wrapper(handler, new RHatchData(*v), true);
          }

          // JS: new RHatchData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RHatchData");
          if (cl.isUndefined()) {
              qWarning() << "Class RHatchData is undefined. Use RHatchData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RHatchData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RHatchData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RHatchData(RJSApi& handler, const RHatchData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RHatchData object:
          RHatchData_Wrapper* ret = new RHatchData_Wrapper(handler, new RHatchData(v), true);

          // JS: new RHatchData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RHatchData");
          if (cl.isUndefined()) {
              qWarning() << "Class RHatchData is undefined. Use RHatchData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RHatchData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RHatchData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RHatchData RJSHelper_qcad::js2cpp_RHatchData(RJSApi& handler, const QJSValue& v) {
          /*
          RHatchData_Wrapper* wrapper = getWrapper<RHatchData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RHatchData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RHatchData();
          }
          //return *(RHatchData*)wrapper->getWrappedVoid();
          RHatchData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RHatchData: wrapped pointer is NULL";
              return RHatchData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RHatchData: not a QObject";
              return RHatchData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RHatchData_ptr: no wrapper";
              handler.trace();
              return RHatchData();
          }
          //RHatchData* ret = getWrapped_RHatchData(wrapper);
          RHatchData* ret = RHatchData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RHatchData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RHatchData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RHatchData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RHatchData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RImageData(RJSApi& handler, const RImageData* v) {
          QJSEngine* engine = handler.getEngine();
          RImageData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RImageData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RImageData object:
              ret = new RImageData_Wrapper(handler, new RImageData(*v), true);
          }

          // JS: new RImageData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RImageData");
          if (cl.isUndefined()) {
              qWarning() << "Class RImageData is undefined. Use RImageData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RImageData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RImageData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RImageData(RJSApi& handler, const RImageData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RImageData object:
          RImageData_Wrapper* ret = new RImageData_Wrapper(handler, new RImageData(v), true);

          // JS: new RImageData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RImageData");
          if (cl.isUndefined()) {
              qWarning() << "Class RImageData is undefined. Use RImageData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RImageData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RImageData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RImageData RJSHelper_qcad::js2cpp_RImageData(RJSApi& handler, const QJSValue& v) {
          /*
          RImageData_Wrapper* wrapper = getWrapper<RImageData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RImageData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RImageData();
          }
          //return *(RImageData*)wrapper->getWrappedVoid();
          RImageData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RImageData: wrapped pointer is NULL";
              return RImageData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RImageData: not a QObject";
              return RImageData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RImageData_ptr: no wrapper";
              handler.trace();
              return RImageData();
          }
          //RImageData* ret = getWrapped_RImageData(wrapper);
          RImageData* ret = RImageData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RImageData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RImageData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RImageData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RImageData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLeaderData(RJSApi& handler, const RLeaderData* v) {
          QJSEngine* engine = handler.getEngine();
          RLeaderData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RLeaderData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RLeaderData object:
              ret = new RLeaderData_Wrapper(handler, new RLeaderData(*v), true);
          }

          // JS: new RLeaderData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLeaderData");
          if (cl.isUndefined()) {
              qWarning() << "Class RLeaderData is undefined. Use RLeaderData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLeaderData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLeaderData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RLeaderData(RJSApi& handler, const RLeaderData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RLeaderData object:
          RLeaderData_Wrapper* ret = new RLeaderData_Wrapper(handler, new RLeaderData(v), true);

          // JS: new RLeaderData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLeaderData");
          if (cl.isUndefined()) {
              qWarning() << "Class RLeaderData is undefined. Use RLeaderData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLeaderData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLeaderData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RLeaderData RJSHelper_qcad::js2cpp_RLeaderData(RJSApi& handler, const QJSValue& v) {
          /*
          RLeaderData_Wrapper* wrapper = getWrapper<RLeaderData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLeaderData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RLeaderData();
          }
          //return *(RLeaderData*)wrapper->getWrappedVoid();
          RLeaderData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RLeaderData: wrapped pointer is NULL";
              return RLeaderData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLeaderData: not a QObject";
              return RLeaderData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLeaderData_ptr: no wrapper";
              handler.trace();
              return RLeaderData();
          }
          //RLeaderData* ret = getWrapped_RLeaderData(wrapper);
          RLeaderData* ret = RLeaderData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RLeaderData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RLeaderData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLeaderData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RLeaderData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLine(RJSApi& handler, const RLine* v) {
          QJSEngine* engine = handler.getEngine();
          RLine_Wrapper* ret;

          if (v==nullptr) {
              ret = new RLine_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RLine object:
              ret = new RLine_Wrapper(handler, new RLine(*v), true);
          }

          // JS: new RLine('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLine");
          if (cl.isUndefined()) {
              qWarning() << "Class RLine is undefined. Use RLine_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLine('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLine(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RLine(RJSApi& handler, const RLine& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RLine object:
          RLine_Wrapper* ret = new RLine_Wrapper(handler, new RLine(v), true);

          // JS: new RLine('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLine");
          if (cl.isUndefined()) {
              qWarning() << "Class RLine is undefined. Use RLine_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLine('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLine(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RLine RJSHelper_qcad::js2cpp_RLine(RJSApi& handler, const QJSValue& v) {
          /*
          RLine_Wrapper* wrapper = getWrapper<RLine_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLine: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RLine();
          }
          //return *(RLine*)wrapper->getWrappedVoid();
          RLine* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RLine: wrapped pointer is NULL";
              return RLine();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLine: not a QObject";
              return RLine();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLine_ptr: no wrapper";
              handler.trace();
              return RLine();
          }
          //RLine* ret = getWrapped_RLine(wrapper);
          RLine* ret = RLine_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RLine();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RLine(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLine: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RLine::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLineData(RJSApi& handler, const RLineData* v) {
          QJSEngine* engine = handler.getEngine();
          RLineData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RLineData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RLineData object:
              ret = new RLineData_Wrapper(handler, new RLineData(*v), true);
          }

          // JS: new RLineData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLineData");
          if (cl.isUndefined()) {
              qWarning() << "Class RLineData is undefined. Use RLineData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLineData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLineData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RLineData(RJSApi& handler, const RLineData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RLineData object:
          RLineData_Wrapper* ret = new RLineData_Wrapper(handler, new RLineData(v), true);

          // JS: new RLineData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLineData");
          if (cl.isUndefined()) {
              qWarning() << "Class RLineData is undefined. Use RLineData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLineData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLineData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RLineData RJSHelper_qcad::js2cpp_RLineData(RJSApi& handler, const QJSValue& v) {
          /*
          RLineData_Wrapper* wrapper = getWrapper<RLineData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLineData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RLineData();
          }
          //return *(RLineData*)wrapper->getWrappedVoid();
          RLineData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RLineData: wrapped pointer is NULL";
              return RLineData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLineData: not a QObject";
              return RLineData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLineData_ptr: no wrapper";
              handler.trace();
              return RLineData();
          }
          //RLineData* ret = getWrapped_RLineData(wrapper);
          RLineData* ret = RLineData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RLineData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RLineData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLineData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RLineData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLinetypePattern(RJSApi& handler, const RLinetypePattern* v) {
          QJSEngine* engine = handler.getEngine();
          RLinetypePattern_Wrapper* ret;

          if (v==nullptr) {
              ret = new RLinetypePattern_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RLinetypePattern object:
              ret = new RLinetypePattern_Wrapper(handler, new RLinetypePattern(*v), true);
          }

          // JS: new RLinetypePattern('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLinetypePattern");
          if (cl.isUndefined()) {
              qWarning() << "Class RLinetypePattern is undefined. Use RLinetypePattern_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLinetypePattern('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLinetypePattern(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RLinetypePattern(RJSApi& handler, const RLinetypePattern& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RLinetypePattern object:
          RLinetypePattern_Wrapper* ret = new RLinetypePattern_Wrapper(handler, new RLinetypePattern(v), true);

          // JS: new RLinetypePattern('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLinetypePattern");
          if (cl.isUndefined()) {
              qWarning() << "Class RLinetypePattern is undefined. Use RLinetypePattern_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLinetypePattern('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLinetypePattern(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RLinetypePattern RJSHelper_qcad::js2cpp_RLinetypePattern(RJSApi& handler, const QJSValue& v) {
          /*
          RLinetypePattern_Wrapper* wrapper = getWrapper<RLinetypePattern_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLinetypePattern: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RLinetypePattern();
          }
          //return *(RLinetypePattern*)wrapper->getWrappedVoid();
          RLinetypePattern* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RLinetypePattern: wrapped pointer is NULL";
              return RLinetypePattern();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLinetypePattern: not a QObject";
              return RLinetypePattern();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLinetypePattern_ptr: no wrapper";
              handler.trace();
              return RLinetypePattern();
          }
          //RLinetypePattern* ret = getWrapped_RLinetypePattern(wrapper);
          RLinetypePattern* ret = RLinetypePattern_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RLinetypePattern();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RLinetypePattern(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLinetypePattern: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RLinetypePattern::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RLineweight(RJSApi& handler, const RLineweight* v) {
          QJSEngine* engine = handler.getEngine();
          RLineweight_Wrapper* ret;

          if (v==nullptr) {
              ret = new RLineweight_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RLineweight object:
              ret = new RLineweight_Wrapper(handler, new RLineweight(*v), true);
          }

          // JS: new RLineweight('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLineweight");
          if (cl.isUndefined()) {
              qWarning() << "Class RLineweight is undefined. Use RLineweight_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLineweight('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLineweight(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RLineweight(RJSApi& handler, const RLineweight& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RLineweight object:
          RLineweight_Wrapper* ret = new RLineweight_Wrapper(handler, new RLineweight(v), true);

          // JS: new RLineweight('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLineweight");
          if (cl.isUndefined()) {
              qWarning() << "Class RLineweight is undefined. Use RLineweight_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLineweight('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLineweight(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RLineweight RJSHelper_qcad::js2cpp_RLineweight(RJSApi& handler, const QJSValue& v) {
          /*
          RLineweight_Wrapper* wrapper = getWrapper<RLineweight_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLineweight: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RLineweight();
          }
          //return *(RLineweight*)wrapper->getWrappedVoid();
          RLineweight* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RLineweight: wrapped pointer is NULL";
              return RLineweight();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLineweight: not a QObject";
              return RLineweight();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLineweight_ptr: no wrapper";
              handler.trace();
              return RLineweight();
          }
          //RLineweight* ret = getWrapped_RLineweight(wrapper);
          RLineweight* ret = RLineweight_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RLineweight();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RLineweight(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLineweight: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RLineweight::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RMath(RJSApi& handler, const RMath* v) {
          QJSEngine* engine = handler.getEngine();
          RMath_Wrapper* ret;

          if (v==nullptr) {
              ret = new RMath_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RMath object:
              ret = new RMath_Wrapper(handler, new RMath(*v), true);
          }

          // JS: new RMath('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMath");
          if (cl.isUndefined()) {
              qWarning() << "Class RMath is undefined. Use RMath_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMath('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMath(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RMath(RJSApi& handler, const RMath& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RMath object:
          RMath_Wrapper* ret = new RMath_Wrapper(handler, new RMath(v), true);

          // JS: new RMath('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMath");
          if (cl.isUndefined()) {
              qWarning() << "Class RMath is undefined. Use RMath_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMath('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMath(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RMath RJSHelper_qcad::js2cpp_RMath(RJSApi& handler, const QJSValue& v) {
          /*
          RMath_Wrapper* wrapper = getWrapper<RMath_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMath: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RMath();
          }
          //return *(RMath*)wrapper->getWrappedVoid();
          RMath* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RMath: wrapped pointer is NULL";
              return RMath();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RMath: not a QObject";
              return RMath();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMath_ptr: no wrapper";
              handler.trace();
              return RMath();
          }
          //RMath* ret = getWrapped_RMath(wrapper);
          RMath* ret = RMath_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RMath();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RMath(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RMath: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RMath::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RMatrix(RJSApi& handler, const RMatrix* v) {
          QJSEngine* engine = handler.getEngine();
          RMatrix_Wrapper* ret;

          if (v==nullptr) {
              ret = new RMatrix_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RMatrix object:
              ret = new RMatrix_Wrapper(handler, new RMatrix(*v), true);
          }

          // JS: new RMatrix('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMatrix");
          if (cl.isUndefined()) {
              qWarning() << "Class RMatrix is undefined. Use RMatrix_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMatrix('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMatrix(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RMatrix(RJSApi& handler, const RMatrix& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RMatrix object:
          RMatrix_Wrapper* ret = new RMatrix_Wrapper(handler, new RMatrix(v), true);

          // JS: new RMatrix('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMatrix");
          if (cl.isUndefined()) {
              qWarning() << "Class RMatrix is undefined. Use RMatrix_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMatrix('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMatrix(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RMatrix RJSHelper_qcad::js2cpp_RMatrix(RJSApi& handler, const QJSValue& v) {
          /*
          RMatrix_Wrapper* wrapper = getWrapper<RMatrix_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMatrix: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RMatrix();
          }
          //return *(RMatrix*)wrapper->getWrappedVoid();
          RMatrix* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RMatrix: wrapped pointer is NULL";
              return RMatrix();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RMatrix: not a QObject";
              return RMatrix();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMatrix_ptr: no wrapper";
              handler.trace();
              return RMatrix();
          }
          //RMatrix* ret = getWrapped_RMatrix(wrapper);
          RMatrix* ret = RMatrix_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RMatrix();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RMatrix(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RMatrix: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RMatrix::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPainterPath(RJSApi& handler, const RPainterPath* v) {
          QJSEngine* engine = handler.getEngine();
          RPainterPath_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPainterPath_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPainterPath object:
              ret = new RPainterPath_Wrapper(handler, new RPainterPath(*v), true);
          }

          // JS: new RPainterPath('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPainterPath");
          if (cl.isUndefined()) {
              qWarning() << "Class RPainterPath is undefined. Use RPainterPath_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPainterPath('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPainterPath(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPainterPath(RJSApi& handler, const RPainterPath& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPainterPath object:
          RPainterPath_Wrapper* ret = new RPainterPath_Wrapper(handler, new RPainterPath(v), true);

          // JS: new RPainterPath('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPainterPath");
          if (cl.isUndefined()) {
              qWarning() << "Class RPainterPath is undefined. Use RPainterPath_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPainterPath('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPainterPath(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPainterPath RJSHelper_qcad::js2cpp_RPainterPath(RJSApi& handler, const QJSValue& v) {
          /*
          RPainterPath_Wrapper* wrapper = getWrapper<RPainterPath_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPainterPath: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RPainterPath();
          }
          //return *(RPainterPath*)wrapper->getWrappedVoid();
          RPainterPath* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPainterPath: wrapped pointer is NULL";
              return RPainterPath();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPainterPath: not a QObject";
              return RPainterPath();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPainterPath_ptr: no wrapper";
              handler.trace();
              return RPainterPath();
          }
          //RPainterPath* ret = getWrapped_RPainterPath(wrapper);
          RPainterPath* ret = RPainterPath_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPainterPath();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPainterPath(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPainterPath: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPainterPath::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPattern(RJSApi& handler, const RPattern* v) {
          QJSEngine* engine = handler.getEngine();
          RPattern_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPattern_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPattern object:
              ret = new RPattern_Wrapper(handler, new RPattern(*v), true);
          }

          // JS: new RPattern('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPattern");
          if (cl.isUndefined()) {
              qWarning() << "Class RPattern is undefined. Use RPattern_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPattern('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPattern(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPattern(RJSApi& handler, const RPattern& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPattern object:
          RPattern_Wrapper* ret = new RPattern_Wrapper(handler, new RPattern(v), true);

          // JS: new RPattern('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPattern");
          if (cl.isUndefined()) {
              qWarning() << "Class RPattern is undefined. Use RPattern_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPattern('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPattern(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPattern RJSHelper_qcad::js2cpp_RPattern(RJSApi& handler, const QJSValue& v) {
          /*
          RPattern_Wrapper* wrapper = getWrapper<RPattern_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPattern: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RPattern();
          }
          //return *(RPattern*)wrapper->getWrappedVoid();
          RPattern* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPattern: wrapped pointer is NULL";
              return RPattern();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPattern: not a QObject";
              return RPattern();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPattern_ptr: no wrapper";
              handler.trace();
              return RPattern();
          }
          //RPattern* ret = getWrapped_RPattern(wrapper);
          RPattern* ret = RPattern_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPattern();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPattern(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPattern: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPattern::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPatternLine(RJSApi& handler, const RPatternLine* v) {
          QJSEngine* engine = handler.getEngine();
          RPatternLine_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPatternLine_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPatternLine object:
              ret = new RPatternLine_Wrapper(handler, new RPatternLine(*v), true);
          }

          // JS: new RPatternLine('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPatternLine");
          if (cl.isUndefined()) {
              qWarning() << "Class RPatternLine is undefined. Use RPatternLine_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPatternLine('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPatternLine(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPatternLine(RJSApi& handler, const RPatternLine& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPatternLine object:
          RPatternLine_Wrapper* ret = new RPatternLine_Wrapper(handler, new RPatternLine(v), true);

          // JS: new RPatternLine('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPatternLine");
          if (cl.isUndefined()) {
              qWarning() << "Class RPatternLine is undefined. Use RPatternLine_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPatternLine('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPatternLine(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPatternLine RJSHelper_qcad::js2cpp_RPatternLine(RJSApi& handler, const QJSValue& v) {
          /*
          RPatternLine_Wrapper* wrapper = getWrapper<RPatternLine_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPatternLine: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RPatternLine();
          }
          //return *(RPatternLine*)wrapper->getWrappedVoid();
          RPatternLine* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPatternLine: wrapped pointer is NULL";
              return RPatternLine();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPatternLine: not a QObject";
              return RPatternLine();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPatternLine_ptr: no wrapper";
              handler.trace();
              return RPatternLine();
          }
          //RPatternLine* ret = getWrapped_RPatternLine(wrapper);
          RPatternLine* ret = RPatternLine_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPatternLine();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPatternLine(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPatternLine: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPatternLine::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPatternList(RJSApi& handler, const RPatternList* v) {
          QJSEngine* engine = handler.getEngine();
          RPatternList_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPatternList_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPatternList object:
              ret = new RPatternList_Wrapper(handler, new RPatternList(*v), true);
          }

          // JS: new RPatternList('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPatternList");
          if (cl.isUndefined()) {
              qWarning() << "Class RPatternList is undefined. Use RPatternList_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPatternList('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPatternList(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPatternList(RJSApi& handler, const RPatternList& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPatternList object:
          RPatternList_Wrapper* ret = new RPatternList_Wrapper(handler, new RPatternList(v), true);

          // JS: new RPatternList('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPatternList");
          if (cl.isUndefined()) {
              qWarning() << "Class RPatternList is undefined. Use RPatternList_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPatternList('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPatternList(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPatternList RJSHelper_qcad::js2cpp_RPatternList(RJSApi& handler, const QJSValue& v) {
          /*
          RPatternList_Wrapper* wrapper = getWrapper<RPatternList_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPatternList: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RPatternList();
          }
          //return *(RPatternList*)wrapper->getWrappedVoid();
          RPatternList* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPatternList: wrapped pointer is NULL";
              return RPatternList();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPatternList: not a QObject";
              return RPatternList();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPatternList_ptr: no wrapper";
              handler.trace();
              return RPatternList();
          }
          //RPatternList* ret = getWrapped_RPatternList(wrapper);
          RPatternList* ret = RPatternList_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPatternList();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPatternList(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPatternList: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPatternList::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPatternListImperial(RJSApi& handler, const RPatternListImperial* v) {
          QJSEngine* engine = handler.getEngine();
          RPatternListImperial_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPatternListImperial_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPatternListImperial object:
              ret = new RPatternListImperial_Wrapper(handler, new RPatternListImperial(*v), true);
          }

          // JS: new RPatternListImperial('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPatternListImperial");
          if (cl.isUndefined()) {
              qWarning() << "Class RPatternListImperial is undefined. Use RPatternListImperial_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPatternListImperial('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPatternListImperial(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPatternListImperial(RJSApi& handler, const RPatternListImperial& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPatternListImperial object:
          RPatternListImperial_Wrapper* ret = new RPatternListImperial_Wrapper(handler, new RPatternListImperial(v), true);

          // JS: new RPatternListImperial('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPatternListImperial");
          if (cl.isUndefined()) {
              qWarning() << "Class RPatternListImperial is undefined. Use RPatternListImperial_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPatternListImperial('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPatternListImperial(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPatternListImperial RJSHelper_qcad::js2cpp_RPatternListImperial(RJSApi& handler, const QJSValue& v) {
          /*
          RPatternListImperial_Wrapper* wrapper = getWrapper<RPatternListImperial_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPatternListImperial: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RPatternListImperial();
          }
          //return *(RPatternListImperial*)wrapper->getWrappedVoid();
          RPatternListImperial* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPatternListImperial: wrapped pointer is NULL";
              return RPatternListImperial();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPatternListImperial: not a QObject";
              return RPatternListImperial();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPatternListImperial_ptr: no wrapper";
              handler.trace();
              return RPatternListImperial();
          }
          //RPatternListImperial* ret = getWrapped_RPatternListImperial(wrapper);
          RPatternListImperial* ret = RPatternListImperial_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPatternListImperial();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPatternListImperial(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPatternListImperial: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPatternListImperial::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPatternListMetric(RJSApi& handler, const RPatternListMetric* v) {
          QJSEngine* engine = handler.getEngine();
          RPatternListMetric_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPatternListMetric_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPatternListMetric object:
              ret = new RPatternListMetric_Wrapper(handler, new RPatternListMetric(*v), true);
          }

          // JS: new RPatternListMetric('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPatternListMetric");
          if (cl.isUndefined()) {
              qWarning() << "Class RPatternListMetric is undefined. Use RPatternListMetric_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPatternListMetric('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPatternListMetric(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPatternListMetric(RJSApi& handler, const RPatternListMetric& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPatternListMetric object:
          RPatternListMetric_Wrapper* ret = new RPatternListMetric_Wrapper(handler, new RPatternListMetric(v), true);

          // JS: new RPatternListMetric('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPatternListMetric");
          if (cl.isUndefined()) {
              qWarning() << "Class RPatternListMetric is undefined. Use RPatternListMetric_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPatternListMetric('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPatternListMetric(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPatternListMetric RJSHelper_qcad::js2cpp_RPatternListMetric(RJSApi& handler, const QJSValue& v) {
          /*
          RPatternListMetric_Wrapper* wrapper = getWrapper<RPatternListMetric_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPatternListMetric: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RPatternListMetric();
          }
          //return *(RPatternListMetric*)wrapper->getWrappedVoid();
          RPatternListMetric* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPatternListMetric: wrapped pointer is NULL";
              return RPatternListMetric();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPatternListMetric: not a QObject";
              return RPatternListMetric();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPatternListMetric_ptr: no wrapper";
              handler.trace();
              return RPatternListMetric();
          }
          //RPatternListMetric* ret = getWrapped_RPatternListMetric(wrapper);
          RPatternListMetric* ret = RPatternListMetric_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPatternListMetric();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPatternListMetric(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPatternListMetric: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPatternListMetric::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPluginInfo(RJSApi& handler, const RPluginInfo* v) {
          QJSEngine* engine = handler.getEngine();
          RPluginInfo_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPluginInfo_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPluginInfo object:
              ret = new RPluginInfo_Wrapper(handler, new RPluginInfo(*v), true);
          }

          // JS: new RPluginInfo('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPluginInfo");
          if (cl.isUndefined()) {
              qWarning() << "Class RPluginInfo is undefined. Use RPluginInfo_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPluginInfo('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPluginInfo(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPluginInfo(RJSApi& handler, const RPluginInfo& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPluginInfo object:
          RPluginInfo_Wrapper* ret = new RPluginInfo_Wrapper(handler, new RPluginInfo(v), true);

          // JS: new RPluginInfo('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPluginInfo");
          if (cl.isUndefined()) {
              qWarning() << "Class RPluginInfo is undefined. Use RPluginInfo_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPluginInfo('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPluginInfo(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPluginInfo RJSHelper_qcad::js2cpp_RPluginInfo(RJSApi& handler, const QJSValue& v) {
          /*
          RPluginInfo_Wrapper* wrapper = getWrapper<RPluginInfo_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPluginInfo: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RPluginInfo();
          }
          //return *(RPluginInfo*)wrapper->getWrappedVoid();
          RPluginInfo* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPluginInfo: wrapped pointer is NULL";
              return RPluginInfo();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPluginInfo: not a QObject";
              return RPluginInfo();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPluginInfo_ptr: no wrapper";
              handler.trace();
              return RPluginInfo();
          }
          //RPluginInfo* ret = getWrapped_RPluginInfo(wrapper);
          RPluginInfo* ret = RPluginInfo_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPluginInfo();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPluginInfo(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPluginInfo: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPluginInfo::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPluginLoader(RJSApi& handler, const RPluginLoader* v) {
          QJSEngine* engine = handler.getEngine();
          RPluginLoader_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPluginLoader_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPluginLoader object:
              ret = new RPluginLoader_Wrapper(handler, new RPluginLoader(*v), true);
          }

          // JS: new RPluginLoader('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPluginLoader");
          if (cl.isUndefined()) {
              qWarning() << "Class RPluginLoader is undefined. Use RPluginLoader_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPluginLoader('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPluginLoader(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPluginLoader(RJSApi& handler, const RPluginLoader& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPluginLoader object:
          RPluginLoader_Wrapper* ret = new RPluginLoader_Wrapper(handler, new RPluginLoader(v), true);

          // JS: new RPluginLoader('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPluginLoader");
          if (cl.isUndefined()) {
              qWarning() << "Class RPluginLoader is undefined. Use RPluginLoader_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPluginLoader('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPluginLoader(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPluginLoader RJSHelper_qcad::js2cpp_RPluginLoader(RJSApi& handler, const QJSValue& v) {
          /*
          RPluginLoader_Wrapper* wrapper = getWrapper<RPluginLoader_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPluginLoader: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RPluginLoader();
          }
          //return *(RPluginLoader*)wrapper->getWrappedVoid();
          RPluginLoader* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPluginLoader: wrapped pointer is NULL";
              return RPluginLoader();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPluginLoader: not a QObject";
              return RPluginLoader();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPluginLoader_ptr: no wrapper";
              handler.trace();
              return RPluginLoader();
          }
          //RPluginLoader* ret = getWrapped_RPluginLoader(wrapper);
          RPluginLoader* ret = RPluginLoader_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPluginLoader();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPluginLoader(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPluginLoader: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPluginLoader::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPoint(RJSApi& handler, const RPoint* v) {
          QJSEngine* engine = handler.getEngine();
          RPoint_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPoint_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPoint object:
              ret = new RPoint_Wrapper(handler, new RPoint(*v), true);
          }

          // JS: new RPoint('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPoint");
          if (cl.isUndefined()) {
              qWarning() << "Class RPoint is undefined. Use RPoint_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPoint('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPoint(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPoint(RJSApi& handler, const RPoint& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPoint object:
          RPoint_Wrapper* ret = new RPoint_Wrapper(handler, new RPoint(v), true);

          // JS: new RPoint('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPoint");
          if (cl.isUndefined()) {
              qWarning() << "Class RPoint is undefined. Use RPoint_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPoint('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPoint(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPoint RJSHelper_qcad::js2cpp_RPoint(RJSApi& handler, const QJSValue& v) {
          /*
          RPoint_Wrapper* wrapper = getWrapper<RPoint_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPoint: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RPoint();
          }
          //return *(RPoint*)wrapper->getWrappedVoid();
          RPoint* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPoint: wrapped pointer is NULL";
              return RPoint();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPoint: not a QObject";
              return RPoint();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPoint_ptr: no wrapper";
              handler.trace();
              return RPoint();
          }
          //RPoint* ret = getWrapped_RPoint(wrapper);
          RPoint* ret = RPoint_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPoint();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPoint(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPoint: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPoint::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPointData(RJSApi& handler, const RPointData* v) {
          QJSEngine* engine = handler.getEngine();
          RPointData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPointData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPointData object:
              ret = new RPointData_Wrapper(handler, new RPointData(*v), true);
          }

          // JS: new RPointData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPointData");
          if (cl.isUndefined()) {
              qWarning() << "Class RPointData is undefined. Use RPointData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPointData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPointData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPointData(RJSApi& handler, const RPointData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPointData object:
          RPointData_Wrapper* ret = new RPointData_Wrapper(handler, new RPointData(v), true);

          // JS: new RPointData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPointData");
          if (cl.isUndefined()) {
              qWarning() << "Class RPointData is undefined. Use RPointData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPointData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPointData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPointData RJSHelper_qcad::js2cpp_RPointData(RJSApi& handler, const QJSValue& v) {
          /*
          RPointData_Wrapper* wrapper = getWrapper<RPointData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPointData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RPointData();
          }
          //return *(RPointData*)wrapper->getWrappedVoid();
          RPointData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPointData: wrapped pointer is NULL";
              return RPointData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPointData: not a QObject";
              return RPointData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPointData_ptr: no wrapper";
              handler.trace();
              return RPointData();
          }
          //RPointData* ret = getWrapped_RPointData(wrapper);
          RPointData* ret = RPointData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPointData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPointData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPointData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPointData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPolyline(RJSApi& handler, const RPolyline* v) {
          QJSEngine* engine = handler.getEngine();
          RPolyline_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPolyline_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPolyline object:
              ret = new RPolyline_Wrapper(handler, new RPolyline(*v), true);
          }

          // JS: new RPolyline('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPolyline");
          if (cl.isUndefined()) {
              qWarning() << "Class RPolyline is undefined. Use RPolyline_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPolyline('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPolyline(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPolyline(RJSApi& handler, const RPolyline& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPolyline object:
          RPolyline_Wrapper* ret = new RPolyline_Wrapper(handler, new RPolyline(v), true);

          // JS: new RPolyline('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPolyline");
          if (cl.isUndefined()) {
              qWarning() << "Class RPolyline is undefined. Use RPolyline_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPolyline('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPolyline(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPolyline RJSHelper_qcad::js2cpp_RPolyline(RJSApi& handler, const QJSValue& v) {
          /*
          RPolyline_Wrapper* wrapper = getWrapper<RPolyline_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPolyline: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RPolyline();
          }
          //return *(RPolyline*)wrapper->getWrappedVoid();
          RPolyline* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPolyline: wrapped pointer is NULL";
              return RPolyline();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPolyline: not a QObject";
              return RPolyline();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPolyline_ptr: no wrapper";
              handler.trace();
              return RPolyline();
          }
          //RPolyline* ret = getWrapped_RPolyline(wrapper);
          RPolyline* ret = RPolyline_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPolyline();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPolyline(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPolyline: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPolyline::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPolylineData(RJSApi& handler, const RPolylineData* v) {
          QJSEngine* engine = handler.getEngine();
          RPolylineData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPolylineData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPolylineData object:
              ret = new RPolylineData_Wrapper(handler, new RPolylineData(*v), true);
          }

          // JS: new RPolylineData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPolylineData");
          if (cl.isUndefined()) {
              qWarning() << "Class RPolylineData is undefined. Use RPolylineData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPolylineData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPolylineData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPolylineData(RJSApi& handler, const RPolylineData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPolylineData object:
          RPolylineData_Wrapper* ret = new RPolylineData_Wrapper(handler, new RPolylineData(v), true);

          // JS: new RPolylineData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPolylineData");
          if (cl.isUndefined()) {
              qWarning() << "Class RPolylineData is undefined. Use RPolylineData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPolylineData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPolylineData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPolylineData RJSHelper_qcad::js2cpp_RPolylineData(RJSApi& handler, const QJSValue& v) {
          /*
          RPolylineData_Wrapper* wrapper = getWrapper<RPolylineData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPolylineData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RPolylineData();
          }
          //return *(RPolylineData*)wrapper->getWrappedVoid();
          RPolylineData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPolylineData: wrapped pointer is NULL";
              return RPolylineData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPolylineData: not a QObject";
              return RPolylineData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPolylineData_ptr: no wrapper";
              handler.trace();
              return RPolylineData();
          }
          //RPolylineData* ret = getWrapped_RPolylineData(wrapper);
          RPolylineData* ret = RPolylineData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPolylineData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPolylineData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPolylineData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPolylineData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPropertyAttributes(RJSApi& handler, const RPropertyAttributes* v) {
          QJSEngine* engine = handler.getEngine();
          RPropertyAttributes_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPropertyAttributes_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPropertyAttributes object:
              ret = new RPropertyAttributes_Wrapper(handler, new RPropertyAttributes(*v), true);
          }

          // JS: new RPropertyAttributes('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPropertyAttributes");
          if (cl.isUndefined()) {
              qWarning() << "Class RPropertyAttributes is undefined. Use RPropertyAttributes_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPropertyAttributes('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPropertyAttributes(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPropertyAttributes(RJSApi& handler, const RPropertyAttributes& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPropertyAttributes object:
          RPropertyAttributes_Wrapper* ret = new RPropertyAttributes_Wrapper(handler, new RPropertyAttributes(v), true);

          // JS: new RPropertyAttributes('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPropertyAttributes");
          if (cl.isUndefined()) {
              qWarning() << "Class RPropertyAttributes is undefined. Use RPropertyAttributes_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPropertyAttributes('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPropertyAttributes(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPropertyAttributes RJSHelper_qcad::js2cpp_RPropertyAttributes(RJSApi& handler, const QJSValue& v) {
          /*
          RPropertyAttributes_Wrapper* wrapper = getWrapper<RPropertyAttributes_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPropertyAttributes: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RPropertyAttributes();
          }
          //return *(RPropertyAttributes*)wrapper->getWrappedVoid();
          RPropertyAttributes* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPropertyAttributes: wrapped pointer is NULL";
              return RPropertyAttributes();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPropertyAttributes: not a QObject";
              return RPropertyAttributes();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPropertyAttributes_ptr: no wrapper";
              handler.trace();
              return RPropertyAttributes();
          }
          //RPropertyAttributes* ret = getWrapped_RPropertyAttributes(wrapper);
          RPropertyAttributes* ret = RPropertyAttributes_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPropertyAttributes();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPropertyAttributes(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPropertyAttributes: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPropertyAttributes::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPropertyChange(RJSApi& handler, const RPropertyChange* v) {
          QJSEngine* engine = handler.getEngine();
          RPropertyChange_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPropertyChange_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPropertyChange object:
              ret = new RPropertyChange_Wrapper(handler, new RPropertyChange(*v), true);
          }

          // JS: new RPropertyChange('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPropertyChange");
          if (cl.isUndefined()) {
              qWarning() << "Class RPropertyChange is undefined. Use RPropertyChange_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPropertyChange('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPropertyChange(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPropertyChange(RJSApi& handler, const RPropertyChange& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPropertyChange object:
          RPropertyChange_Wrapper* ret = new RPropertyChange_Wrapper(handler, new RPropertyChange(v), true);

          // JS: new RPropertyChange('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPropertyChange");
          if (cl.isUndefined()) {
              qWarning() << "Class RPropertyChange is undefined. Use RPropertyChange_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPropertyChange('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPropertyChange(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPropertyChange RJSHelper_qcad::js2cpp_RPropertyChange(RJSApi& handler, const QJSValue& v) {
          /*
          RPropertyChange_Wrapper* wrapper = getWrapper<RPropertyChange_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPropertyChange: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RPropertyChange();
          }
          //return *(RPropertyChange*)wrapper->getWrappedVoid();
          RPropertyChange* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPropertyChange: wrapped pointer is NULL";
              return RPropertyChange();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPropertyChange: not a QObject";
              return RPropertyChange();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPropertyChange_ptr: no wrapper";
              handler.trace();
              return RPropertyChange();
          }
          //RPropertyChange* ret = getWrapped_RPropertyChange(wrapper);
          RPropertyChange* ret = RPropertyChange_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPropertyChange();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPropertyChange(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPropertyChange: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPropertyChange::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RPropertyTypeId(RJSApi& handler, const RPropertyTypeId* v) {
          QJSEngine* engine = handler.getEngine();
          RPropertyTypeId_Wrapper* ret;

          if (v==nullptr) {
              ret = new RPropertyTypeId_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RPropertyTypeId object:
              ret = new RPropertyTypeId_Wrapper(handler, new RPropertyTypeId(*v), true);
          }

          // JS: new RPropertyTypeId('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPropertyTypeId");
          if (cl.isUndefined()) {
              qWarning() << "Class RPropertyTypeId is undefined. Use RPropertyTypeId_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPropertyTypeId('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPropertyTypeId(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPropertyTypeId(RJSApi& handler, const RPropertyTypeId& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RPropertyTypeId object:
          RPropertyTypeId_Wrapper* ret = new RPropertyTypeId_Wrapper(handler, new RPropertyTypeId(v), true);

          // JS: new RPropertyTypeId('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPropertyTypeId");
          if (cl.isUndefined()) {
              qWarning() << "Class RPropertyTypeId is undefined. Use RPropertyTypeId_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPropertyTypeId('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPropertyTypeId(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RPropertyTypeId RJSHelper_qcad::js2cpp_RPropertyTypeId(RJSApi& handler, const QJSValue& v) {
          /*
          RPropertyTypeId_Wrapper* wrapper = getWrapper<RPropertyTypeId_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPropertyTypeId: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RPropertyTypeId();
          }
          //return *(RPropertyTypeId*)wrapper->getWrappedVoid();
          RPropertyTypeId* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RPropertyTypeId: wrapped pointer is NULL";
              return RPropertyTypeId();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPropertyTypeId: not a QObject";
              return RPropertyTypeId();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPropertyTypeId_ptr: no wrapper";
              handler.trace();
              return RPropertyTypeId();
          }
          //RPropertyTypeId* ret = getWrapped_RPropertyTypeId(wrapper);
          RPropertyTypeId* ret = RPropertyTypeId_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RPropertyTypeId();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RPropertyTypeId(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPropertyTypeId: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RPropertyTypeId::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RRay(RJSApi& handler, const RRay* v) {
          QJSEngine* engine = handler.getEngine();
          RRay_Wrapper* ret;

          if (v==nullptr) {
              ret = new RRay_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RRay object:
              ret = new RRay_Wrapper(handler, new RRay(*v), true);
          }

          // JS: new RRay('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRay");
          if (cl.isUndefined()) {
              qWarning() << "Class RRay is undefined. Use RRay_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RRay('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RRay(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RRay(RJSApi& handler, const RRay& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RRay object:
          RRay_Wrapper* ret = new RRay_Wrapper(handler, new RRay(v), true);

          // JS: new RRay('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRay");
          if (cl.isUndefined()) {
              qWarning() << "Class RRay is undefined. Use RRay_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RRay('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RRay(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RRay RJSHelper_qcad::js2cpp_RRay(RJSApi& handler, const QJSValue& v) {
          /*
          RRay_Wrapper* wrapper = getWrapper<RRay_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RRay: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RRay();
          }
          //return *(RRay*)wrapper->getWrappedVoid();
          RRay* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RRay: wrapped pointer is NULL";
              return RRay();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RRay: not a QObject";
              return RRay();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RRay_ptr: no wrapper";
              handler.trace();
              return RRay();
          }
          //RRay* ret = getWrapped_RRay(wrapper);
          RRay* ret = RRay_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RRay();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RRay(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RRay: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RRay::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RRayData(RJSApi& handler, const RRayData* v) {
          QJSEngine* engine = handler.getEngine();
          RRayData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RRayData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RRayData object:
              ret = new RRayData_Wrapper(handler, new RRayData(*v), true);
          }

          // JS: new RRayData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRayData");
          if (cl.isUndefined()) {
              qWarning() << "Class RRayData is undefined. Use RRayData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RRayData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RRayData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RRayData(RJSApi& handler, const RRayData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RRayData object:
          RRayData_Wrapper* ret = new RRayData_Wrapper(handler, new RRayData(v), true);

          // JS: new RRayData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRayData");
          if (cl.isUndefined()) {
              qWarning() << "Class RRayData is undefined. Use RRayData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RRayData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RRayData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RRayData RJSHelper_qcad::js2cpp_RRayData(RJSApi& handler, const QJSValue& v) {
          /*
          RRayData_Wrapper* wrapper = getWrapper<RRayData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RRayData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RRayData();
          }
          //return *(RRayData*)wrapper->getWrappedVoid();
          RRayData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RRayData: wrapped pointer is NULL";
              return RRayData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RRayData: not a QObject";
              return RRayData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RRayData_ptr: no wrapper";
              handler.trace();
              return RRayData();
          }
          //RRayData* ret = getWrapped_RRayData(wrapper);
          RRayData* ret = RRayData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RRayData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RRayData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RRayData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RRayData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RRefPoint(RJSApi& handler, const RRefPoint* v) {
          QJSEngine* engine = handler.getEngine();
          RRefPoint_Wrapper* ret;

          if (v==nullptr) {
              ret = new RRefPoint_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RRefPoint object:
              ret = new RRefPoint_Wrapper(handler, new RRefPoint(*v), true);
          }

          // JS: new RRefPoint('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRefPoint");
          if (cl.isUndefined()) {
              qWarning() << "Class RRefPoint is undefined. Use RRefPoint_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RRefPoint('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RRefPoint(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RRefPoint(RJSApi& handler, const RRefPoint& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RRefPoint object:
          RRefPoint_Wrapper* ret = new RRefPoint_Wrapper(handler, new RRefPoint(v), true);

          // JS: new RRefPoint('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRefPoint");
          if (cl.isUndefined()) {
              qWarning() << "Class RRefPoint is undefined. Use RRefPoint_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RRefPoint('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RRefPoint(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RRefPoint RJSHelper_qcad::js2cpp_RRefPoint(RJSApi& handler, const QJSValue& v) {
          /*
          RRefPoint_Wrapper* wrapper = getWrapper<RRefPoint_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RRefPoint: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RRefPoint();
          }
          //return *(RRefPoint*)wrapper->getWrappedVoid();
          RRefPoint* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RRefPoint: wrapped pointer is NULL";
              return RRefPoint();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RRefPoint: not a QObject";
              return RRefPoint();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RRefPoint_ptr: no wrapper";
              handler.trace();
              return RRefPoint();
          }
          //RRefPoint* ret = getWrapped_RRefPoint(wrapper);
          RRefPoint* ret = RRefPoint_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RRefPoint();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RRefPoint(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RRefPoint: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RRefPoint::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RS(RJSApi& handler, const RS* v) {
          QJSEngine* engine = handler.getEngine();
          RS_Wrapper* ret;

          if (v==nullptr) {
              ret = new RS_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RS object:
              ret = new RS_Wrapper(handler, new RS(*v), true);
          }

          // JS: new RS('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RS");
          if (cl.isUndefined()) {
              qWarning() << "Class RS is undefined. Use RS_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RS('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RS(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RS(RJSApi& handler, const RS& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RS object:
          RS_Wrapper* ret = new RS_Wrapper(handler, new RS(v), true);

          // JS: new RS('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RS");
          if (cl.isUndefined()) {
              qWarning() << "Class RS is undefined. Use RS_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RS('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RS(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RS RJSHelper_qcad::js2cpp_RS(RJSApi& handler, const QJSValue& v) {
          /*
          RS_Wrapper* wrapper = getWrapper<RS_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RS: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RS();
          }
          //return *(RS*)wrapper->getWrappedVoid();
          RS* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RS: wrapped pointer is NULL";
              return RS();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RS: not a QObject";
              return RS();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RS_ptr: no wrapper";
              handler.trace();
              return RS();
          }
          //RS* ret = getWrapped_RS(wrapper);
          RS* ret = RS_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RS();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RS(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RS: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RS::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSettings(RJSApi& handler, const RSettings* v) {
          QJSEngine* engine = handler.getEngine();
          RSettings_Wrapper* ret;

          if (v==nullptr) {
              ret = new RSettings_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RSettings object:
              ret = new RSettings_Wrapper(handler, new RSettings(*v), true);
          }

          // JS: new RSettings('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSettings");
          if (cl.isUndefined()) {
              qWarning() << "Class RSettings is undefined. Use RSettings_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSettings('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSettings(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RSettings(RJSApi& handler, const RSettings& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RSettings object:
          RSettings_Wrapper* ret = new RSettings_Wrapper(handler, new RSettings(v), true);

          // JS: new RSettings('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSettings");
          if (cl.isUndefined()) {
              qWarning() << "Class RSettings is undefined. Use RSettings_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSettings('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSettings(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RSettings RJSHelper_qcad::js2cpp_RSettings(RJSApi& handler, const QJSValue& v) {
          /*
          RSettings_Wrapper* wrapper = getWrapper<RSettings_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSettings: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RSettings();
          }
          //return *(RSettings*)wrapper->getWrappedVoid();
          RSettings* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RSettings: wrapped pointer is NULL";
              return RSettings();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSettings: not a QObject";
              return RSettings();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSettings_ptr: no wrapper";
              handler.trace();
              return RSettings();
          }
          //RSettings* ret = getWrapped_RSettings(wrapper);
          RSettings* ret = RSettings_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RSettings();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RSettings(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSettings: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RSettings::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSolidData(RJSApi& handler, const RSolidData* v) {
          QJSEngine* engine = handler.getEngine();
          RSolidData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RSolidData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RSolidData object:
              ret = new RSolidData_Wrapper(handler, new RSolidData(*v), true);
          }

          // JS: new RSolidData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSolidData");
          if (cl.isUndefined()) {
              qWarning() << "Class RSolidData is undefined. Use RSolidData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSolidData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSolidData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RSolidData(RJSApi& handler, const RSolidData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RSolidData object:
          RSolidData_Wrapper* ret = new RSolidData_Wrapper(handler, new RSolidData(v), true);

          // JS: new RSolidData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSolidData");
          if (cl.isUndefined()) {
              qWarning() << "Class RSolidData is undefined. Use RSolidData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSolidData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSolidData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RSolidData RJSHelper_qcad::js2cpp_RSolidData(RJSApi& handler, const QJSValue& v) {
          /*
          RSolidData_Wrapper* wrapper = getWrapper<RSolidData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSolidData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RSolidData();
          }
          //return *(RSolidData*)wrapper->getWrappedVoid();
          RSolidData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RSolidData: wrapped pointer is NULL";
              return RSolidData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSolidData: not a QObject";
              return RSolidData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSolidData_ptr: no wrapper";
              handler.trace();
              return RSolidData();
          }
          //RSolidData* ret = getWrapped_RSolidData(wrapper);
          RSolidData* ret = RSolidData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RSolidData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RSolidData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSolidData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RSolidData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSpatialIndexNavel(RJSApi& handler, const RSpatialIndexNavel* v) {
          QJSEngine* engine = handler.getEngine();
          RSpatialIndexNavel_Wrapper* ret;

          if (v==nullptr) {
              ret = new RSpatialIndexNavel_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RSpatialIndexNavel object:
              ret = new RSpatialIndexNavel_Wrapper(handler, new RSpatialIndexNavel(*v), true);
          }

          // JS: new RSpatialIndexNavel('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSpatialIndexNavel");
          if (cl.isUndefined()) {
              qWarning() << "Class RSpatialIndexNavel is undefined. Use RSpatialIndexNavel_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSpatialIndexNavel('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSpatialIndexNavel(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RSpatialIndexNavel(RJSApi& handler, const RSpatialIndexNavel& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RSpatialIndexNavel object:
          RSpatialIndexNavel_Wrapper* ret = new RSpatialIndexNavel_Wrapper(handler, new RSpatialIndexNavel(v), true);

          // JS: new RSpatialIndexNavel('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSpatialIndexNavel");
          if (cl.isUndefined()) {
              qWarning() << "Class RSpatialIndexNavel is undefined. Use RSpatialIndexNavel_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSpatialIndexNavel('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSpatialIndexNavel(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RSpatialIndexNavel RJSHelper_qcad::js2cpp_RSpatialIndexNavel(RJSApi& handler, const QJSValue& v) {
          /*
          RSpatialIndexNavel_Wrapper* wrapper = getWrapper<RSpatialIndexNavel_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSpatialIndexNavel: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RSpatialIndexNavel();
          }
          //return *(RSpatialIndexNavel*)wrapper->getWrappedVoid();
          RSpatialIndexNavel* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RSpatialIndexNavel: wrapped pointer is NULL";
              return RSpatialIndexNavel();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSpatialIndexNavel: not a QObject";
              return RSpatialIndexNavel();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSpatialIndexNavel_ptr: no wrapper";
              handler.trace();
              return RSpatialIndexNavel();
          }
          //RSpatialIndexNavel* ret = getWrapped_RSpatialIndexNavel(wrapper);
          RSpatialIndexNavel* ret = RSpatialIndexNavel_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RSpatialIndexNavel();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RSpatialIndexNavel(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSpatialIndexNavel: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RSpatialIndexNavel::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSpatialIndexVisitorAdapter(RJSApi& handler, const RSpatialIndexVisitorAdapter* v) {
          QJSEngine* engine = handler.getEngine();
          RSpatialIndexVisitorAdapter_Wrapper* ret;

          if (v==nullptr) {
              ret = new RSpatialIndexVisitorAdapter_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RSpatialIndexVisitorAdapter object:
              ret = new RSpatialIndexVisitorAdapter_Wrapper(handler, new RSpatialIndexVisitorAdapter(*v), true);
          }

          // JS: new RSpatialIndexVisitorAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSpatialIndexVisitorAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RSpatialIndexVisitorAdapter is undefined. Use RSpatialIndexVisitorAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSpatialIndexVisitorAdapter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSpatialIndexVisitorAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RSpatialIndexVisitorAdapter(RJSApi& handler, const RSpatialIndexVisitorAdapter& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RSpatialIndexVisitorAdapter object:
          RSpatialIndexVisitorAdapter_Wrapper* ret = new RSpatialIndexVisitorAdapter_Wrapper(handler, new RSpatialIndexVisitorAdapter(v), true);

          // JS: new RSpatialIndexVisitorAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSpatialIndexVisitorAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RSpatialIndexVisitorAdapter is undefined. Use RSpatialIndexVisitorAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSpatialIndexVisitorAdapter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSpatialIndexVisitorAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RSpatialIndexVisitorAdapter RJSHelper_qcad::js2cpp_RSpatialIndexVisitorAdapter(RJSApi& handler, const QJSValue& v) {
          /*
          RSpatialIndexVisitorAdapter_Wrapper* wrapper = getWrapper<RSpatialIndexVisitorAdapter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSpatialIndexVisitorAdapter: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RSpatialIndexVisitorAdapter();
          }
          //return *(RSpatialIndexVisitorAdapter*)wrapper->getWrappedVoid();
          RSpatialIndexVisitorAdapter* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RSpatialIndexVisitorAdapter: wrapped pointer is NULL";
              return RSpatialIndexVisitorAdapter();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSpatialIndexVisitorAdapter: not a QObject";
              return RSpatialIndexVisitorAdapter();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSpatialIndexVisitorAdapter_ptr: no wrapper";
              handler.trace();
              return RSpatialIndexVisitorAdapter();
          }
          //RSpatialIndexVisitorAdapter* ret = getWrapped_RSpatialIndexVisitorAdapter(wrapper);
          RSpatialIndexVisitorAdapter* ret = RSpatialIndexVisitorAdapter_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RSpatialIndexVisitorAdapter();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RSpatialIndexVisitorAdapter(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSpatialIndexVisitorAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RSpatialIndexVisitorAdapter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSpline(RJSApi& handler, const RSpline* v) {
          QJSEngine* engine = handler.getEngine();
          RSpline_Wrapper* ret;

          if (v==nullptr) {
              ret = new RSpline_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RSpline object:
              ret = new RSpline_Wrapper(handler, new RSpline(*v), true);
          }

          // JS: new RSpline('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSpline");
          if (cl.isUndefined()) {
              qWarning() << "Class RSpline is undefined. Use RSpline_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSpline('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSpline(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RSpline(RJSApi& handler, const RSpline& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RSpline object:
          RSpline_Wrapper* ret = new RSpline_Wrapper(handler, new RSpline(v), true);

          // JS: new RSpline('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSpline");
          if (cl.isUndefined()) {
              qWarning() << "Class RSpline is undefined. Use RSpline_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSpline('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSpline(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RSpline RJSHelper_qcad::js2cpp_RSpline(RJSApi& handler, const QJSValue& v) {
          /*
          RSpline_Wrapper* wrapper = getWrapper<RSpline_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSpline: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RSpline();
          }
          //return *(RSpline*)wrapper->getWrappedVoid();
          RSpline* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RSpline: wrapped pointer is NULL";
              return RSpline();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSpline: not a QObject";
              return RSpline();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSpline_ptr: no wrapper";
              handler.trace();
              return RSpline();
          }
          //RSpline* ret = getWrapped_RSpline(wrapper);
          RSpline* ret = RSpline_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RSpline();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RSpline(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSpline: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RSpline::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RSplineData(RJSApi& handler, const RSplineData* v) {
          QJSEngine* engine = handler.getEngine();
          RSplineData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RSplineData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RSplineData object:
              ret = new RSplineData_Wrapper(handler, new RSplineData(*v), true);
          }

          // JS: new RSplineData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSplineData");
          if (cl.isUndefined()) {
              qWarning() << "Class RSplineData is undefined. Use RSplineData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSplineData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSplineData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RSplineData(RJSApi& handler, const RSplineData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RSplineData object:
          RSplineData_Wrapper* ret = new RSplineData_Wrapper(handler, new RSplineData(v), true);

          // JS: new RSplineData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSplineData");
          if (cl.isUndefined()) {
              qWarning() << "Class RSplineData is undefined. Use RSplineData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSplineData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSplineData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RSplineData RJSHelper_qcad::js2cpp_RSplineData(RJSApi& handler, const QJSValue& v) {
          /*
          RSplineData_Wrapper* wrapper = getWrapper<RSplineData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSplineData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RSplineData();
          }
          //return *(RSplineData*)wrapper->getWrappedVoid();
          RSplineData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RSplineData: wrapped pointer is NULL";
              return RSplineData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSplineData: not a QObject";
              return RSplineData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSplineData_ptr: no wrapper";
              handler.trace();
              return RSplineData();
          }
          //RSplineData* ret = getWrapped_RSplineData(wrapper);
          RSplineData* ret = RSplineData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RSplineData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RSplineData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSplineData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RSplineData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RStemmer(RJSApi& handler, const RStemmer* v) {
          QJSEngine* engine = handler.getEngine();
          RStemmer_Wrapper* ret;

          if (v==nullptr) {
              ret = new RStemmer_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RStemmer object:
              ret = new RStemmer_Wrapper(handler, new RStemmer(*v), true);
          }

          // JS: new RStemmer('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RStemmer");
          if (cl.isUndefined()) {
              qWarning() << "Class RStemmer is undefined. Use RStemmer_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RStemmer('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RStemmer(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RStemmer(RJSApi& handler, const RStemmer& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RStemmer object:
          RStemmer_Wrapper* ret = new RStemmer_Wrapper(handler, new RStemmer(v), true);

          // JS: new RStemmer('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RStemmer");
          if (cl.isUndefined()) {
              qWarning() << "Class RStemmer is undefined. Use RStemmer_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RStemmer('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RStemmer(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RStemmer RJSHelper_qcad::js2cpp_RStemmer(RJSApi& handler, const QJSValue& v) {
          /*
          RStemmer_Wrapper* wrapper = getWrapper<RStemmer_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RStemmer: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RStemmer();
          }
          //return *(RStemmer*)wrapper->getWrappedVoid();
          RStemmer* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RStemmer: wrapped pointer is NULL";
              return RStemmer();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RStemmer: not a QObject";
              return RStemmer();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RStemmer_ptr: no wrapper";
              handler.trace();
              return RStemmer();
          }
          //RStemmer* ret = getWrapped_RStemmer(wrapper);
          RStemmer* ret = RStemmer_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RStemmer();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RStemmer(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RStemmer: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RStemmer::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTextBasedData(RJSApi& handler, const RTextBasedData* v) {
          QJSEngine* engine = handler.getEngine();
          RTextBasedData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RTextBasedData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RTextBasedData object:
              ret = new RTextBasedData_Wrapper(handler, new RTextBasedData(*v), true);
          }

          // JS: new RTextBasedData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTextBasedData");
          if (cl.isUndefined()) {
              qWarning() << "Class RTextBasedData is undefined. Use RTextBasedData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTextBasedData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTextBasedData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RTextBasedData(RJSApi& handler, const RTextBasedData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RTextBasedData object:
          RTextBasedData_Wrapper* ret = new RTextBasedData_Wrapper(handler, new RTextBasedData(v), true);

          // JS: new RTextBasedData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTextBasedData");
          if (cl.isUndefined()) {
              qWarning() << "Class RTextBasedData is undefined. Use RTextBasedData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTextBasedData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTextBasedData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RTextBasedData RJSHelper_qcad::js2cpp_RTextBasedData(RJSApi& handler, const QJSValue& v) {
          /*
          RTextBasedData_Wrapper* wrapper = getWrapper<RTextBasedData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTextBasedData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RTextBasedData();
          }
          //return *(RTextBasedData*)wrapper->getWrappedVoid();
          RTextBasedData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RTextBasedData: wrapped pointer is NULL";
              return RTextBasedData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTextBasedData: not a QObject";
              return RTextBasedData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTextBasedData_ptr: no wrapper";
              handler.trace();
              return RTextBasedData();
          }
          //RTextBasedData* ret = getWrapped_RTextBasedData(wrapper);
          RTextBasedData* ret = RTextBasedData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RTextBasedData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RTextBasedData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTextBasedData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RTextBasedData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTextData(RJSApi& handler, const RTextData* v) {
          QJSEngine* engine = handler.getEngine();
          RTextData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RTextData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RTextData object:
              ret = new RTextData_Wrapper(handler, new RTextData(*v), true);
          }

          // JS: new RTextData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTextData");
          if (cl.isUndefined()) {
              qWarning() << "Class RTextData is undefined. Use RTextData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTextData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTextData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RTextData(RJSApi& handler, const RTextData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RTextData object:
          RTextData_Wrapper* ret = new RTextData_Wrapper(handler, new RTextData(v), true);

          // JS: new RTextData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTextData");
          if (cl.isUndefined()) {
              qWarning() << "Class RTextData is undefined. Use RTextData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTextData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTextData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RTextData RJSHelper_qcad::js2cpp_RTextData(RJSApi& handler, const QJSValue& v) {
          /*
          RTextData_Wrapper* wrapper = getWrapper<RTextData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTextData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RTextData();
          }
          //return *(RTextData*)wrapper->getWrappedVoid();
          RTextData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RTextData: wrapped pointer is NULL";
              return RTextData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTextData: not a QObject";
              return RTextData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTextData_ptr: no wrapper";
              handler.trace();
              return RTextData();
          }
          //RTextData* ret = getWrapped_RTextData(wrapper);
          RTextData* ret = RTextData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RTextData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RTextData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTextData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RTextData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTextLabel(RJSApi& handler, const RTextLabel* v) {
          QJSEngine* engine = handler.getEngine();
          RTextLabel_Wrapper* ret;

          if (v==nullptr) {
              ret = new RTextLabel_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RTextLabel object:
              ret = new RTextLabel_Wrapper(handler, new RTextLabel(*v), true);
          }

          // JS: new RTextLabel('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTextLabel");
          if (cl.isUndefined()) {
              qWarning() << "Class RTextLabel is undefined. Use RTextLabel_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTextLabel('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTextLabel(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RTextLabel(RJSApi& handler, const RTextLabel& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RTextLabel object:
          RTextLabel_Wrapper* ret = new RTextLabel_Wrapper(handler, new RTextLabel(v), true);

          // JS: new RTextLabel('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTextLabel");
          if (cl.isUndefined()) {
              qWarning() << "Class RTextLabel is undefined. Use RTextLabel_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTextLabel('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTextLabel(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RTextLabel RJSHelper_qcad::js2cpp_RTextLabel(RJSApi& handler, const QJSValue& v) {
          /*
          RTextLabel_Wrapper* wrapper = getWrapper<RTextLabel_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTextLabel: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RTextLabel();
          }
          //return *(RTextLabel*)wrapper->getWrappedVoid();
          RTextLabel* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RTextLabel: wrapped pointer is NULL";
              return RTextLabel();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTextLabel: not a QObject";
              return RTextLabel();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTextLabel_ptr: no wrapper";
              handler.trace();
              return RTextLabel();
          }
          //RTextLabel* ret = getWrapped_RTextLabel(wrapper);
          RTextLabel* ret = RTextLabel_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RTextLabel();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RTextLabel(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTextLabel: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RTextLabel::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTextLayout(RJSApi& handler, const RTextLayout* v) {
          QJSEngine* engine = handler.getEngine();
          RTextLayout_Wrapper* ret;

          if (v==nullptr) {
              ret = new RTextLayout_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RTextLayout object:
              ret = new RTextLayout_Wrapper(handler, new RTextLayout(*v), true);
          }

          // JS: new RTextLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTextLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class RTextLayout is undefined. Use RTextLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTextLayout('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTextLayout(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RTextLayout(RJSApi& handler, const RTextLayout& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RTextLayout object:
          RTextLayout_Wrapper* ret = new RTextLayout_Wrapper(handler, new RTextLayout(v), true);

          // JS: new RTextLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTextLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class RTextLayout is undefined. Use RTextLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTextLayout('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTextLayout(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RTextLayout RJSHelper_qcad::js2cpp_RTextLayout(RJSApi& handler, const QJSValue& v) {
          /*
          RTextLayout_Wrapper* wrapper = getWrapper<RTextLayout_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTextLayout: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RTextLayout();
          }
          //return *(RTextLayout*)wrapper->getWrappedVoid();
          RTextLayout* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RTextLayout: wrapped pointer is NULL";
              return RTextLayout();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTextLayout: not a QObject";
              return RTextLayout();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTextLayout_ptr: no wrapper";
              handler.trace();
              return RTextLayout();
          }
          //RTextLayout* ret = getWrapped_RTextLayout(wrapper);
          RTextLayout* ret = RTextLayout_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RTextLayout();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RTextLayout(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTextLayout: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RTextLayout::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RToleranceData(RJSApi& handler, const RToleranceData* v) {
          QJSEngine* engine = handler.getEngine();
          RToleranceData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RToleranceData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RToleranceData object:
              ret = new RToleranceData_Wrapper(handler, new RToleranceData(*v), true);
          }

          // JS: new RToleranceData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RToleranceData");
          if (cl.isUndefined()) {
              qWarning() << "Class RToleranceData is undefined. Use RToleranceData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RToleranceData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RToleranceData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RToleranceData(RJSApi& handler, const RToleranceData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RToleranceData object:
          RToleranceData_Wrapper* ret = new RToleranceData_Wrapper(handler, new RToleranceData(v), true);

          // JS: new RToleranceData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RToleranceData");
          if (cl.isUndefined()) {
              qWarning() << "Class RToleranceData is undefined. Use RToleranceData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RToleranceData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RToleranceData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RToleranceData RJSHelper_qcad::js2cpp_RToleranceData(RJSApi& handler, const QJSValue& v) {
          /*
          RToleranceData_Wrapper* wrapper = getWrapper<RToleranceData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RToleranceData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RToleranceData();
          }
          //return *(RToleranceData*)wrapper->getWrappedVoid();
          RToleranceData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RToleranceData: wrapped pointer is NULL";
              return RToleranceData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RToleranceData: not a QObject";
              return RToleranceData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RToleranceData_ptr: no wrapper";
              handler.trace();
              return RToleranceData();
          }
          //RToleranceData* ret = getWrapped_RToleranceData(wrapper);
          RToleranceData* ret = RToleranceData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RToleranceData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RToleranceData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RToleranceData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RToleranceData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTraceData(RJSApi& handler, const RTraceData* v) {
          QJSEngine* engine = handler.getEngine();
          RTraceData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RTraceData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RTraceData object:
              ret = new RTraceData_Wrapper(handler, new RTraceData(*v), true);
          }

          // JS: new RTraceData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTraceData");
          if (cl.isUndefined()) {
              qWarning() << "Class RTraceData is undefined. Use RTraceData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTraceData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTraceData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RTraceData(RJSApi& handler, const RTraceData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RTraceData object:
          RTraceData_Wrapper* ret = new RTraceData_Wrapper(handler, new RTraceData(v), true);

          // JS: new RTraceData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTraceData");
          if (cl.isUndefined()) {
              qWarning() << "Class RTraceData is undefined. Use RTraceData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTraceData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTraceData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RTraceData RJSHelper_qcad::js2cpp_RTraceData(RJSApi& handler, const QJSValue& v) {
          /*
          RTraceData_Wrapper* wrapper = getWrapper<RTraceData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTraceData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RTraceData();
          }
          //return *(RTraceData*)wrapper->getWrappedVoid();
          RTraceData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RTraceData: wrapped pointer is NULL";
              return RTraceData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTraceData: not a QObject";
              return RTraceData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTraceData_ptr: no wrapper";
              handler.trace();
              return RTraceData();
          }
          //RTraceData* ret = getWrapped_RTraceData(wrapper);
          RTraceData* ret = RTraceData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RTraceData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RTraceData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTraceData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RTraceData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTransaction(RJSApi& handler, const RTransaction* v) {
          QJSEngine* engine = handler.getEngine();
          RTransaction_Wrapper* ret;

          if (v==nullptr) {
              ret = new RTransaction_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RTransaction object:
              ret = new RTransaction_Wrapper(handler, new RTransaction(*v), true);
          }

          // JS: new RTransaction('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTransaction");
          if (cl.isUndefined()) {
              qWarning() << "Class RTransaction is undefined. Use RTransaction_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTransaction('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTransaction(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RTransaction(RJSApi& handler, const RTransaction& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RTransaction object:
          RTransaction_Wrapper* ret = new RTransaction_Wrapper(handler, new RTransaction(v), true);

          // JS: new RTransaction('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTransaction");
          if (cl.isUndefined()) {
              qWarning() << "Class RTransaction is undefined. Use RTransaction_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTransaction('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTransaction(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RTransaction RJSHelper_qcad::js2cpp_RTransaction(RJSApi& handler, const QJSValue& v) {
          /*
          RTransaction_Wrapper* wrapper = getWrapper<RTransaction_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTransaction: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RTransaction();
          }
          //return *(RTransaction*)wrapper->getWrappedVoid();
          RTransaction* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RTransaction: wrapped pointer is NULL";
              return RTransaction();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTransaction: not a QObject";
              return RTransaction();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTransaction_ptr: no wrapper";
              handler.trace();
              return RTransaction();
          }
          //RTransaction* ret = getWrapped_RTransaction(wrapper);
          RTransaction* ret = RTransaction_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RTransaction();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RTransaction(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTransaction: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RTransaction::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTransform(RJSApi& handler, const RTransform* v) {
          QJSEngine* engine = handler.getEngine();
          RTransform_Wrapper* ret;

          if (v==nullptr) {
              ret = new RTransform_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RTransform object:
              ret = new RTransform_Wrapper(handler, new RTransform(*v), true);
          }

          // JS: new RTransform('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTransform");
          if (cl.isUndefined()) {
              qWarning() << "Class RTransform is undefined. Use RTransform_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTransform('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTransform(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RTransform(RJSApi& handler, const RTransform& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RTransform object:
          RTransform_Wrapper* ret = new RTransform_Wrapper(handler, new RTransform(v), true);

          // JS: new RTransform('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTransform");
          if (cl.isUndefined()) {
              qWarning() << "Class RTransform is undefined. Use RTransform_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTransform('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTransform(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RTransform RJSHelper_qcad::js2cpp_RTransform(RJSApi& handler, const QJSValue& v) {
          /*
          RTransform_Wrapper* wrapper = getWrapper<RTransform_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTransform: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RTransform();
          }
          //return *(RTransform*)wrapper->getWrappedVoid();
          RTransform* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RTransform: wrapped pointer is NULL";
              return RTransform();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTransform: not a QObject";
              return RTransform();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTransform_ptr: no wrapper";
              handler.trace();
              return RTransform();
          }
          //RTransform* ret = getWrapped_RTransform(wrapper);
          RTransform* ret = RTransform_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RTransform();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RTransform(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTransform: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RTransform::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTransformOp(RJSApi& handler, const RTransformOp* v) {
          QJSEngine* engine = handler.getEngine();
          RTransformOp_Wrapper* ret;

          if (v==nullptr) {
              ret = new RTransformOp_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RTransformOp object:
              ret = new RTransformOp_Wrapper(handler, new RTransformOp(*v), true);
          }

          // JS: new RTransformOp('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTransformOp");
          if (cl.isUndefined()) {
              qWarning() << "Class RTransformOp is undefined. Use RTransformOp_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTransformOp('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTransformOp(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RTransformOp(RJSApi& handler, const RTransformOp& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RTransformOp object:
          RTransformOp_Wrapper* ret = new RTransformOp_Wrapper(handler, new RTransformOp(v), true);

          // JS: new RTransformOp('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTransformOp");
          if (cl.isUndefined()) {
              qWarning() << "Class RTransformOp is undefined. Use RTransformOp_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTransformOp('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTransformOp(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RTransformOp RJSHelper_qcad::js2cpp_RTransformOp(RJSApi& handler, const QJSValue& v) {
          /*
          RTransformOp_Wrapper* wrapper = getWrapper<RTransformOp_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTransformOp: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RTransformOp();
          }
          //return *(RTransformOp*)wrapper->getWrappedVoid();
          RTransformOp* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RTransformOp: wrapped pointer is NULL";
              return RTransformOp();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTransformOp: not a QObject";
              return RTransformOp();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTransformOp_ptr: no wrapper";
              handler.trace();
              return RTransformOp();
          }
          //RTransformOp* ret = getWrapped_RTransformOp(wrapper);
          RTransformOp* ret = RTransformOp_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RTransformOp();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RTransformOp(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTransformOp: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RTransformOp::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RTriangle(RJSApi& handler, const RTriangle* v) {
          QJSEngine* engine = handler.getEngine();
          RTriangle_Wrapper* ret;

          if (v==nullptr) {
              ret = new RTriangle_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RTriangle object:
              ret = new RTriangle_Wrapper(handler, new RTriangle(*v), true);
          }

          // JS: new RTriangle('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTriangle");
          if (cl.isUndefined()) {
              qWarning() << "Class RTriangle is undefined. Use RTriangle_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTriangle('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTriangle(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RTriangle(RJSApi& handler, const RTriangle& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RTriangle object:
          RTriangle_Wrapper* ret = new RTriangle_Wrapper(handler, new RTriangle(v), true);

          // JS: new RTriangle('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTriangle");
          if (cl.isUndefined()) {
              qWarning() << "Class RTriangle is undefined. Use RTriangle_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTriangle('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTriangle(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RTriangle RJSHelper_qcad::js2cpp_RTriangle(RJSApi& handler, const QJSValue& v) {
          /*
          RTriangle_Wrapper* wrapper = getWrapper<RTriangle_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTriangle: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RTriangle();
          }
          //return *(RTriangle*)wrapper->getWrappedVoid();
          RTriangle* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RTriangle: wrapped pointer is NULL";
              return RTriangle();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTriangle: not a QObject";
              return RTriangle();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTriangle_ptr: no wrapper";
              handler.trace();
              return RTriangle();
          }
          //RTriangle* ret = getWrapped_RTriangle(wrapper);
          RTriangle* ret = RTriangle_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RTriangle();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RTriangle(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTriangle: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RTriangle::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RUnit(RJSApi& handler, const RUnit* v) {
          QJSEngine* engine = handler.getEngine();
          RUnit_Wrapper* ret;

          if (v==nullptr) {
              ret = new RUnit_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RUnit object:
              ret = new RUnit_Wrapper(handler, new RUnit(*v), true);
          }

          // JS: new RUnit('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RUnit");
          if (cl.isUndefined()) {
              qWarning() << "Class RUnit is undefined. Use RUnit_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RUnit('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RUnit(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RUnit(RJSApi& handler, const RUnit& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RUnit object:
          RUnit_Wrapper* ret = new RUnit_Wrapper(handler, new RUnit(v), true);

          // JS: new RUnit('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RUnit");
          if (cl.isUndefined()) {
              qWarning() << "Class RUnit is undefined. Use RUnit_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RUnit('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RUnit(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RUnit RJSHelper_qcad::js2cpp_RUnit(RJSApi& handler, const QJSValue& v) {
          /*
          RUnit_Wrapper* wrapper = getWrapper<RUnit_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RUnit: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RUnit();
          }
          //return *(RUnit*)wrapper->getWrappedVoid();
          RUnit* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RUnit: wrapped pointer is NULL";
              return RUnit();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RUnit: not a QObject";
              return RUnit();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RUnit_ptr: no wrapper";
              handler.trace();
              return RUnit();
          }
          //RUnit* ret = getWrapped_RUnit(wrapper);
          RUnit* ret = RUnit_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RUnit();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RUnit(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RUnit: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RUnit::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RViewFocusListenerAdapter(RJSApi& handler, const RViewFocusListenerAdapter* v) {
          QJSEngine* engine = handler.getEngine();
          RViewFocusListenerAdapter_Wrapper* ret;

          if (v==nullptr) {
              ret = new RViewFocusListenerAdapter_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RViewFocusListenerAdapter object:
              ret = new RViewFocusListenerAdapter_Wrapper(handler, new RViewFocusListenerAdapter(*v), true);
          }

          // JS: new RViewFocusListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RViewFocusListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RViewFocusListenerAdapter is undefined. Use RViewFocusListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RViewFocusListenerAdapter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RViewFocusListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RViewFocusListenerAdapter(RJSApi& handler, const RViewFocusListenerAdapter& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RViewFocusListenerAdapter object:
          RViewFocusListenerAdapter_Wrapper* ret = new RViewFocusListenerAdapter_Wrapper(handler, new RViewFocusListenerAdapter(v), true);

          // JS: new RViewFocusListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RViewFocusListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RViewFocusListenerAdapter is undefined. Use RViewFocusListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RViewFocusListenerAdapter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RViewFocusListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RViewFocusListenerAdapter RJSHelper_qcad::js2cpp_RViewFocusListenerAdapter(RJSApi& handler, const QJSValue& v) {
          /*
          RViewFocusListenerAdapter_Wrapper* wrapper = getWrapper<RViewFocusListenerAdapter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RViewFocusListenerAdapter: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RViewFocusListenerAdapter();
          }
          //return *(RViewFocusListenerAdapter*)wrapper->getWrappedVoid();
          RViewFocusListenerAdapter* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RViewFocusListenerAdapter: wrapped pointer is NULL";
              return RViewFocusListenerAdapter();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RViewFocusListenerAdapter: not a QObject";
              return RViewFocusListenerAdapter();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RViewFocusListenerAdapter_ptr: no wrapper";
              handler.trace();
              return RViewFocusListenerAdapter();
          }
          //RViewFocusListenerAdapter* ret = getWrapped_RViewFocusListenerAdapter(wrapper);
          RViewFocusListenerAdapter* ret = RViewFocusListenerAdapter_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RViewFocusListenerAdapter();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RViewFocusListenerAdapter(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RViewFocusListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RViewFocusListenerAdapter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RViewportData(RJSApi& handler, const RViewportData* v) {
          QJSEngine* engine = handler.getEngine();
          RViewportData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RViewportData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RViewportData object:
              ret = new RViewportData_Wrapper(handler, new RViewportData(*v), true);
          }

          // JS: new RViewportData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RViewportData");
          if (cl.isUndefined()) {
              qWarning() << "Class RViewportData is undefined. Use RViewportData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RViewportData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RViewportData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RViewportData(RJSApi& handler, const RViewportData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RViewportData object:
          RViewportData_Wrapper* ret = new RViewportData_Wrapper(handler, new RViewportData(v), true);

          // JS: new RViewportData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RViewportData");
          if (cl.isUndefined()) {
              qWarning() << "Class RViewportData is undefined. Use RViewportData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RViewportData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RViewportData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RViewportData RJSHelper_qcad::js2cpp_RViewportData(RJSApi& handler, const QJSValue& v) {
          /*
          RViewportData_Wrapper* wrapper = getWrapper<RViewportData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RViewportData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RViewportData();
          }
          //return *(RViewportData*)wrapper->getWrappedVoid();
          RViewportData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RViewportData: wrapped pointer is NULL";
              return RViewportData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RViewportData: not a QObject";
              return RViewportData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RViewportData_ptr: no wrapper";
              handler.trace();
              return RViewportData();
          }
          //RViewportData* ret = getWrapped_RViewportData(wrapper);
          RViewportData* ret = RViewportData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RViewportData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RViewportData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RViewportData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RViewportData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RWipeoutData(RJSApi& handler, const RWipeoutData* v) {
          QJSEngine* engine = handler.getEngine();
          RWipeoutData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RWipeoutData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RWipeoutData object:
              ret = new RWipeoutData_Wrapper(handler, new RWipeoutData(*v), true);
          }

          // JS: new RWipeoutData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RWipeoutData");
          if (cl.isUndefined()) {
              qWarning() << "Class RWipeoutData is undefined. Use RWipeoutData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RWipeoutData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RWipeoutData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RWipeoutData(RJSApi& handler, const RWipeoutData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RWipeoutData object:
          RWipeoutData_Wrapper* ret = new RWipeoutData_Wrapper(handler, new RWipeoutData(v), true);

          // JS: new RWipeoutData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RWipeoutData");
          if (cl.isUndefined()) {
              qWarning() << "Class RWipeoutData is undefined. Use RWipeoutData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RWipeoutData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RWipeoutData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RWipeoutData RJSHelper_qcad::js2cpp_RWipeoutData(RJSApi& handler, const QJSValue& v) {
          /*
          RWipeoutData_Wrapper* wrapper = getWrapper<RWipeoutData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RWipeoutData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RWipeoutData();
          }
          //return *(RWipeoutData*)wrapper->getWrappedVoid();
          RWipeoutData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RWipeoutData: wrapped pointer is NULL";
              return RWipeoutData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RWipeoutData: not a QObject";
              return RWipeoutData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RWipeoutData_ptr: no wrapper";
              handler.trace();
              return RWipeoutData();
          }
          //RWipeoutData* ret = getWrapped_RWipeoutData(wrapper);
          RWipeoutData* ret = RWipeoutData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RWipeoutData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RWipeoutData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RWipeoutData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RWipeoutData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RXLine(RJSApi& handler, const RXLine* v) {
          QJSEngine* engine = handler.getEngine();
          RXLine_Wrapper* ret;

          if (v==nullptr) {
              ret = new RXLine_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RXLine object:
              ret = new RXLine_Wrapper(handler, new RXLine(*v), true);
          }

          // JS: new RXLine('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RXLine");
          if (cl.isUndefined()) {
              qWarning() << "Class RXLine is undefined. Use RXLine_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RXLine('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RXLine(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RXLine(RJSApi& handler, const RXLine& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RXLine object:
          RXLine_Wrapper* ret = new RXLine_Wrapper(handler, new RXLine(v), true);

          // JS: new RXLine('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RXLine");
          if (cl.isUndefined()) {
              qWarning() << "Class RXLine is undefined. Use RXLine_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RXLine('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RXLine(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RXLine RJSHelper_qcad::js2cpp_RXLine(RJSApi& handler, const QJSValue& v) {
          /*
          RXLine_Wrapper* wrapper = getWrapper<RXLine_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RXLine: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RXLine();
          }
          //return *(RXLine*)wrapper->getWrappedVoid();
          RXLine* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RXLine: wrapped pointer is NULL";
              return RXLine();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RXLine: not a QObject";
              return RXLine();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RXLine_ptr: no wrapper";
              handler.trace();
              return RXLine();
          }
          //RXLine* ret = getWrapped_RXLine(wrapper);
          RXLine* ret = RXLine_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RXLine();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RXLine(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RXLine: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RXLine::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RXLineData(RJSApi& handler, const RXLineData* v) {
          QJSEngine* engine = handler.getEngine();
          RXLineData_Wrapper* ret;

          if (v==nullptr) {
              ret = new RXLineData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RXLineData object:
              ret = new RXLineData_Wrapper(handler, new RXLineData(*v), true);
          }

          // JS: new RXLineData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RXLineData");
          if (cl.isUndefined()) {
              qWarning() << "Class RXLineData is undefined. Use RXLineData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RXLineData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RXLineData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RXLineData(RJSApi& handler, const RXLineData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RXLineData object:
          RXLineData_Wrapper* ret = new RXLineData_Wrapper(handler, new RXLineData(v), true);

          // JS: new RXLineData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RXLineData");
          if (cl.isUndefined()) {
              qWarning() << "Class RXLineData is undefined. Use RXLineData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RXLineData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RXLineData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RXLineData RJSHelper_qcad::js2cpp_RXLineData(RJSApi& handler, const QJSValue& v) {
          /*
          RXLineData_Wrapper* wrapper = getWrapper<RXLineData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RXLineData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RXLineData();
          }
          //return *(RXLineData*)wrapper->getWrappedVoid();
          RXLineData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RXLineData: wrapped pointer is NULL";
              return RXLineData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RXLineData: not a QObject";
              return RXLineData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RXLineData_ptr: no wrapper";
              handler.trace();
              return RXLineData();
          }
          //RXLineData* ret = getWrapped_RXLineData(wrapper);
          RXLineData* ret = RXLineData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RXLineData();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RXLineData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RXLineData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RXLineData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_RVector(RJSApi& handler, const RVector* v) {
          QJSEngine* engine = handler.getEngine();
          RVector_Wrapper* ret;

          if (v==nullptr) {
              ret = new RVector_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of RVector object:
              ret = new RVector_Wrapper(handler, new RVector(*v), true);
          }

          // JS: new RVector('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RVector");
          if (cl.isUndefined()) {
              qWarning() << "Class RVector is undefined. Use RVector_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RVector('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RVector(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RVector(RJSApi& handler, const RVector& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the RVector object:
          RVector_Wrapper* ret = new RVector_Wrapper(handler, new RVector(v), true);

          // JS: new RVector('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RVector");
          if (cl.isUndefined()) {
              qWarning() << "Class RVector is undefined. Use RVector_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RVector('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RVector(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      RVector RJSHelper_qcad::js2cpp_RVector(RJSApi& handler, const QJSValue& v) {
          /*
          RVector_Wrapper* wrapper = getWrapper<RVector_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RVector: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return RVector();
          }
          //return *(RVector*)wrapper->getWrappedVoid();
          RVector* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_RVector: wrapped pointer is NULL";
              return RVector();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RVector: not a QObject";
              return RVector();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RVector_ptr: no wrapper";
              handler.trace();
              return RVector();
          }
          //RVector* ret = getWrapped_RVector(wrapper);
          RVector* ret = RVector_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return RVector();
          }
          return *ret;
      }

      bool RJSHelper_qcad::is_RVector(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RVector: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_RVector::getIdStatic())).toBool();
      }
    