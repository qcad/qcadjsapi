
  // Automatically generated, do not edit
  
          #include "RJSHelper_qcad.h"
        
          #include "header_qcad_cpp.h"
        
          #include "raction_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "raddobjectsoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rarc_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rtextbaseddata_wrapper.h"
        
          #include "rtextbaseddata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rtextbasedentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rtextbasedentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rblocklistener_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qtoolbar_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rwidget_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rcircle_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qcolor_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qlineedit_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "rinputevent_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rcoordinatelistener_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rclipboardoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rdeleteobjectsoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rclipboardoperation_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimlineardata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimlinearentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimangulardata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimangularentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimangulardata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimangularentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimangulardata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimangularentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimlineardata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimlinearentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rdimstyledata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qdockwidget_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rellipse_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rinputevent_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rexportlistener_wrapper.h"
        
          #include "rsoliddata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rexporter_wrapper.h"
        
          #include "rexporter_wrapper.h"
        
          #include "rfileexporter_wrapper.h"
        
          #include "rfileexporterfactory_wrapper.h"
        
          #include "rimporter_wrapper.h"
        
          #include "rimporter_wrapper.h"
        
          #include "rfileimporter_wrapper.h"
        
          #include "rfileimporterfactory_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemmodel_wrapper.h"
        
          #include "qfilesystemmodel_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
          #include "qlayout_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rfocuslistener_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rexporter_wrapper.h"
        
          #include "rexporter_wrapper.h"
        
          #include "rgraphicsscene_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rgraphicsview_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rfocuslistener_wrapper.h"
        
          #include "rtransactionlistener_wrapper.h"
        
          #include "rselectionlistener_wrapper.h"
        
          #include "qaction_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rimportlistener_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rintertransactionlistener_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rkeylistener_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rlayerlistener_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpolyline_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rline_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qlistview_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qlistview_wrapper.h"
        
          #include "qlistwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rmainwindow_wrapper.h"
        
          #include "qmainwindow_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qlineedit_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qmdiarea_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rmodifiedlistener_wrapper.h"
        
          #include "qmdisubwindow_wrapper.h"
        
          #include "rstorage_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "raddobjectoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "raddobjectsoperation_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qinputevent_wrapper.h"
        
          #include "qpointerevent_wrapper.h"
        
          #include "qsinglepointevent_wrapper.h"
        
          #include "qmouseevent_wrapper.h"
        
          #include "rinputevent_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rgrid_wrapper.h"
        
          #include "qpainterpath_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpalettelistener_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rclipboardoperation_wrapper.h"
        
          #include "rpatternlist_wrapper.h"
        
          #include "rpatternlist_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpenlistener_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpoint_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rexplodable_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpolyline_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpreferenceslistener_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpropertylistener_wrapper.h"
        
          #include "rlayerlistener_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpropertylistener_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rxline_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rray_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rvector_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
          #include "rrestrictorthogonal_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
          #include "rrestrictorthogonal_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rruler_wrapper.h"
        
          #include "rcoordinatelistener_wrapper.h"
        
          #include "rpalettelistener_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rselectionlistener_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qcoreapplication_wrapper.h"
        
          #include "qguiapplication_wrapper.h"
        
          #include "qapplication_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpolyline_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rspatialindex_wrapper.h"
        
          #include "rspatialindex_wrapper.h"
        
          #include "rspatialindexvisitor_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rexplodable_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rspline_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpainterpathsource_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rtextbaseddata_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qtextedit_wrapper.h"
        
          #include "qtextbrowser_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rtextbasedentity_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rpoint_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qtoolbutton_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemdelegate_wrapper.h"
        
          #include "qitemdelegate_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rsoliddata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rtransactionlistener_wrapper.h"
        
          #include "qtransform_wrapper.h"
        
          #include "rtransformation_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qtreeview_wrapper.h"
        
          #include "qtreewidget_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rexplodable_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rviewfocuslistener_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rviewlistener_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpoint_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qinputevent_wrapper.h"
        
          #include "qpointerevent_wrapper.h"
        
          #include "qsinglepointevent_wrapper.h"
        
          #include "qwheelevent_wrapper.h"
        
          #include "rinputevent_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpolylinedata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rxline_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        // downcaster classes:
        

          // downcasters from QAction to ...
          

            // downcasters from QAction to RGuiAction
            class RJSDowncaster_QAction_RGuiAction : public RJSDowncaster_QAction {
                QJSValue downcast(RJSApi& handler, QAction* o) {
                    RGuiAction* c = dynamic_cast<RGuiAction*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RGuiAction(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QApplication to ...
          

            // downcasters from QApplication to RSingleApplication
            class RJSDowncaster_QApplication_RSingleApplication : public RJSDowncaster_QApplication {
                QJSValue downcast(RJSApi& handler, QApplication* o) {
                    RSingleApplication* c = dynamic_cast<RSingleApplication*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RSingleApplication(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QComboBox to ...
          

            // downcasters from QComboBox to RColorCombo
            class RJSDowncaster_QComboBox_RColorCombo : public RJSDowncaster_QComboBox {
                QJSValue downcast(RJSApi& handler, QComboBox* o) {
                    RColorCombo* c = dynamic_cast<RColorCombo*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RColorCombo(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QComboBox to RComboBox
            class RJSDowncaster_QComboBox_RComboBox : public RJSDowncaster_QComboBox {
                QJSValue downcast(RJSApi& handler, QComboBox* o) {
                    RComboBox* c = dynamic_cast<RComboBox*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RComboBox(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QComboBox to RLinetypeCombo
            class RJSDowncaster_QComboBox_RLinetypeCombo : public RJSDowncaster_QComboBox {
                QJSValue downcast(RJSApi& handler, QComboBox* o) {
                    RLinetypeCombo* c = dynamic_cast<RLinetypeCombo*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RLinetypeCombo(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QComboBox to RLineweightCombo
            class RJSDowncaster_QComboBox_RLineweightCombo : public RJSDowncaster_QComboBox {
                QJSValue downcast(RJSApi& handler, QComboBox* o) {
                    RLineweightCombo* c = dynamic_cast<RLineweightCombo*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RLineweightCombo(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QComboBox to RMathComboBox
            class RJSDowncaster_QComboBox_RMathComboBox : public RJSDowncaster_QComboBox {
                QJSValue downcast(RJSApi& handler, QComboBox* o) {
                    RMathComboBox* c = dynamic_cast<RMathComboBox*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RMathComboBox(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QEvent to ...
          

            // downcasters from QEvent to RCloseCurrentEvent
            class RJSDowncaster_QEvent_RCloseCurrentEvent : public RJSDowncaster_QEvent {
                QJSValue downcast(RJSApi& handler, QEvent* o) {
                    RCloseCurrentEvent* c = dynamic_cast<RCloseCurrentEvent*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RCloseCurrentEvent(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QEvent to RPropertyEvent
            class RJSDowncaster_QEvent_RPropertyEvent : public RJSDowncaster_QEvent {
                QJSValue downcast(RJSApi& handler, QEvent* o) {
                    RPropertyEvent* c = dynamic_cast<RPropertyEvent*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RPropertyEvent(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QEvent to RTerminateEvent
            class RJSDowncaster_QEvent_RTerminateEvent : public RJSDowncaster_QEvent {
                QJSValue downcast(RJSApi& handler, QEvent* o) {
                    RTerminateEvent* c = dynamic_cast<RTerminateEvent*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RTerminateEvent(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QDockWidget to ...
          

            // downcasters from QDockWidget to RDockWidget
            class RJSDowncaster_QDockWidget_RDockWidget : public RJSDowncaster_QDockWidget {
                QJSValue downcast(RJSApi& handler, QDockWidget* o) {
                    RDockWidget* c = dynamic_cast<RDockWidget*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RDockWidget(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QFileSystemModel to ...
          

            // downcasters from QFileSystemModel to RFileSystemModel
            class RJSDowncaster_QFileSystemModel_RFileSystemModel : public RJSDowncaster_QFileSystemModel {
                QJSValue downcast(RJSApi& handler, QFileSystemModel* o) {
                    RFileSystemModel* c = dynamic_cast<RFileSystemModel*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RFileSystemModel(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QFrame to ...
          

            // downcasters from QFrame to RRulerQt
            class RJSDowncaster_QFrame_RRulerQt : public RJSDowncaster_QFrame {
                QJSValue downcast(RJSApi& handler, QFrame* o) {
                    RRulerQt* c = dynamic_cast<RRulerQt*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RRulerQt(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QItemDelegate to ...
          

            // downcasters from QItemDelegate to RToolMatrixItemDelegate
            class RJSDowncaster_QItemDelegate_RToolMatrixItemDelegate : public RJSDowncaster_QItemDelegate {
                QJSValue downcast(RJSApi& handler, QItemDelegate* o) {
                    RToolMatrixItemDelegate* c = dynamic_cast<RToolMatrixItemDelegate*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RToolMatrixItemDelegate(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QJSEngine to ...
          

          // downcasters from QLayout to ...
          

            // downcasters from QLayout to RFlowLayout
            class RJSDowncaster_QLayout_RFlowLayout : public RJSDowncaster_QLayout {
                QJSValue downcast(RJSApi& handler, QLayout* o) {
                    RFlowLayout* c = dynamic_cast<RFlowLayout*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RFlowLayout(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QLineEdit to ...
          

            // downcasters from QLineEdit to RCommandLine
            class RJSDowncaster_QLineEdit_RCommandLine : public RJSDowncaster_QLineEdit {
                QJSValue downcast(RJSApi& handler, QLineEdit* o) {
                    RCommandLine* c = dynamic_cast<RCommandLine*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RCommandLine(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QLineEdit to RMathLineEdit
            class RJSDowncaster_QLineEdit_RMathLineEdit : public RJSDowncaster_QLineEdit {
                QJSValue downcast(RJSApi& handler, QLineEdit* o) {
                    RMathLineEdit* c = dynamic_cast<RMathLineEdit*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RMathLineEdit(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QListView to ...
          

            // downcasters from QListView to RListView
            class RJSDowncaster_QListView_RListView : public RJSDowncaster_QListView {
                QJSValue downcast(RJSApi& handler, QListView* o) {
                    RListView* c = dynamic_cast<RListView*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RListView(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QListWidget to ...
          

            // downcasters from QListWidget to RListWidget
            class RJSDowncaster_QListWidget_RListWidget : public RJSDowncaster_QListWidget {
                QJSValue downcast(RJSApi& handler, QListWidget* o) {
                    RListWidget* c = dynamic_cast<RListWidget*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RListWidget(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QMainWindow to ...
          

            // downcasters from QMainWindow to RMainWindowQt
            class RJSDowncaster_QMainWindow_RMainWindowQt : public RJSDowncaster_QMainWindow {
                QJSValue downcast(RJSApi& handler, QMainWindow* o) {
                    RMainWindowQt* c = dynamic_cast<RMainWindowQt*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RMainWindowQt(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QMdiArea to ...
          

            // downcasters from QMdiArea to RMdiArea
            class RJSDowncaster_QMdiArea_RMdiArea : public RJSDowncaster_QMdiArea {
                QJSValue downcast(RJSApi& handler, QMdiArea* o) {
                    RMdiArea* c = dynamic_cast<RMdiArea*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RMdiArea(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QMdiSubWindow to ...
          

            // downcasters from QMdiSubWindow to RMdiChildQt
            class RJSDowncaster_QMdiSubWindow_RMdiChildQt : public RJSDowncaster_QMdiSubWindow {
                QJSValue downcast(RJSApi& handler, QMdiSubWindow* o) {
                    RMdiChildQt* c = dynamic_cast<RMdiChildQt*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RMdiChildQt(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QObject to ...
          

            // downcasters from QObject to REventFilter
            class RJSDowncaster_QObject_REventFilter : public RJSDowncaster_QObject {
                QJSValue downcast(RJSApi& handler, QObject* o) {
                    REventFilter* c = dynamic_cast<REventFilter*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_REventFilter(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QObject to REventHandler
            class RJSDowncaster_QObject_REventHandler : public RJSDowncaster_QObject {
                QJSValue downcast(RJSApi& handler, QObject* o) {
                    REventHandler* c = dynamic_cast<REventHandler*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_REventHandler(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QObject to RGraphicsViewImage
            class RJSDowncaster_QObject_RGraphicsViewImage : public RJSDowncaster_QObject {
                QJSValue downcast(RJSApi& handler, QObject* o) {
                    RGraphicsViewImage* c = dynamic_cast<RGraphicsViewImage*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RGraphicsViewImage(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QObject to RGraphicsViewWorker
            class RJSDowncaster_QObject_RGraphicsViewWorker : public RJSDowncaster_QObject {
                QJSValue downcast(RJSApi& handler, QObject* o) {
                    RGraphicsViewWorker* c = dynamic_cast<RGraphicsViewWorker*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RGraphicsViewWorker(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QObject to RToolOptionEventFilter
            class RJSDowncaster_QObject_RToolOptionEventFilter : public RJSDowncaster_QObject {
                QJSValue downcast(RJSApi& handler, QObject* o) {
                    RToolOptionEventFilter* c = dynamic_cast<RToolOptionEventFilter*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RToolOptionEventFilter(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QQmlEngine to ...
          

          // downcasters from QTextBrowser to ...
          

            // downcasters from QTextBrowser to RTextEdit
            class RJSDowncaster_QTextBrowser_RTextEdit : public RJSDowncaster_QTextBrowser {
                QJSValue downcast(RJSApi& handler, QTextBrowser* o) {
                    RTextEdit* c = dynamic_cast<RTextEdit*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RTextEdit(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QToolBar to ...
          

            // downcasters from QToolBar to RCadToolBar
            class RJSDowncaster_QToolBar_RCadToolBar : public RJSDowncaster_QToolBar {
                QJSValue downcast(RJSApi& handler, QToolBar* o) {
                    RCadToolBar* c = dynamic_cast<RCadToolBar*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RCadToolBar(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QToolButton to ...
          

            // downcasters from QToolButton to RToolButton
            class RJSDowncaster_QToolButton_RToolButton : public RJSDowncaster_QToolButton {
                QJSValue downcast(RJSApi& handler, QToolButton* o) {
                    RToolButton* c = dynamic_cast<RToolButton*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RToolButton(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QTreeWidget to ...
          

            // downcasters from QTreeWidget to RTreeWidget
            class RJSDowncaster_QTreeWidget_RTreeWidget : public RJSDowncaster_QTreeWidget {
                QJSValue downcast(RJSApi& handler, QTreeWidget* o) {
                    RTreeWidget* c = dynamic_cast<RTreeWidget*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RTreeWidget(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QWidget to ...
          

            // downcasters from QWidget to RCharacterWidget
            class RJSDowncaster_QWidget_RCharacterWidget : public RJSDowncaster_QWidget {
                QJSValue downcast(RJSApi& handler, QWidget* o) {
                    RCharacterWidget* c = dynamic_cast<RCharacterWidget*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RCharacterWidget(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QWidget to RFontChooserWidget
            class RJSDowncaster_QWidget_RFontChooserWidget : public RJSDowncaster_QWidget {
                QJSValue downcast(RJSApi& handler, QWidget* o) {
                    RFontChooserWidget* c = dynamic_cast<RFontChooserWidget*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RFontChooserWidget(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QWidget to RGraphicsViewQt
            class RJSDowncaster_QWidget_RGraphicsViewQt : public RJSDowncaster_QWidget {
                QJSValue downcast(RJSApi& handler, QWidget* o) {
                    RGraphicsViewQt* c = dynamic_cast<RGraphicsViewQt*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RGraphicsViewQt(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QWidget to RWidget
            class RJSDowncaster_QWidget_RWidget : public RJSDowncaster_QWidget {
                QJSValue downcast(RJSApi& handler, QWidget* o) {
                    RWidget* c = dynamic_cast<RWidget*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RWidget(handler, c);
                    }
                    return QJSValue();
                }
            };

          
  // ------------
  // QList types:
  // ------------
  
      QJSValue RJSHelper_qcad::cpp2js_QList_RArc(RJSApi& handler, const QList<RArc>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RArc(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RArc> RJSHelper_qcad::js2cpp_QList_RArc(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RArc>>(v);
          QList<RArc> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RArc: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RArc(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RArc(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RBlock_Id(RJSApi& handler, const QList<RBlock::Id>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RBlock_Id(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RBlock::Id> RJSHelper_qcad::js2cpp_QList_RBlock_Id(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RBlock::Id>>(v);
          QList<RBlock::Id> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RBlock_Id: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RBlock_Id(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RBlock_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RBox(RJSApi& handler, const QList<RBox>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RBox(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RBox> RJSHelper_qcad::js2cpp_QList_RBox(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RBox>>(v);
          QList<RBox> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RBox: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RBox(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RBox(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RColor(RJSApi& handler, const QList<RColor>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RColor(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RColor> RJSHelper_qcad::js2cpp_QList_RColor(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RColor>>(v);
          QList<RColor> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RColor: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RColor(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RColor(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_REntity_Id(RJSApi& handler, const QList<REntity::Id>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_REntity_Id(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<REntity::Id> RJSHelper_qcad::js2cpp_QList_REntity_Id(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<REntity::Id>>(v);
          QList<REntity::Id> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_REntity_Id: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_REntity_Id(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_REntity_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RGraphicsSceneDrawable(RJSApi& handler, const QList<RGraphicsSceneDrawable>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RGraphicsSceneDrawable(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RGraphicsSceneDrawable> RJSHelper_qcad::js2cpp_QList_RGraphicsSceneDrawable(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RGraphicsSceneDrawable>>(v);
          QList<RGraphicsSceneDrawable> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RGraphicsSceneDrawable: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RGraphicsSceneDrawable(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RGraphicsSceneDrawable(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RLayer_Id(RJSApi& handler, const QList<RLayer::Id>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RLayer_Id(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RLayer::Id> RJSHelper_qcad::js2cpp_QList_RLayer_Id(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RLayer::Id>>(v);
          QList<RLayer::Id> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RLayer_Id: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RLayer_Id(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RLayer_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RLine(RJSApi& handler, const QList<RLine>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RLine(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RLine> RJSHelper_qcad::js2cpp_QList_RLine(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RLine>>(v);
          QList<RLine> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RLine: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RLine(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RLine(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RLinetypePattern(RJSApi& handler, const QList<RLinetypePattern>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RLinetypePattern(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RLinetypePattern> RJSHelper_qcad::js2cpp_QList_RLinetypePattern(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RLinetypePattern>>(v);
          QList<RLinetypePattern> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RLinetypePattern: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RLinetypePattern(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RLinetypePattern(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RObject_Id(RJSApi& handler, const QList<RObject::Id>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RObject_Id(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RObject::Id> RJSHelper_qcad::js2cpp_QList_RObject_Id(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RObject::Id>>(v);
          QList<RObject::Id> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RObject_Id: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RObject_Id(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RObject_Id(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RPainterPath(RJSApi& handler, const QList<RPainterPath>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RPainterPath(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RPainterPath> RJSHelper_qcad::js2cpp_QList_RPainterPath(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RPainterPath>>(v);
          QList<RPainterPath> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RPainterPath: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RPainterPath(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RPainterPath(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RPatternLine(RJSApi& handler, const QList<RPatternLine>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RPatternLine(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RPatternLine> RJSHelper_qcad::js2cpp_QList_RPatternLine(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RPatternLine>>(v);
          QList<RPatternLine> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RPatternLine: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RPatternLine(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RPatternLine(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RPolyline(RJSApi& handler, const QList<RPolyline>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RPolyline(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RPolyline> RJSHelper_qcad::js2cpp_QList_RPolyline(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RPolyline>>(v);
          QList<RPolyline> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RPolyline: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RPolyline(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RPolyline(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RPropertyChange(RJSApi& handler, const QList<RPropertyChange>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RPropertyChange(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RPropertyChange> RJSHelper_qcad::js2cpp_QList_RPropertyChange(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RPropertyChange>>(v);
          QList<RPropertyChange> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RPropertyChange: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RPropertyChange(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RPropertyChange(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RPropertyTypeId(RJSApi& handler, const QList<RPropertyTypeId>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RPropertyTypeId(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RPropertyTypeId> RJSHelper_qcad::js2cpp_QList_RPropertyTypeId(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RPropertyTypeId>>(v);
          QList<RPropertyTypeId> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RPropertyTypeId: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RPropertyTypeId(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RPropertyTypeId(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RRefPoint(RJSApi& handler, const QList<RRefPoint>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RRefPoint(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RRefPoint> RJSHelper_qcad::js2cpp_QList_RRefPoint(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RRefPoint>>(v);
          QList<RRefPoint> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RRefPoint: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RRefPoint(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RRefPoint(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RS_EntityType(RJSApi& handler, const QList<RS::EntityType>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RS_EntityType(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RS::EntityType> RJSHelper_qcad::js2cpp_QList_RS_EntityType(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RS::EntityType>>(v);
          QList<RS::EntityType> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RS_EntityType: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RS_EntityType(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RS_EntityType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RSpline(RJSApi& handler, const QList<RSpline>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RSpline(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RSpline> RJSHelper_qcad::js2cpp_QList_RSpline(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RSpline>>(v);
          QList<RSpline> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RSpline: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RSpline(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RSpline(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RTextBasedData(RJSApi& handler, const QList<RTextBasedData>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RTextBasedData(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RTextBasedData> RJSHelper_qcad::js2cpp_QList_RTextBasedData(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RTextBasedData>>(v);
          QList<RTextBasedData> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RTextBasedData: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RTextBasedData(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RTextBasedData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RTextData(RJSApi& handler, const QList<RTextData>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RTextData(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RTextData> RJSHelper_qcad::js2cpp_QList_RTextData(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RTextData>>(v);
          QList<RTextData> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RTextData: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RTextData(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RTextData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RTextLabel(RJSApi& handler, const QList<RTextLabel>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RTextLabel(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RTextLabel> RJSHelper_qcad::js2cpp_QList_RTextLabel(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RTextLabel>>(v);
          QList<RTextLabel> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RTextLabel: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RTextLabel(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RTextLabel(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RTextLayout(RJSApi& handler, const QList<RTextLayout>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RTextLayout(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RTextLayout> RJSHelper_qcad::js2cpp_QList_RTextLayout(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RTextLayout>>(v);
          QList<RTextLayout> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RTextLayout: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RTextLayout(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RTextLayout(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RTransaction(RJSApi& handler, const QList<RTransaction>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RTransaction(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RTransaction> RJSHelper_qcad::js2cpp_QList_RTransaction(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RTransaction>>(v);
          QList<RTransaction> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RTransaction: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RTransaction(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RTransaction(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RTransformOp(RJSApi& handler, const QList<RTransformOp>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RTransformOp(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RTransformOp> RJSHelper_qcad::js2cpp_QList_RTransformOp(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RTransformOp>>(v);
          QList<RTransformOp> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RTransformOp: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RTransformOp(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RTransformOp(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RTriangle(RJSApi& handler, const QList<RTriangle>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RTriangle(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RTriangle> RJSHelper_qcad::js2cpp_QList_RTriangle(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RTriangle>>(v);
          QList<RTriangle> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RTriangle: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RTriangle(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RTriangle(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QList_RVector(RJSApi& handler, const QList<RVector>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper_qcad::cpp2js_RVector(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<RVector> RJSHelper_qcad::js2cpp_QList_RVector(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<RVector>>(v);
          QList<RVector> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_RVector: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_RVector(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper_qcad::is_QList_RVector(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    