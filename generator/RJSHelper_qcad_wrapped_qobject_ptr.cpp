
  // Automatically generated, do not edit
  
          #include "RJSHelper_qcad.h"
        
          #include "header_qcad_cpp.h"
        
          #include "raction_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "raddobjectsoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rarc_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rtextbaseddata_wrapper.h"
        
          #include "rtextbaseddata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rtextbasedentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rtextbasedentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rblocklistener_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qtoolbar_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rwidget_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rcircle_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qcolor_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qlineedit_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "rinputevent_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rcoordinatelistener_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rclipboardoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rdeleteobjectsoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rclipboardoperation_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimlineardata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimlinearentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimangulardata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimangularentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimangulardata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimangularentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimangulardata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimangularentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimlineardata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimlinearentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rdimstyledata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qdockwidget_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rellipse_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rinputevent_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rexportlistener_wrapper.h"
        
          #include "rsoliddata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rexporter_wrapper.h"
        
          #include "rexporter_wrapper.h"
        
          #include "rfileexporter_wrapper.h"
        
          #include "rfileexporterfactory_wrapper.h"
        
          #include "rimporter_wrapper.h"
        
          #include "rimporter_wrapper.h"
        
          #include "rfileimporter_wrapper.h"
        
          #include "rfileimporterfactory_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemmodel_wrapper.h"
        
          #include "qfilesystemmodel_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
          #include "qlayout_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rfocuslistener_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rexporter_wrapper.h"
        
          #include "rexporter_wrapper.h"
        
          #include "rgraphicsscene_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rgraphicsview_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rfocuslistener_wrapper.h"
        
          #include "rtransactionlistener_wrapper.h"
        
          #include "rselectionlistener_wrapper.h"
        
          #include "qaction_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rimportlistener_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rintertransactionlistener_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rkeylistener_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rlayerlistener_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpolyline_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rline_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qlistview_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qlistview_wrapper.h"
        
          #include "qlistwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rmainwindow_wrapper.h"
        
          #include "qmainwindow_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qlineedit_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qmdiarea_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rmodifiedlistener_wrapper.h"
        
          #include "qmdisubwindow_wrapper.h"
        
          #include "rstorage_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "raddobjectoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "raddobjectsoperation_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qinputevent_wrapper.h"
        
          #include "qpointerevent_wrapper.h"
        
          #include "qsinglepointevent_wrapper.h"
        
          #include "qmouseevent_wrapper.h"
        
          #include "rinputevent_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rgrid_wrapper.h"
        
          #include "qpainterpath_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpalettelistener_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rclipboardoperation_wrapper.h"
        
          #include "rpatternlist_wrapper.h"
        
          #include "rpatternlist_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpenlistener_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpoint_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rexplodable_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpolyline_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpreferenceslistener_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpropertylistener_wrapper.h"
        
          #include "rlayerlistener_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpropertylistener_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rxline_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rray_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rvector_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
          #include "rrestrictorthogonal_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
          #include "rrestrictorthogonal_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rruler_wrapper.h"
        
          #include "rcoordinatelistener_wrapper.h"
        
          #include "rpalettelistener_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rselectionlistener_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qcoreapplication_wrapper.h"
        
          #include "qguiapplication_wrapper.h"
        
          #include "qapplication_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpolyline_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rspatialindex_wrapper.h"
        
          #include "rspatialindex_wrapper.h"
        
          #include "rspatialindexvisitor_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rexplodable_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rspline_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpainterpathsource_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rtextbaseddata_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qtextedit_wrapper.h"
        
          #include "qtextbrowser_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rtextbasedentity_wrapper.h"
        
          #include "rpoint_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qtoolbutton_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemdelegate_wrapper.h"
        
          #include "qitemdelegate_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rsoliddata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rtransactionlistener_wrapper.h"
        
          #include "qtransform_wrapper.h"
        
          #include "rtransformation_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qtreeview_wrapper.h"
        
          #include "qtreewidget_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rexplodable_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rviewfocuslistener_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rviewlistener_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpoint_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qinputevent_wrapper.h"
        
          #include "qpointerevent_wrapper.h"
        
          #include "qsinglepointevent_wrapper.h"
        
          #include "qwheelevent_wrapper.h"
        
          #include "rinputevent_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpolylinedata_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rxline_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        // downcaster classes:
        

          // downcasters from QAction to ...
          

            // downcasters from QAction to RGuiAction
            class RJSDowncaster_QAction_RGuiAction : public RJSDowncaster_QAction {
                QJSValue downcast(RJSApi& handler, QAction* o) {
                    RGuiAction* c = dynamic_cast<RGuiAction*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RGuiAction(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QApplication to ...
          

            // downcasters from QApplication to RSingleApplication
            class RJSDowncaster_QApplication_RSingleApplication : public RJSDowncaster_QApplication {
                QJSValue downcast(RJSApi& handler, QApplication* o) {
                    RSingleApplication* c = dynamic_cast<RSingleApplication*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RSingleApplication(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QComboBox to ...
          

            // downcasters from QComboBox to RColorCombo
            class RJSDowncaster_QComboBox_RColorCombo : public RJSDowncaster_QComboBox {
                QJSValue downcast(RJSApi& handler, QComboBox* o) {
                    RColorCombo* c = dynamic_cast<RColorCombo*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RColorCombo(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QComboBox to RComboBox
            class RJSDowncaster_QComboBox_RComboBox : public RJSDowncaster_QComboBox {
                QJSValue downcast(RJSApi& handler, QComboBox* o) {
                    RComboBox* c = dynamic_cast<RComboBox*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RComboBox(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QComboBox to RLinetypeCombo
            class RJSDowncaster_QComboBox_RLinetypeCombo : public RJSDowncaster_QComboBox {
                QJSValue downcast(RJSApi& handler, QComboBox* o) {
                    RLinetypeCombo* c = dynamic_cast<RLinetypeCombo*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RLinetypeCombo(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QComboBox to RLineweightCombo
            class RJSDowncaster_QComboBox_RLineweightCombo : public RJSDowncaster_QComboBox {
                QJSValue downcast(RJSApi& handler, QComboBox* o) {
                    RLineweightCombo* c = dynamic_cast<RLineweightCombo*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RLineweightCombo(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QComboBox to RMathComboBox
            class RJSDowncaster_QComboBox_RMathComboBox : public RJSDowncaster_QComboBox {
                QJSValue downcast(RJSApi& handler, QComboBox* o) {
                    RMathComboBox* c = dynamic_cast<RMathComboBox*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RMathComboBox(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QEvent to ...
          

            // downcasters from QEvent to RCloseCurrentEvent
            class RJSDowncaster_QEvent_RCloseCurrentEvent : public RJSDowncaster_QEvent {
                QJSValue downcast(RJSApi& handler, QEvent* o) {
                    RCloseCurrentEvent* c = dynamic_cast<RCloseCurrentEvent*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RCloseCurrentEvent(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QEvent to RPropertyEvent
            class RJSDowncaster_QEvent_RPropertyEvent : public RJSDowncaster_QEvent {
                QJSValue downcast(RJSApi& handler, QEvent* o) {
                    RPropertyEvent* c = dynamic_cast<RPropertyEvent*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RPropertyEvent(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QEvent to RTerminateEvent
            class RJSDowncaster_QEvent_RTerminateEvent : public RJSDowncaster_QEvent {
                QJSValue downcast(RJSApi& handler, QEvent* o) {
                    RTerminateEvent* c = dynamic_cast<RTerminateEvent*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RTerminateEvent(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QDockWidget to ...
          

            // downcasters from QDockWidget to RDockWidget
            class RJSDowncaster_QDockWidget_RDockWidget : public RJSDowncaster_QDockWidget {
                QJSValue downcast(RJSApi& handler, QDockWidget* o) {
                    RDockWidget* c = dynamic_cast<RDockWidget*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RDockWidget(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QFileSystemModel to ...
          

            // downcasters from QFileSystemModel to RFileSystemModel
            class RJSDowncaster_QFileSystemModel_RFileSystemModel : public RJSDowncaster_QFileSystemModel {
                QJSValue downcast(RJSApi& handler, QFileSystemModel* o) {
                    RFileSystemModel* c = dynamic_cast<RFileSystemModel*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RFileSystemModel(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QFrame to ...
          

            // downcasters from QFrame to RRulerQt
            class RJSDowncaster_QFrame_RRulerQt : public RJSDowncaster_QFrame {
                QJSValue downcast(RJSApi& handler, QFrame* o) {
                    RRulerQt* c = dynamic_cast<RRulerQt*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RRulerQt(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QItemDelegate to ...
          

            // downcasters from QItemDelegate to RToolMatrixItemDelegate
            class RJSDowncaster_QItemDelegate_RToolMatrixItemDelegate : public RJSDowncaster_QItemDelegate {
                QJSValue downcast(RJSApi& handler, QItemDelegate* o) {
                    RToolMatrixItemDelegate* c = dynamic_cast<RToolMatrixItemDelegate*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RToolMatrixItemDelegate(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QJSEngine to ...
          

          // downcasters from QLayout to ...
          

            // downcasters from QLayout to RFlowLayout
            class RJSDowncaster_QLayout_RFlowLayout : public RJSDowncaster_QLayout {
                QJSValue downcast(RJSApi& handler, QLayout* o) {
                    RFlowLayout* c = dynamic_cast<RFlowLayout*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RFlowLayout(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QLineEdit to ...
          

            // downcasters from QLineEdit to RCommandLine
            class RJSDowncaster_QLineEdit_RCommandLine : public RJSDowncaster_QLineEdit {
                QJSValue downcast(RJSApi& handler, QLineEdit* o) {
                    RCommandLine* c = dynamic_cast<RCommandLine*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RCommandLine(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QLineEdit to RMathLineEdit
            class RJSDowncaster_QLineEdit_RMathLineEdit : public RJSDowncaster_QLineEdit {
                QJSValue downcast(RJSApi& handler, QLineEdit* o) {
                    RMathLineEdit* c = dynamic_cast<RMathLineEdit*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RMathLineEdit(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QListView to ...
          

            // downcasters from QListView to RListView
            class RJSDowncaster_QListView_RListView : public RJSDowncaster_QListView {
                QJSValue downcast(RJSApi& handler, QListView* o) {
                    RListView* c = dynamic_cast<RListView*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RListView(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QListWidget to ...
          

            // downcasters from QListWidget to RListWidget
            class RJSDowncaster_QListWidget_RListWidget : public RJSDowncaster_QListWidget {
                QJSValue downcast(RJSApi& handler, QListWidget* o) {
                    RListWidget* c = dynamic_cast<RListWidget*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RListWidget(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QMainWindow to ...
          

            // downcasters from QMainWindow to RMainWindowQt
            class RJSDowncaster_QMainWindow_RMainWindowQt : public RJSDowncaster_QMainWindow {
                QJSValue downcast(RJSApi& handler, QMainWindow* o) {
                    RMainWindowQt* c = dynamic_cast<RMainWindowQt*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RMainWindowQt(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QMdiArea to ...
          

            // downcasters from QMdiArea to RMdiArea
            class RJSDowncaster_QMdiArea_RMdiArea : public RJSDowncaster_QMdiArea {
                QJSValue downcast(RJSApi& handler, QMdiArea* o) {
                    RMdiArea* c = dynamic_cast<RMdiArea*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RMdiArea(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QMdiSubWindow to ...
          

            // downcasters from QMdiSubWindow to RMdiChildQt
            class RJSDowncaster_QMdiSubWindow_RMdiChildQt : public RJSDowncaster_QMdiSubWindow {
                QJSValue downcast(RJSApi& handler, QMdiSubWindow* o) {
                    RMdiChildQt* c = dynamic_cast<RMdiChildQt*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RMdiChildQt(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QObject to ...
          

            // downcasters from QObject to REventFilter
            class RJSDowncaster_QObject_REventFilter : public RJSDowncaster_QObject {
                QJSValue downcast(RJSApi& handler, QObject* o) {
                    REventFilter* c = dynamic_cast<REventFilter*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_REventFilter(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QObject to REventHandler
            class RJSDowncaster_QObject_REventHandler : public RJSDowncaster_QObject {
                QJSValue downcast(RJSApi& handler, QObject* o) {
                    REventHandler* c = dynamic_cast<REventHandler*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_REventHandler(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QObject to RGraphicsViewImage
            class RJSDowncaster_QObject_RGraphicsViewImage : public RJSDowncaster_QObject {
                QJSValue downcast(RJSApi& handler, QObject* o) {
                    RGraphicsViewImage* c = dynamic_cast<RGraphicsViewImage*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RGraphicsViewImage(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QObject to RGraphicsViewWorker
            class RJSDowncaster_QObject_RGraphicsViewWorker : public RJSDowncaster_QObject {
                QJSValue downcast(RJSApi& handler, QObject* o) {
                    RGraphicsViewWorker* c = dynamic_cast<RGraphicsViewWorker*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RGraphicsViewWorker(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QObject to RToolOptionEventFilter
            class RJSDowncaster_QObject_RToolOptionEventFilter : public RJSDowncaster_QObject {
                QJSValue downcast(RJSApi& handler, QObject* o) {
                    RToolOptionEventFilter* c = dynamic_cast<RToolOptionEventFilter*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RToolOptionEventFilter(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QQmlEngine to ...
          

          // downcasters from QTextBrowser to ...
          

            // downcasters from QTextBrowser to RTextEdit
            class RJSDowncaster_QTextBrowser_RTextEdit : public RJSDowncaster_QTextBrowser {
                QJSValue downcast(RJSApi& handler, QTextBrowser* o) {
                    RTextEdit* c = dynamic_cast<RTextEdit*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RTextEdit(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QToolBar to ...
          

            // downcasters from QToolBar to RCadToolBar
            class RJSDowncaster_QToolBar_RCadToolBar : public RJSDowncaster_QToolBar {
                QJSValue downcast(RJSApi& handler, QToolBar* o) {
                    RCadToolBar* c = dynamic_cast<RCadToolBar*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RCadToolBar(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QToolButton to ...
          

            // downcasters from QToolButton to RToolButton
            class RJSDowncaster_QToolButton_RToolButton : public RJSDowncaster_QToolButton {
                QJSValue downcast(RJSApi& handler, QToolButton* o) {
                    RToolButton* c = dynamic_cast<RToolButton*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RToolButton(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QTreeWidget to ...
          

            // downcasters from QTreeWidget to RTreeWidget
            class RJSDowncaster_QTreeWidget_RTreeWidget : public RJSDowncaster_QTreeWidget {
                QJSValue downcast(RJSApi& handler, QTreeWidget* o) {
                    RTreeWidget* c = dynamic_cast<RTreeWidget*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RTreeWidget(handler, c);
                    }
                    return QJSValue();
                }
            };

          

          // downcasters from QWidget to ...
          

            // downcasters from QWidget to RCharacterWidget
            class RJSDowncaster_QWidget_RCharacterWidget : public RJSDowncaster_QWidget {
                QJSValue downcast(RJSApi& handler, QWidget* o) {
                    RCharacterWidget* c = dynamic_cast<RCharacterWidget*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RCharacterWidget(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QWidget to RFontChooserWidget
            class RJSDowncaster_QWidget_RFontChooserWidget : public RJSDowncaster_QWidget {
                QJSValue downcast(RJSApi& handler, QWidget* o) {
                    RFontChooserWidget* c = dynamic_cast<RFontChooserWidget*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RFontChooserWidget(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QWidget to RGraphicsViewQt
            class RJSDowncaster_QWidget_RGraphicsViewQt : public RJSDowncaster_QWidget {
                QJSValue downcast(RJSApi& handler, QWidget* o) {
                    RGraphicsViewQt* c = dynamic_cast<RGraphicsViewQt*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RGraphicsViewQt(handler, c);
                    }
                    return QJSValue();
                }
            };

          

            // downcasters from QWidget to RWidget
            class RJSDowncaster_QWidget_RWidget : public RJSDowncaster_QWidget {
                QJSValue downcast(RJSApi& handler, QWidget* o) {
                    RWidget* c = dynamic_cast<RWidget*>(o);
                    if (c!=nullptr) {
                        return RJSHelper_qcad::cpp2js_RWidget(handler, c);
                    }
                    return QJSValue();
                }
            };

          
  // ------------------------------
  // wrapped QObject pointer types:
  // ------------------------------
  
      QJSValue RJSHelper_qcad::cpp2js_RBlockListenerAdapter(RJSApi& handler, RBlockListenerAdapter* v) {
          RBlockListenerAdapter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RBlockListenerAdapter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RBlockListenerAdapter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RBlockListenerAdapter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RBlockListenerAdapter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RBlockListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RBlockListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RBlockListenerAdapter is undefined. Use RBlockListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RBlockListenerAdapter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RBlockListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RBlockListenerAdapter(RJSApi& handler, const RBlockListenerAdapter* v) {
          return RJSHelper_qcad::cpp2js_RBlockListenerAdapter(handler, const_cast<RBlockListenerAdapter*>(v));
      }

      RBlockListenerAdapter* RJSHelper_qcad::js2cpp_RBlockListenerAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RBlockListenerAdapter: not a QObject";
              return nullptr;
          }
          //RBlockListenerAdapter_Wrapper* wrapper = getWrapper<RBlockListenerAdapter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RBlockListenerAdapter_Wrapper* wrapper = qobject_cast<RBlockListenerAdapter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RBlockListenerAdapter_Wrapper* wrapper = dynamic_cast<RBlockListenerAdapter_Wrapper*>(obj);
          //RBlockListenerAdapter_Wrapper* wrapper = (RBlockListenerAdapter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RBlockListenerAdapter: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RBlockListenerAdapter*)wrapper->getWrappedVoid();
          //return getWrapped_RBlockListenerAdapter(wrapper);
          return RBlockListenerAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RBlockListenerAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RBlockListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RBlockListenerAdapter_Type);
          //return fun.call().toInt()==RJSType::RBlockListenerAdapter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RBlockListenerAdapter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RCadToolBar(RJSApi& handler, RCadToolBar* v) {
          RCadToolBar_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RCadToolBar_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RCadToolBar: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RCadToolBar_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RCadToolBar_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RCadToolBar('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCadToolBar");
          if (cl.isUndefined()) {
              qWarning() << "Class RCadToolBar is undefined. Use RCadToolBar_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCadToolBar('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCadToolBar(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RCadToolBar(RJSApi& handler, const RCadToolBar* v) {
          return RJSHelper_qcad::cpp2js_RCadToolBar(handler, const_cast<RCadToolBar*>(v));
      }

      RCadToolBar* RJSHelper_qcad::js2cpp_RCadToolBar_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RCadToolBar: not a QObject";
              return nullptr;
          }
          //RCadToolBar_Wrapper* wrapper = getWrapper<RCadToolBar_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RCadToolBar_Wrapper* wrapper = qobject_cast<RCadToolBar_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RCadToolBar_Wrapper* wrapper = dynamic_cast<RCadToolBar_Wrapper*>(obj);
          //RCadToolBar_Wrapper* wrapper = (RCadToolBar_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCadToolBar: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RCadToolBar*)wrapper->getWrappedVoid();
          //return getWrapped_RCadToolBar(wrapper);
          return RCadToolBar_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RCadToolBar_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RCadToolBar: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RCadToolBar_Type);
          //return fun.call().toInt()==RJSType::RCadToolBar_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RCadToolBar::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RCadToolBarPanel(RJSApi& handler, RCadToolBarPanel* v) {
          RCadToolBarPanel_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RCadToolBarPanel_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RCadToolBarPanel: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RCadToolBarPanel_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RCadToolBarPanel_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RCadToolBarPanel('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCadToolBarPanel");
          if (cl.isUndefined()) {
              qWarning() << "Class RCadToolBarPanel is undefined. Use RCadToolBarPanel_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCadToolBarPanel('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCadToolBarPanel(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RCadToolBarPanel(RJSApi& handler, const RCadToolBarPanel* v) {
          return RJSHelper_qcad::cpp2js_RCadToolBarPanel(handler, const_cast<RCadToolBarPanel*>(v));
      }

      RCadToolBarPanel* RJSHelper_qcad::js2cpp_RCadToolBarPanel_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RCadToolBarPanel: not a QObject";
              return nullptr;
          }
          //RCadToolBarPanel_Wrapper* wrapper = getWrapper<RCadToolBarPanel_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RCadToolBarPanel_Wrapper* wrapper = qobject_cast<RCadToolBarPanel_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RCadToolBarPanel_Wrapper* wrapper = dynamic_cast<RCadToolBarPanel_Wrapper*>(obj);
          //RCadToolBarPanel_Wrapper* wrapper = (RCadToolBarPanel_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCadToolBarPanel: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RCadToolBarPanel*)wrapper->getWrappedVoid();
          //return getWrapped_RCadToolBarPanel(wrapper);
          return RCadToolBarPanel_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RCadToolBarPanel_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RCadToolBarPanel: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RCadToolBarPanel_Type);
          //return fun.call().toInt()==RJSType::RCadToolBarPanel_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RCadToolBarPanel::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RCharacterWidget(RJSApi& handler, RCharacterWidget* v) {
          RCharacterWidget_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RCharacterWidget_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RCharacterWidget: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RCharacterWidget_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RCharacterWidget_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RCharacterWidget('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCharacterWidget");
          if (cl.isUndefined()) {
              qWarning() << "Class RCharacterWidget is undefined. Use RCharacterWidget_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCharacterWidget('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCharacterWidget(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RCharacterWidget(RJSApi& handler, const RCharacterWidget* v) {
          return RJSHelper_qcad::cpp2js_RCharacterWidget(handler, const_cast<RCharacterWidget*>(v));
      }

      RCharacterWidget* RJSHelper_qcad::js2cpp_RCharacterWidget_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RCharacterWidget: not a QObject";
              return nullptr;
          }
          //RCharacterWidget_Wrapper* wrapper = getWrapper<RCharacterWidget_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RCharacterWidget_Wrapper* wrapper = qobject_cast<RCharacterWidget_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RCharacterWidget_Wrapper* wrapper = dynamic_cast<RCharacterWidget_Wrapper*>(obj);
          //RCharacterWidget_Wrapper* wrapper = (RCharacterWidget_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCharacterWidget: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RCharacterWidget*)wrapper->getWrappedVoid();
          //return getWrapped_RCharacterWidget(wrapper);
          return RCharacterWidget_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RCharacterWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RCharacterWidget: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RCharacterWidget_Type);
          //return fun.call().toInt()==RJSType::RCharacterWidget_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RCharacterWidget::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RColorCombo(RJSApi& handler, RColorCombo* v) {
          RColorCombo_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RColorCombo_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RColorCombo: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RColorCombo_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RColorCombo_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RColorCombo('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RColorCombo");
          if (cl.isUndefined()) {
              qWarning() << "Class RColorCombo is undefined. Use RColorCombo_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RColorCombo('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RColorCombo(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RColorCombo(RJSApi& handler, const RColorCombo* v) {
          return RJSHelper_qcad::cpp2js_RColorCombo(handler, const_cast<RColorCombo*>(v));
      }

      RColorCombo* RJSHelper_qcad::js2cpp_RColorCombo_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RColorCombo: not a QObject";
              return nullptr;
          }
          //RColorCombo_Wrapper* wrapper = getWrapper<RColorCombo_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RColorCombo_Wrapper* wrapper = qobject_cast<RColorCombo_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RColorCombo_Wrapper* wrapper = dynamic_cast<RColorCombo_Wrapper*>(obj);
          //RColorCombo_Wrapper* wrapper = (RColorCombo_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RColorCombo: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RColorCombo*)wrapper->getWrappedVoid();
          //return getWrapped_RColorCombo(wrapper);
          return RColorCombo_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RColorCombo_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RColorCombo: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RColorCombo_Type);
          //return fun.call().toInt()==RJSType::RColorCombo_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RColorCombo::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RComboBox(RJSApi& handler, RComboBox* v) {
          RComboBox_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RComboBox_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RComboBox: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RComboBox_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RComboBox_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RComboBox('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RComboBox");
          if (cl.isUndefined()) {
              qWarning() << "Class RComboBox is undefined. Use RComboBox_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RComboBox('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RComboBox(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RComboBox(RJSApi& handler, const RComboBox* v) {
          return RJSHelper_qcad::cpp2js_RComboBox(handler, const_cast<RComboBox*>(v));
      }

      RComboBox* RJSHelper_qcad::js2cpp_RComboBox_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RComboBox: not a QObject";
              return nullptr;
          }
          //RComboBox_Wrapper* wrapper = getWrapper<RComboBox_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RComboBox_Wrapper* wrapper = qobject_cast<RComboBox_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RComboBox_Wrapper* wrapper = dynamic_cast<RComboBox_Wrapper*>(obj);
          //RComboBox_Wrapper* wrapper = (RComboBox_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RComboBox: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RComboBox*)wrapper->getWrappedVoid();
          //return getWrapped_RComboBox(wrapper);
          return RComboBox_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RComboBox_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RComboBox: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RComboBox_Type);
          //return fun.call().toInt()==RJSType::RComboBox_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RComboBox::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RCommandLine(RJSApi& handler, RCommandLine* v) {
          RCommandLine_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RCommandLine_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RCommandLine: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RCommandLine_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RCommandLine_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RCommandLine('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCommandLine");
          if (cl.isUndefined()) {
              qWarning() << "Class RCommandLine is undefined. Use RCommandLine_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCommandLine('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCommandLine(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RCommandLine(RJSApi& handler, const RCommandLine* v) {
          return RJSHelper_qcad::cpp2js_RCommandLine(handler, const_cast<RCommandLine*>(v));
      }

      RCommandLine* RJSHelper_qcad::js2cpp_RCommandLine_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RCommandLine: not a QObject";
              return nullptr;
          }
          //RCommandLine_Wrapper* wrapper = getWrapper<RCommandLine_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RCommandLine_Wrapper* wrapper = qobject_cast<RCommandLine_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RCommandLine_Wrapper* wrapper = dynamic_cast<RCommandLine_Wrapper*>(obj);
          //RCommandLine_Wrapper* wrapper = (RCommandLine_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCommandLine: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RCommandLine*)wrapper->getWrappedVoid();
          //return getWrapped_RCommandLine(wrapper);
          return RCommandLine_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RCommandLine_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RCommandLine: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RCommandLine_Type);
          //return fun.call().toInt()==RJSType::RCommandLine_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RCommandLine::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RCoordinateListenerAdapter(RJSApi& handler, RCoordinateListenerAdapter* v) {
          RCoordinateListenerAdapter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RCoordinateListenerAdapter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RCoordinateListenerAdapter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RCoordinateListenerAdapter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RCoordinateListenerAdapter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RCoordinateListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCoordinateListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RCoordinateListenerAdapter is undefined. Use RCoordinateListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RCoordinateListenerAdapter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RCoordinateListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RCoordinateListenerAdapter(RJSApi& handler, const RCoordinateListenerAdapter* v) {
          return RJSHelper_qcad::cpp2js_RCoordinateListenerAdapter(handler, const_cast<RCoordinateListenerAdapter*>(v));
      }

      RCoordinateListenerAdapter* RJSHelper_qcad::js2cpp_RCoordinateListenerAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RCoordinateListenerAdapter: not a QObject";
              return nullptr;
          }
          //RCoordinateListenerAdapter_Wrapper* wrapper = getWrapper<RCoordinateListenerAdapter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RCoordinateListenerAdapter_Wrapper* wrapper = qobject_cast<RCoordinateListenerAdapter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RCoordinateListenerAdapter_Wrapper* wrapper = dynamic_cast<RCoordinateListenerAdapter_Wrapper*>(obj);
          //RCoordinateListenerAdapter_Wrapper* wrapper = (RCoordinateListenerAdapter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RCoordinateListenerAdapter: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RCoordinateListenerAdapter*)wrapper->getWrappedVoid();
          //return getWrapped_RCoordinateListenerAdapter(wrapper);
          return RCoordinateListenerAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RCoordinateListenerAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RCoordinateListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RCoordinateListenerAdapter_Type);
          //return fun.call().toInt()==RJSType::RCoordinateListenerAdapter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RCoordinateListenerAdapter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RDockWidget(RJSApi& handler, RDockWidget* v) {
          RDockWidget_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RDockWidget_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RDockWidget: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RDockWidget_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RDockWidget_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RDockWidget('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDockWidget");
          if (cl.isUndefined()) {
              qWarning() << "Class RDockWidget is undefined. Use RDockWidget_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RDockWidget('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RDockWidget(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RDockWidget(RJSApi& handler, const RDockWidget* v) {
          return RJSHelper_qcad::cpp2js_RDockWidget(handler, const_cast<RDockWidget*>(v));
      }

      RDockWidget* RJSHelper_qcad::js2cpp_RDockWidget_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RDockWidget: not a QObject";
              return nullptr;
          }
          //RDockWidget_Wrapper* wrapper = getWrapper<RDockWidget_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RDockWidget_Wrapper* wrapper = qobject_cast<RDockWidget_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RDockWidget_Wrapper* wrapper = dynamic_cast<RDockWidget_Wrapper*>(obj);
          //RDockWidget_Wrapper* wrapper = (RDockWidget_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RDockWidget: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RDockWidget*)wrapper->getWrappedVoid();
          //return getWrapped_RDockWidget(wrapper);
          return RDockWidget_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RDockWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RDockWidget: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RDockWidget_Type);
          //return fun.call().toInt()==RJSType::RDockWidget_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RDockWidget::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_REventFilter(RJSApi& handler, REventFilter* v) {
          REventFilter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<REventFilter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_REventFilter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new REventFilter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new REventFilter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new REventFilter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("REventFilter");
          if (cl.isUndefined()) {
              qWarning() << "Class REventFilter is undefined. Use REventFilter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new REventFilter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new REventFilter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_REventFilter(RJSApi& handler, const REventFilter* v) {
          return RJSHelper_qcad::cpp2js_REventFilter(handler, const_cast<REventFilter*>(v));
      }

      REventFilter* RJSHelper_qcad::js2cpp_REventFilter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_REventFilter: not a QObject";
              return nullptr;
          }
          //REventFilter_Wrapper* wrapper = getWrapper<REventFilter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //REventFilter_Wrapper* wrapper = qobject_cast<REventFilter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //REventFilter_Wrapper* wrapper = dynamic_cast<REventFilter_Wrapper*>(obj);
          //REventFilter_Wrapper* wrapper = (REventFilter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_REventFilter: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (REventFilter*)wrapper->getWrappedVoid();
          //return getWrapped_REventFilter(wrapper);
          return REventFilter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_REventFilter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_REventFilter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::REventFilter_Type);
          //return fun.call().toInt()==RJSType::REventFilter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_REventFilter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RExportListenerAdapter(RJSApi& handler, RExportListenerAdapter* v) {
          RExportListenerAdapter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RExportListenerAdapter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RExportListenerAdapter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RExportListenerAdapter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RExportListenerAdapter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RExportListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RExportListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RExportListenerAdapter is undefined. Use RExportListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RExportListenerAdapter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RExportListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RExportListenerAdapter(RJSApi& handler, const RExportListenerAdapter* v) {
          return RJSHelper_qcad::cpp2js_RExportListenerAdapter(handler, const_cast<RExportListenerAdapter*>(v));
      }

      RExportListenerAdapter* RJSHelper_qcad::js2cpp_RExportListenerAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RExportListenerAdapter: not a QObject";
              return nullptr;
          }
          //RExportListenerAdapter_Wrapper* wrapper = getWrapper<RExportListenerAdapter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RExportListenerAdapter_Wrapper* wrapper = qobject_cast<RExportListenerAdapter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RExportListenerAdapter_Wrapper* wrapper = dynamic_cast<RExportListenerAdapter_Wrapper*>(obj);
          //RExportListenerAdapter_Wrapper* wrapper = (RExportListenerAdapter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RExportListenerAdapter: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RExportListenerAdapter*)wrapper->getWrappedVoid();
          //return getWrapped_RExportListenerAdapter(wrapper);
          return RExportListenerAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RExportListenerAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RExportListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RExportListenerAdapter_Type);
          //return fun.call().toInt()==RJSType::RExportListenerAdapter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RExportListenerAdapter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RToolOptionEventFilter(RJSApi& handler, RToolOptionEventFilter* v) {
          RToolOptionEventFilter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RToolOptionEventFilter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RToolOptionEventFilter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RToolOptionEventFilter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RToolOptionEventFilter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RToolOptionEventFilter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RToolOptionEventFilter");
          if (cl.isUndefined()) {
              qWarning() << "Class RToolOptionEventFilter is undefined. Use RToolOptionEventFilter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RToolOptionEventFilter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RToolOptionEventFilter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RToolOptionEventFilter(RJSApi& handler, const RToolOptionEventFilter* v) {
          return RJSHelper_qcad::cpp2js_RToolOptionEventFilter(handler, const_cast<RToolOptionEventFilter*>(v));
      }

      RToolOptionEventFilter* RJSHelper_qcad::js2cpp_RToolOptionEventFilter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RToolOptionEventFilter: not a QObject";
              return nullptr;
          }
          //RToolOptionEventFilter_Wrapper* wrapper = getWrapper<RToolOptionEventFilter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RToolOptionEventFilter_Wrapper* wrapper = qobject_cast<RToolOptionEventFilter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RToolOptionEventFilter_Wrapper* wrapper = dynamic_cast<RToolOptionEventFilter_Wrapper*>(obj);
          //RToolOptionEventFilter_Wrapper* wrapper = (RToolOptionEventFilter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RToolOptionEventFilter: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RToolOptionEventFilter*)wrapper->getWrappedVoid();
          //return getWrapped_RToolOptionEventFilter(wrapper);
          return RToolOptionEventFilter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RToolOptionEventFilter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RToolOptionEventFilter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RToolOptionEventFilter_Type);
          //return fun.call().toInt()==RJSType::RToolOptionEventFilter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RToolOptionEventFilter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_REventHandler(RJSApi& handler, REventHandler* v) {
          REventHandler_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<REventHandler_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_REventHandler: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new REventHandler_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new REventHandler_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new REventHandler('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("REventHandler");
          if (cl.isUndefined()) {
              qWarning() << "Class REventHandler is undefined. Use REventHandler_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new REventHandler('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new REventHandler(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_REventHandler(RJSApi& handler, const REventHandler* v) {
          return RJSHelper_qcad::cpp2js_REventHandler(handler, const_cast<REventHandler*>(v));
      }

      REventHandler* RJSHelper_qcad::js2cpp_REventHandler_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_REventHandler: not a QObject";
              return nullptr;
          }
          //REventHandler_Wrapper* wrapper = getWrapper<REventHandler_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //REventHandler_Wrapper* wrapper = qobject_cast<REventHandler_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //REventHandler_Wrapper* wrapper = dynamic_cast<REventHandler_Wrapper*>(obj);
          //REventHandler_Wrapper* wrapper = (REventHandler_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_REventHandler: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (REventHandler*)wrapper->getWrappedVoid();
          //return getWrapped_REventHandler(wrapper);
          return REventHandler_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_REventHandler_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_REventHandler: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::REventHandler_Type);
          //return fun.call().toInt()==RJSType::REventHandler_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_REventHandler::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RFileSystemModel(RJSApi& handler, RFileSystemModel* v) {
          RFileSystemModel_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RFileSystemModel_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RFileSystemModel: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RFileSystemModel_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RFileSystemModel_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RFileSystemModel('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFileSystemModel");
          if (cl.isUndefined()) {
              qWarning() << "Class RFileSystemModel is undefined. Use RFileSystemModel_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFileSystemModel('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFileSystemModel(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RFileSystemModel(RJSApi& handler, const RFileSystemModel* v) {
          return RJSHelper_qcad::cpp2js_RFileSystemModel(handler, const_cast<RFileSystemModel*>(v));
      }

      RFileSystemModel* RJSHelper_qcad::js2cpp_RFileSystemModel_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFileSystemModel: not a QObject";
              return nullptr;
          }
          //RFileSystemModel_Wrapper* wrapper = getWrapper<RFileSystemModel_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RFileSystemModel_Wrapper* wrapper = qobject_cast<RFileSystemModel_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RFileSystemModel_Wrapper* wrapper = dynamic_cast<RFileSystemModel_Wrapper*>(obj);
          //RFileSystemModel_Wrapper* wrapper = (RFileSystemModel_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFileSystemModel: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RFileSystemModel*)wrapper->getWrappedVoid();
          //return getWrapped_RFileSystemModel(wrapper);
          return RFileSystemModel_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RFileSystemModel_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFileSystemModel: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RFileSystemModel_Type);
          //return fun.call().toInt()==RJSType::RFileSystemModel_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RFileSystemModel::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RFlowLayout(RJSApi& handler, RFlowLayout* v) {
          RFlowLayout_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RFlowLayout_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RFlowLayout: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RFlowLayout_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RFlowLayout_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RFlowLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFlowLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class RFlowLayout is undefined. Use RFlowLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFlowLayout('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFlowLayout(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RFlowLayout(RJSApi& handler, const RFlowLayout* v) {
          return RJSHelper_qcad::cpp2js_RFlowLayout(handler, const_cast<RFlowLayout*>(v));
      }

      RFlowLayout* RJSHelper_qcad::js2cpp_RFlowLayout_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFlowLayout: not a QObject";
              return nullptr;
          }
          //RFlowLayout_Wrapper* wrapper = getWrapper<RFlowLayout_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RFlowLayout_Wrapper* wrapper = qobject_cast<RFlowLayout_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RFlowLayout_Wrapper* wrapper = dynamic_cast<RFlowLayout_Wrapper*>(obj);
          //RFlowLayout_Wrapper* wrapper = (RFlowLayout_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFlowLayout: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RFlowLayout*)wrapper->getWrappedVoid();
          //return getWrapped_RFlowLayout(wrapper);
          return RFlowLayout_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RFlowLayout_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFlowLayout: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RFlowLayout_Type);
          //return fun.call().toInt()==RJSType::RFlowLayout_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RFlowLayout::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RFocusListenerAdapter(RJSApi& handler, RFocusListenerAdapter* v) {
          RFocusListenerAdapter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RFocusListenerAdapter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RFocusListenerAdapter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RFocusListenerAdapter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RFocusListenerAdapter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RFocusListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFocusListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RFocusListenerAdapter is undefined. Use RFocusListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFocusListenerAdapter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFocusListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RFocusListenerAdapter(RJSApi& handler, const RFocusListenerAdapter* v) {
          return RJSHelper_qcad::cpp2js_RFocusListenerAdapter(handler, const_cast<RFocusListenerAdapter*>(v));
      }

      RFocusListenerAdapter* RJSHelper_qcad::js2cpp_RFocusListenerAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFocusListenerAdapter: not a QObject";
              return nullptr;
          }
          //RFocusListenerAdapter_Wrapper* wrapper = getWrapper<RFocusListenerAdapter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RFocusListenerAdapter_Wrapper* wrapper = qobject_cast<RFocusListenerAdapter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RFocusListenerAdapter_Wrapper* wrapper = dynamic_cast<RFocusListenerAdapter_Wrapper*>(obj);
          //RFocusListenerAdapter_Wrapper* wrapper = (RFocusListenerAdapter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFocusListenerAdapter: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RFocusListenerAdapter*)wrapper->getWrappedVoid();
          //return getWrapped_RFocusListenerAdapter(wrapper);
          return RFocusListenerAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RFocusListenerAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFocusListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RFocusListenerAdapter_Type);
          //return fun.call().toInt()==RJSType::RFocusListenerAdapter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RFocusListenerAdapter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RFontChooserWidget(RJSApi& handler, RFontChooserWidget* v) {
          RFontChooserWidget_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RFontChooserWidget_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RFontChooserWidget: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RFontChooserWidget_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RFontChooserWidget_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RFontChooserWidget('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFontChooserWidget");
          if (cl.isUndefined()) {
              qWarning() << "Class RFontChooserWidget is undefined. Use RFontChooserWidget_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RFontChooserWidget('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RFontChooserWidget(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RFontChooserWidget(RJSApi& handler, const RFontChooserWidget* v) {
          return RJSHelper_qcad::cpp2js_RFontChooserWidget(handler, const_cast<RFontChooserWidget*>(v));
      }

      RFontChooserWidget* RJSHelper_qcad::js2cpp_RFontChooserWidget_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RFontChooserWidget: not a QObject";
              return nullptr;
          }
          //RFontChooserWidget_Wrapper* wrapper = getWrapper<RFontChooserWidget_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RFontChooserWidget_Wrapper* wrapper = qobject_cast<RFontChooserWidget_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RFontChooserWidget_Wrapper* wrapper = dynamic_cast<RFontChooserWidget_Wrapper*>(obj);
          //RFontChooserWidget_Wrapper* wrapper = (RFontChooserWidget_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RFontChooserWidget: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RFontChooserWidget*)wrapper->getWrappedVoid();
          //return getWrapped_RFontChooserWidget(wrapper);
          return RFontChooserWidget_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RFontChooserWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RFontChooserWidget: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RFontChooserWidget_Type);
          //return fun.call().toInt()==RJSType::RFontChooserWidget_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RFontChooserWidget::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RGraphicsViewQt(RJSApi& handler, RGraphicsViewQt* v) {
          RGraphicsViewQt_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RGraphicsViewQt_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RGraphicsViewQt: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RGraphicsViewQt_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RGraphicsViewQt_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RGraphicsViewQt('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RGraphicsViewQt");
          if (cl.isUndefined()) {
              qWarning() << "Class RGraphicsViewQt is undefined. Use RGraphicsViewQt_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RGraphicsViewQt('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RGraphicsViewQt(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RGraphicsViewQt(RJSApi& handler, const RGraphicsViewQt* v) {
          return RJSHelper_qcad::cpp2js_RGraphicsViewQt(handler, const_cast<RGraphicsViewQt*>(v));
      }

      RGraphicsViewQt* RJSHelper_qcad::js2cpp_RGraphicsViewQt_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RGraphicsViewQt: not a QObject";
              return nullptr;
          }
          //RGraphicsViewQt_Wrapper* wrapper = getWrapper<RGraphicsViewQt_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RGraphicsViewQt_Wrapper* wrapper = qobject_cast<RGraphicsViewQt_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RGraphicsViewQt_Wrapper* wrapper = dynamic_cast<RGraphicsViewQt_Wrapper*>(obj);
          //RGraphicsViewQt_Wrapper* wrapper = (RGraphicsViewQt_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RGraphicsViewQt: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RGraphicsViewQt*)wrapper->getWrappedVoid();
          //return getWrapped_RGraphicsViewQt(wrapper);
          return RGraphicsViewQt_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RGraphicsViewQt_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RGraphicsViewQt: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RGraphicsViewQt_Type);
          //return fun.call().toInt()==RJSType::RGraphicsViewQt_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RGraphicsViewQt::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RGraphicsViewImage(RJSApi& handler, RGraphicsViewImage* v) {
          RGraphicsViewImage_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RGraphicsViewImage_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RGraphicsViewImage: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RGraphicsViewImage_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RGraphicsViewImage_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RGraphicsViewImage('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RGraphicsViewImage");
          if (cl.isUndefined()) {
              qWarning() << "Class RGraphicsViewImage is undefined. Use RGraphicsViewImage_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RGraphicsViewImage('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RGraphicsViewImage(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RGraphicsViewImage(RJSApi& handler, const RGraphicsViewImage* v) {
          return RJSHelper_qcad::cpp2js_RGraphicsViewImage(handler, const_cast<RGraphicsViewImage*>(v));
      }

      RGraphicsViewImage* RJSHelper_qcad::js2cpp_RGraphicsViewImage_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RGraphicsViewImage: not a QObject";
              return nullptr;
          }
          //RGraphicsViewImage_Wrapper* wrapper = getWrapper<RGraphicsViewImage_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RGraphicsViewImage_Wrapper* wrapper = qobject_cast<RGraphicsViewImage_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RGraphicsViewImage_Wrapper* wrapper = dynamic_cast<RGraphicsViewImage_Wrapper*>(obj);
          //RGraphicsViewImage_Wrapper* wrapper = (RGraphicsViewImage_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RGraphicsViewImage: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RGraphicsViewImage*)wrapper->getWrappedVoid();
          //return getWrapped_RGraphicsViewImage(wrapper);
          return RGraphicsViewImage_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RGraphicsViewImage_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RGraphicsViewImage: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RGraphicsViewImage_Type);
          //return fun.call().toInt()==RJSType::RGraphicsViewImage_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RGraphicsViewImage::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RGraphicsViewWorker(RJSApi& handler, RGraphicsViewWorker* v) {
          RGraphicsViewWorker_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RGraphicsViewWorker_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RGraphicsViewWorker: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RGraphicsViewWorker_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RGraphicsViewWorker_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RGraphicsViewWorker('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RGraphicsViewWorker");
          if (cl.isUndefined()) {
              qWarning() << "Class RGraphicsViewWorker is undefined. Use RGraphicsViewWorker_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RGraphicsViewWorker('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RGraphicsViewWorker(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RGraphicsViewWorker(RJSApi& handler, const RGraphicsViewWorker* v) {
          return RJSHelper_qcad::cpp2js_RGraphicsViewWorker(handler, const_cast<RGraphicsViewWorker*>(v));
      }

      RGraphicsViewWorker* RJSHelper_qcad::js2cpp_RGraphicsViewWorker_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RGraphicsViewWorker: not a QObject";
              return nullptr;
          }
          //RGraphicsViewWorker_Wrapper* wrapper = getWrapper<RGraphicsViewWorker_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RGraphicsViewWorker_Wrapper* wrapper = qobject_cast<RGraphicsViewWorker_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RGraphicsViewWorker_Wrapper* wrapper = dynamic_cast<RGraphicsViewWorker_Wrapper*>(obj);
          //RGraphicsViewWorker_Wrapper* wrapper = (RGraphicsViewWorker_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RGraphicsViewWorker: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RGraphicsViewWorker*)wrapper->getWrappedVoid();
          //return getWrapped_RGraphicsViewWorker(wrapper);
          return RGraphicsViewWorker_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RGraphicsViewWorker_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RGraphicsViewWorker: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RGraphicsViewWorker_Type);
          //return fun.call().toInt()==RJSType::RGraphicsViewWorker_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RGraphicsViewWorker::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RGuiAction(RJSApi& handler, RGuiAction* v) {
          RGuiAction_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RGuiAction_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RGuiAction: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RGuiAction_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RGuiAction_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RGuiAction('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RGuiAction");
          if (cl.isUndefined()) {
              qWarning() << "Class RGuiAction is undefined. Use RGuiAction_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RGuiAction('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RGuiAction(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RGuiAction(RJSApi& handler, const RGuiAction* v) {
          return RJSHelper_qcad::cpp2js_RGuiAction(handler, const_cast<RGuiAction*>(v));
      }

      RGuiAction* RJSHelper_qcad::js2cpp_RGuiAction_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RGuiAction: not a QObject";
              return nullptr;
          }
          //RGuiAction_Wrapper* wrapper = getWrapper<RGuiAction_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RGuiAction_Wrapper* wrapper = qobject_cast<RGuiAction_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RGuiAction_Wrapper* wrapper = dynamic_cast<RGuiAction_Wrapper*>(obj);
          //RGuiAction_Wrapper* wrapper = (RGuiAction_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RGuiAction: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RGuiAction*)wrapper->getWrappedVoid();
          //return getWrapped_RGuiAction(wrapper);
          return RGuiAction_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RGuiAction_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RGuiAction: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RGuiAction_Type);
          //return fun.call().toInt()==RJSType::RGuiAction_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RGuiAction::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RImportListenerAdapter(RJSApi& handler, RImportListenerAdapter* v) {
          RImportListenerAdapter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RImportListenerAdapter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RImportListenerAdapter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RImportListenerAdapter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RImportListenerAdapter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RImportListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RImportListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RImportListenerAdapter is undefined. Use RImportListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RImportListenerAdapter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RImportListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RImportListenerAdapter(RJSApi& handler, const RImportListenerAdapter* v) {
          return RJSHelper_qcad::cpp2js_RImportListenerAdapter(handler, const_cast<RImportListenerAdapter*>(v));
      }

      RImportListenerAdapter* RJSHelper_qcad::js2cpp_RImportListenerAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RImportListenerAdapter: not a QObject";
              return nullptr;
          }
          //RImportListenerAdapter_Wrapper* wrapper = getWrapper<RImportListenerAdapter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RImportListenerAdapter_Wrapper* wrapper = qobject_cast<RImportListenerAdapter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RImportListenerAdapter_Wrapper* wrapper = dynamic_cast<RImportListenerAdapter_Wrapper*>(obj);
          //RImportListenerAdapter_Wrapper* wrapper = (RImportListenerAdapter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RImportListenerAdapter: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RImportListenerAdapter*)wrapper->getWrappedVoid();
          //return getWrapped_RImportListenerAdapter(wrapper);
          return RImportListenerAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RImportListenerAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RImportListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RImportListenerAdapter_Type);
          //return fun.call().toInt()==RJSType::RImportListenerAdapter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RImportListenerAdapter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RInterTransactionListenerAdapter(RJSApi& handler, RInterTransactionListenerAdapter* v) {
          RInterTransactionListenerAdapter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RInterTransactionListenerAdapter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RInterTransactionListenerAdapter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RInterTransactionListenerAdapter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RInterTransactionListenerAdapter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RInterTransactionListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RInterTransactionListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RInterTransactionListenerAdapter is undefined. Use RInterTransactionListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RInterTransactionListenerAdapter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RInterTransactionListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RInterTransactionListenerAdapter(RJSApi& handler, const RInterTransactionListenerAdapter* v) {
          return RJSHelper_qcad::cpp2js_RInterTransactionListenerAdapter(handler, const_cast<RInterTransactionListenerAdapter*>(v));
      }

      RInterTransactionListenerAdapter* RJSHelper_qcad::js2cpp_RInterTransactionListenerAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RInterTransactionListenerAdapter: not a QObject";
              return nullptr;
          }
          //RInterTransactionListenerAdapter_Wrapper* wrapper = getWrapper<RInterTransactionListenerAdapter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RInterTransactionListenerAdapter_Wrapper* wrapper = qobject_cast<RInterTransactionListenerAdapter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RInterTransactionListenerAdapter_Wrapper* wrapper = dynamic_cast<RInterTransactionListenerAdapter_Wrapper*>(obj);
          //RInterTransactionListenerAdapter_Wrapper* wrapper = (RInterTransactionListenerAdapter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RInterTransactionListenerAdapter: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RInterTransactionListenerAdapter*)wrapper->getWrappedVoid();
          //return getWrapped_RInterTransactionListenerAdapter(wrapper);
          return RInterTransactionListenerAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RInterTransactionListenerAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RInterTransactionListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RInterTransactionListenerAdapter_Type);
          //return fun.call().toInt()==RJSType::RInterTransactionListenerAdapter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RInterTransactionListenerAdapter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RKeyListenerAdapter(RJSApi& handler, RKeyListenerAdapter* v) {
          RKeyListenerAdapter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RKeyListenerAdapter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RKeyListenerAdapter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RKeyListenerAdapter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RKeyListenerAdapter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RKeyListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RKeyListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RKeyListenerAdapter is undefined. Use RKeyListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RKeyListenerAdapter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RKeyListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RKeyListenerAdapter(RJSApi& handler, const RKeyListenerAdapter* v) {
          return RJSHelper_qcad::cpp2js_RKeyListenerAdapter(handler, const_cast<RKeyListenerAdapter*>(v));
      }

      RKeyListenerAdapter* RJSHelper_qcad::js2cpp_RKeyListenerAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RKeyListenerAdapter: not a QObject";
              return nullptr;
          }
          //RKeyListenerAdapter_Wrapper* wrapper = getWrapper<RKeyListenerAdapter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RKeyListenerAdapter_Wrapper* wrapper = qobject_cast<RKeyListenerAdapter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RKeyListenerAdapter_Wrapper* wrapper = dynamic_cast<RKeyListenerAdapter_Wrapper*>(obj);
          //RKeyListenerAdapter_Wrapper* wrapper = (RKeyListenerAdapter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RKeyListenerAdapter: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RKeyListenerAdapter*)wrapper->getWrappedVoid();
          //return getWrapped_RKeyListenerAdapter(wrapper);
          return RKeyListenerAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RKeyListenerAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RKeyListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RKeyListenerAdapter_Type);
          //return fun.call().toInt()==RJSType::RKeyListenerAdapter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RKeyListenerAdapter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RLayerListenerAdapter(RJSApi& handler, RLayerListenerAdapter* v) {
          RLayerListenerAdapter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RLayerListenerAdapter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RLayerListenerAdapter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RLayerListenerAdapter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RLayerListenerAdapter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RLayerListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLayerListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RLayerListenerAdapter is undefined. Use RLayerListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLayerListenerAdapter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLayerListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RLayerListenerAdapter(RJSApi& handler, const RLayerListenerAdapter* v) {
          return RJSHelper_qcad::cpp2js_RLayerListenerAdapter(handler, const_cast<RLayerListenerAdapter*>(v));
      }

      RLayerListenerAdapter* RJSHelper_qcad::js2cpp_RLayerListenerAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLayerListenerAdapter: not a QObject";
              return nullptr;
          }
          //RLayerListenerAdapter_Wrapper* wrapper = getWrapper<RLayerListenerAdapter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RLayerListenerAdapter_Wrapper* wrapper = qobject_cast<RLayerListenerAdapter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RLayerListenerAdapter_Wrapper* wrapper = dynamic_cast<RLayerListenerAdapter_Wrapper*>(obj);
          //RLayerListenerAdapter_Wrapper* wrapper = (RLayerListenerAdapter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLayerListenerAdapter: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RLayerListenerAdapter*)wrapper->getWrappedVoid();
          //return getWrapped_RLayerListenerAdapter(wrapper);
          return RLayerListenerAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RLayerListenerAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLayerListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RLayerListenerAdapter_Type);
          //return fun.call().toInt()==RJSType::RLayerListenerAdapter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RLayerListenerAdapter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RLinetypeCombo(RJSApi& handler, RLinetypeCombo* v) {
          RLinetypeCombo_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RLinetypeCombo_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RLinetypeCombo: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RLinetypeCombo_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RLinetypeCombo_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RLinetypeCombo('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLinetypeCombo");
          if (cl.isUndefined()) {
              qWarning() << "Class RLinetypeCombo is undefined. Use RLinetypeCombo_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLinetypeCombo('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLinetypeCombo(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RLinetypeCombo(RJSApi& handler, const RLinetypeCombo* v) {
          return RJSHelper_qcad::cpp2js_RLinetypeCombo(handler, const_cast<RLinetypeCombo*>(v));
      }

      RLinetypeCombo* RJSHelper_qcad::js2cpp_RLinetypeCombo_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLinetypeCombo: not a QObject";
              return nullptr;
          }
          //RLinetypeCombo_Wrapper* wrapper = getWrapper<RLinetypeCombo_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RLinetypeCombo_Wrapper* wrapper = qobject_cast<RLinetypeCombo_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RLinetypeCombo_Wrapper* wrapper = dynamic_cast<RLinetypeCombo_Wrapper*>(obj);
          //RLinetypeCombo_Wrapper* wrapper = (RLinetypeCombo_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLinetypeCombo: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RLinetypeCombo*)wrapper->getWrappedVoid();
          //return getWrapped_RLinetypeCombo(wrapper);
          return RLinetypeCombo_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RLinetypeCombo_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLinetypeCombo: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RLinetypeCombo_Type);
          //return fun.call().toInt()==RJSType::RLinetypeCombo_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RLinetypeCombo::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RLineweightCombo(RJSApi& handler, RLineweightCombo* v) {
          RLineweightCombo_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RLineweightCombo_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RLineweightCombo: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RLineweightCombo_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RLineweightCombo_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RLineweightCombo('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLineweightCombo");
          if (cl.isUndefined()) {
              qWarning() << "Class RLineweightCombo is undefined. Use RLineweightCombo_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RLineweightCombo('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RLineweightCombo(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RLineweightCombo(RJSApi& handler, const RLineweightCombo* v) {
          return RJSHelper_qcad::cpp2js_RLineweightCombo(handler, const_cast<RLineweightCombo*>(v));
      }

      RLineweightCombo* RJSHelper_qcad::js2cpp_RLineweightCombo_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RLineweightCombo: not a QObject";
              return nullptr;
          }
          //RLineweightCombo_Wrapper* wrapper = getWrapper<RLineweightCombo_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RLineweightCombo_Wrapper* wrapper = qobject_cast<RLineweightCombo_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RLineweightCombo_Wrapper* wrapper = dynamic_cast<RLineweightCombo_Wrapper*>(obj);
          //RLineweightCombo_Wrapper* wrapper = (RLineweightCombo_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RLineweightCombo: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RLineweightCombo*)wrapper->getWrappedVoid();
          //return getWrapped_RLineweightCombo(wrapper);
          return RLineweightCombo_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RLineweightCombo_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RLineweightCombo: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RLineweightCombo_Type);
          //return fun.call().toInt()==RJSType::RLineweightCombo_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RLineweightCombo::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RListView(RJSApi& handler, RListView* v) {
          RListView_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RListView_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RListView: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RListView_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RListView_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RListView('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RListView");
          if (cl.isUndefined()) {
              qWarning() << "Class RListView is undefined. Use RListView_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RListView('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RListView(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RListView(RJSApi& handler, const RListView* v) {
          return RJSHelper_qcad::cpp2js_RListView(handler, const_cast<RListView*>(v));
      }

      RListView* RJSHelper_qcad::js2cpp_RListView_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RListView: not a QObject";
              return nullptr;
          }
          //RListView_Wrapper* wrapper = getWrapper<RListView_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RListView_Wrapper* wrapper = qobject_cast<RListView_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RListView_Wrapper* wrapper = dynamic_cast<RListView_Wrapper*>(obj);
          //RListView_Wrapper* wrapper = (RListView_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RListView: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RListView*)wrapper->getWrappedVoid();
          //return getWrapped_RListView(wrapper);
          return RListView_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RListView_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RListView: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RListView_Type);
          //return fun.call().toInt()==RJSType::RListView_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RListView::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RListWidget(RJSApi& handler, RListWidget* v) {
          RListWidget_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RListWidget_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RListWidget: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RListWidget_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RListWidget_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RListWidget('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RListWidget");
          if (cl.isUndefined()) {
              qWarning() << "Class RListWidget is undefined. Use RListWidget_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RListWidget('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RListWidget(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RListWidget(RJSApi& handler, const RListWidget* v) {
          return RJSHelper_qcad::cpp2js_RListWidget(handler, const_cast<RListWidget*>(v));
      }

      RListWidget* RJSHelper_qcad::js2cpp_RListWidget_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RListWidget: not a QObject";
              return nullptr;
          }
          //RListWidget_Wrapper* wrapper = getWrapper<RListWidget_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RListWidget_Wrapper* wrapper = qobject_cast<RListWidget_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RListWidget_Wrapper* wrapper = dynamic_cast<RListWidget_Wrapper*>(obj);
          //RListWidget_Wrapper* wrapper = (RListWidget_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RListWidget: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RListWidget*)wrapper->getWrappedVoid();
          //return getWrapped_RListWidget(wrapper);
          return RListWidget_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RListWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RListWidget: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RListWidget_Type);
          //return fun.call().toInt()==RJSType::RListWidget_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RListWidget::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RMainWindowQt(RJSApi& handler, RMainWindowQt* v) {
          RMainWindowQt_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RMainWindowQt_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RMainWindowQt: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RMainWindowQt_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RMainWindowQt_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RMainWindowQt('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMainWindowQt");
          if (cl.isUndefined()) {
              qWarning() << "Class RMainWindowQt is undefined. Use RMainWindowQt_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMainWindowQt('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMainWindowQt(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RMainWindowQt(RJSApi& handler, const RMainWindowQt* v) {
          return RJSHelper_qcad::cpp2js_RMainWindowQt(handler, const_cast<RMainWindowQt*>(v));
      }

      RMainWindowQt* RJSHelper_qcad::js2cpp_RMainWindowQt_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RMainWindowQt: not a QObject";
              return nullptr;
          }
          //RMainWindowQt_Wrapper* wrapper = getWrapper<RMainWindowQt_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RMainWindowQt_Wrapper* wrapper = qobject_cast<RMainWindowQt_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RMainWindowQt_Wrapper* wrapper = dynamic_cast<RMainWindowQt_Wrapper*>(obj);
          //RMainWindowQt_Wrapper* wrapper = (RMainWindowQt_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMainWindowQt: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RMainWindowQt*)wrapper->getWrappedVoid();
          //return getWrapped_RMainWindowQt(wrapper);
          return RMainWindowQt_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RMainWindowQt_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RMainWindowQt: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RMainWindowQt_Type);
          //return fun.call().toInt()==RJSType::RMainWindowQt_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RMainWindowQt::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RMathComboBox(RJSApi& handler, RMathComboBox* v) {
          RMathComboBox_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RMathComboBox_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RMathComboBox: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RMathComboBox_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RMathComboBox_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RMathComboBox('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMathComboBox");
          if (cl.isUndefined()) {
              qWarning() << "Class RMathComboBox is undefined. Use RMathComboBox_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMathComboBox('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMathComboBox(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RMathComboBox(RJSApi& handler, const RMathComboBox* v) {
          return RJSHelper_qcad::cpp2js_RMathComboBox(handler, const_cast<RMathComboBox*>(v));
      }

      RMathComboBox* RJSHelper_qcad::js2cpp_RMathComboBox_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RMathComboBox: not a QObject";
              return nullptr;
          }
          //RMathComboBox_Wrapper* wrapper = getWrapper<RMathComboBox_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RMathComboBox_Wrapper* wrapper = qobject_cast<RMathComboBox_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RMathComboBox_Wrapper* wrapper = dynamic_cast<RMathComboBox_Wrapper*>(obj);
          //RMathComboBox_Wrapper* wrapper = (RMathComboBox_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMathComboBox: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RMathComboBox*)wrapper->getWrappedVoid();
          //return getWrapped_RMathComboBox(wrapper);
          return RMathComboBox_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RMathComboBox_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RMathComboBox: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RMathComboBox_Type);
          //return fun.call().toInt()==RJSType::RMathComboBox_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RMathComboBox::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RMathLineEdit(RJSApi& handler, RMathLineEdit* v) {
          RMathLineEdit_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RMathLineEdit_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RMathLineEdit: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RMathLineEdit_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RMathLineEdit_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RMathLineEdit('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMathLineEdit");
          if (cl.isUndefined()) {
              qWarning() << "Class RMathLineEdit is undefined. Use RMathLineEdit_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMathLineEdit('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMathLineEdit(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RMathLineEdit(RJSApi& handler, const RMathLineEdit* v) {
          return RJSHelper_qcad::cpp2js_RMathLineEdit(handler, const_cast<RMathLineEdit*>(v));
      }

      RMathLineEdit* RJSHelper_qcad::js2cpp_RMathLineEdit_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RMathLineEdit: not a QObject";
              return nullptr;
          }
          //RMathLineEdit_Wrapper* wrapper = getWrapper<RMathLineEdit_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RMathLineEdit_Wrapper* wrapper = qobject_cast<RMathLineEdit_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RMathLineEdit_Wrapper* wrapper = dynamic_cast<RMathLineEdit_Wrapper*>(obj);
          //RMathLineEdit_Wrapper* wrapper = (RMathLineEdit_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMathLineEdit: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RMathLineEdit*)wrapper->getWrappedVoid();
          //return getWrapped_RMathLineEdit(wrapper);
          return RMathLineEdit_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RMathLineEdit_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RMathLineEdit: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RMathLineEdit_Type);
          //return fun.call().toInt()==RJSType::RMathLineEdit_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RMathLineEdit::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RMdiArea(RJSApi& handler, RMdiArea* v) {
          RMdiArea_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RMdiArea_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RMdiArea: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RMdiArea_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RMdiArea_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RMdiArea('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMdiArea");
          if (cl.isUndefined()) {
              qWarning() << "Class RMdiArea is undefined. Use RMdiArea_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMdiArea('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMdiArea(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RMdiArea(RJSApi& handler, const RMdiArea* v) {
          return RJSHelper_qcad::cpp2js_RMdiArea(handler, const_cast<RMdiArea*>(v));
      }

      RMdiArea* RJSHelper_qcad::js2cpp_RMdiArea_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RMdiArea: not a QObject";
              return nullptr;
          }
          //RMdiArea_Wrapper* wrapper = getWrapper<RMdiArea_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RMdiArea_Wrapper* wrapper = qobject_cast<RMdiArea_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RMdiArea_Wrapper* wrapper = dynamic_cast<RMdiArea_Wrapper*>(obj);
          //RMdiArea_Wrapper* wrapper = (RMdiArea_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMdiArea: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RMdiArea*)wrapper->getWrappedVoid();
          //return getWrapped_RMdiArea(wrapper);
          return RMdiArea_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RMdiArea_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RMdiArea: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RMdiArea_Type);
          //return fun.call().toInt()==RJSType::RMdiArea_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RMdiArea::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RMdiChildQt(RJSApi& handler, RMdiChildQt* v) {
          RMdiChildQt_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RMdiChildQt_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RMdiChildQt: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RMdiChildQt_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RMdiChildQt_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RMdiChildQt('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RMdiChildQt");
          if (cl.isUndefined()) {
              qWarning() << "Class RMdiChildQt is undefined. Use RMdiChildQt_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RMdiChildQt('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RMdiChildQt(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RMdiChildQt(RJSApi& handler, const RMdiChildQt* v) {
          return RJSHelper_qcad::cpp2js_RMdiChildQt(handler, const_cast<RMdiChildQt*>(v));
      }

      RMdiChildQt* RJSHelper_qcad::js2cpp_RMdiChildQt_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RMdiChildQt: not a QObject";
              return nullptr;
          }
          //RMdiChildQt_Wrapper* wrapper = getWrapper<RMdiChildQt_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RMdiChildQt_Wrapper* wrapper = qobject_cast<RMdiChildQt_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RMdiChildQt_Wrapper* wrapper = dynamic_cast<RMdiChildQt_Wrapper*>(obj);
          //RMdiChildQt_Wrapper* wrapper = (RMdiChildQt_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RMdiChildQt: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RMdiChildQt*)wrapper->getWrappedVoid();
          //return getWrapped_RMdiChildQt(wrapper);
          return RMdiChildQt_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RMdiChildQt_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RMdiChildQt: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RMdiChildQt_Type);
          //return fun.call().toInt()==RJSType::RMdiChildQt_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RMdiChildQt::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RPaletteListenerAdapter(RJSApi& handler, RPaletteListenerAdapter* v) {
          RPaletteListenerAdapter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RPaletteListenerAdapter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RPaletteListenerAdapter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RPaletteListenerAdapter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RPaletteListenerAdapter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RPaletteListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPaletteListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RPaletteListenerAdapter is undefined. Use RPaletteListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPaletteListenerAdapter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPaletteListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPaletteListenerAdapter(RJSApi& handler, const RPaletteListenerAdapter* v) {
          return RJSHelper_qcad::cpp2js_RPaletteListenerAdapter(handler, const_cast<RPaletteListenerAdapter*>(v));
      }

      RPaletteListenerAdapter* RJSHelper_qcad::js2cpp_RPaletteListenerAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPaletteListenerAdapter: not a QObject";
              return nullptr;
          }
          //RPaletteListenerAdapter_Wrapper* wrapper = getWrapper<RPaletteListenerAdapter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RPaletteListenerAdapter_Wrapper* wrapper = qobject_cast<RPaletteListenerAdapter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPaletteListenerAdapter_Wrapper* wrapper = dynamic_cast<RPaletteListenerAdapter_Wrapper*>(obj);
          //RPaletteListenerAdapter_Wrapper* wrapper = (RPaletteListenerAdapter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPaletteListenerAdapter: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RPaletteListenerAdapter*)wrapper->getWrappedVoid();
          //return getWrapped_RPaletteListenerAdapter(wrapper);
          return RPaletteListenerAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPaletteListenerAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPaletteListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RPaletteListenerAdapter_Type);
          //return fun.call().toInt()==RJSType::RPaletteListenerAdapter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RPaletteListenerAdapter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RPenListenerAdapter(RJSApi& handler, RPenListenerAdapter* v) {
          RPenListenerAdapter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RPenListenerAdapter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RPenListenerAdapter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RPenListenerAdapter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RPenListenerAdapter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RPenListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPenListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RPenListenerAdapter is undefined. Use RPenListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPenListenerAdapter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPenListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPenListenerAdapter(RJSApi& handler, const RPenListenerAdapter* v) {
          return RJSHelper_qcad::cpp2js_RPenListenerAdapter(handler, const_cast<RPenListenerAdapter*>(v));
      }

      RPenListenerAdapter* RJSHelper_qcad::js2cpp_RPenListenerAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPenListenerAdapter: not a QObject";
              return nullptr;
          }
          //RPenListenerAdapter_Wrapper* wrapper = getWrapper<RPenListenerAdapter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RPenListenerAdapter_Wrapper* wrapper = qobject_cast<RPenListenerAdapter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPenListenerAdapter_Wrapper* wrapper = dynamic_cast<RPenListenerAdapter_Wrapper*>(obj);
          //RPenListenerAdapter_Wrapper* wrapper = (RPenListenerAdapter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPenListenerAdapter: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RPenListenerAdapter*)wrapper->getWrappedVoid();
          //return getWrapped_RPenListenerAdapter(wrapper);
          return RPenListenerAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPenListenerAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPenListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RPenListenerAdapter_Type);
          //return fun.call().toInt()==RJSType::RPenListenerAdapter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RPenListenerAdapter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RPreferencesListenerAdapter(RJSApi& handler, RPreferencesListenerAdapter* v) {
          RPreferencesListenerAdapter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RPreferencesListenerAdapter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RPreferencesListenerAdapter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RPreferencesListenerAdapter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RPreferencesListenerAdapter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RPreferencesListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPreferencesListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RPreferencesListenerAdapter is undefined. Use RPreferencesListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPreferencesListenerAdapter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPreferencesListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPreferencesListenerAdapter(RJSApi& handler, const RPreferencesListenerAdapter* v) {
          return RJSHelper_qcad::cpp2js_RPreferencesListenerAdapter(handler, const_cast<RPreferencesListenerAdapter*>(v));
      }

      RPreferencesListenerAdapter* RJSHelper_qcad::js2cpp_RPreferencesListenerAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPreferencesListenerAdapter: not a QObject";
              return nullptr;
          }
          //RPreferencesListenerAdapter_Wrapper* wrapper = getWrapper<RPreferencesListenerAdapter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RPreferencesListenerAdapter_Wrapper* wrapper = qobject_cast<RPreferencesListenerAdapter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPreferencesListenerAdapter_Wrapper* wrapper = dynamic_cast<RPreferencesListenerAdapter_Wrapper*>(obj);
          //RPreferencesListenerAdapter_Wrapper* wrapper = (RPreferencesListenerAdapter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPreferencesListenerAdapter: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RPreferencesListenerAdapter*)wrapper->getWrappedVoid();
          //return getWrapped_RPreferencesListenerAdapter(wrapper);
          return RPreferencesListenerAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPreferencesListenerAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPreferencesListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RPreferencesListenerAdapter_Type);
          //return fun.call().toInt()==RJSType::RPreferencesListenerAdapter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RPreferencesListenerAdapter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RPropertyEditor(RJSApi& handler, RPropertyEditor* v) {
          RPropertyEditor_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RPropertyEditor_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RPropertyEditor: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RPropertyEditor_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RPropertyEditor_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RPropertyEditor('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPropertyEditor");
          if (cl.isUndefined()) {
              qWarning() << "Class RPropertyEditor is undefined. Use RPropertyEditor_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPropertyEditor('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPropertyEditor(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPropertyEditor(RJSApi& handler, const RPropertyEditor* v) {
          return RJSHelper_qcad::cpp2js_RPropertyEditor(handler, const_cast<RPropertyEditor*>(v));
      }

      RPropertyEditor* RJSHelper_qcad::js2cpp_RPropertyEditor_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPropertyEditor: not a QObject";
              return nullptr;
          }
          //RPropertyEditor_Wrapper* wrapper = getWrapper<RPropertyEditor_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RPropertyEditor_Wrapper* wrapper = qobject_cast<RPropertyEditor_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPropertyEditor_Wrapper* wrapper = dynamic_cast<RPropertyEditor_Wrapper*>(obj);
          //RPropertyEditor_Wrapper* wrapper = (RPropertyEditor_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPropertyEditor: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RPropertyEditor*)wrapper->getWrappedVoid();
          //return getWrapped_RPropertyEditor(wrapper);
          return RPropertyEditor_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPropertyEditor_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPropertyEditor: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RPropertyEditor_Type);
          //return fun.call().toInt()==RJSType::RPropertyEditor_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RPropertyEditor::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RPropertyListenerAdapter(RJSApi& handler, RPropertyListenerAdapter* v) {
          RPropertyListenerAdapter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RPropertyListenerAdapter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RPropertyListenerAdapter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RPropertyListenerAdapter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RPropertyListenerAdapter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RPropertyListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPropertyListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RPropertyListenerAdapter is undefined. Use RPropertyListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RPropertyListenerAdapter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RPropertyListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RPropertyListenerAdapter(RJSApi& handler, const RPropertyListenerAdapter* v) {
          return RJSHelper_qcad::cpp2js_RPropertyListenerAdapter(handler, const_cast<RPropertyListenerAdapter*>(v));
      }

      RPropertyListenerAdapter* RJSHelper_qcad::js2cpp_RPropertyListenerAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RPropertyListenerAdapter: not a QObject";
              return nullptr;
          }
          //RPropertyListenerAdapter_Wrapper* wrapper = getWrapper<RPropertyListenerAdapter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RPropertyListenerAdapter_Wrapper* wrapper = qobject_cast<RPropertyListenerAdapter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RPropertyListenerAdapter_Wrapper* wrapper = dynamic_cast<RPropertyListenerAdapter_Wrapper*>(obj);
          //RPropertyListenerAdapter_Wrapper* wrapper = (RPropertyListenerAdapter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RPropertyListenerAdapter: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RPropertyListenerAdapter*)wrapper->getWrappedVoid();
          //return getWrapped_RPropertyListenerAdapter(wrapper);
          return RPropertyListenerAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RPropertyListenerAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RPropertyListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RPropertyListenerAdapter_Type);
          //return fun.call().toInt()==RJSType::RPropertyListenerAdapter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RPropertyListenerAdapter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RRulerQt(RJSApi& handler, RRulerQt* v) {
          RRulerQt_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RRulerQt_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RRulerQt: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RRulerQt_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RRulerQt_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RRulerQt('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRulerQt");
          if (cl.isUndefined()) {
              qWarning() << "Class RRulerQt is undefined. Use RRulerQt_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RRulerQt('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RRulerQt(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RRulerQt(RJSApi& handler, const RRulerQt* v) {
          return RJSHelper_qcad::cpp2js_RRulerQt(handler, const_cast<RRulerQt*>(v));
      }

      RRulerQt* RJSHelper_qcad::js2cpp_RRulerQt_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RRulerQt: not a QObject";
              return nullptr;
          }
          //RRulerQt_Wrapper* wrapper = getWrapper<RRulerQt_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RRulerQt_Wrapper* wrapper = qobject_cast<RRulerQt_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RRulerQt_Wrapper* wrapper = dynamic_cast<RRulerQt_Wrapper*>(obj);
          //RRulerQt_Wrapper* wrapper = (RRulerQt_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RRulerQt: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RRulerQt*)wrapper->getWrappedVoid();
          //return getWrapped_RRulerQt(wrapper);
          return RRulerQt_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RRulerQt_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RRulerQt: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RRulerQt_Type);
          //return fun.call().toInt()==RJSType::RRulerQt_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RRulerQt::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RSelectionListenerAdapter(RJSApi& handler, RSelectionListenerAdapter* v) {
          RSelectionListenerAdapter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RSelectionListenerAdapter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RSelectionListenerAdapter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RSelectionListenerAdapter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RSelectionListenerAdapter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RSelectionListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSelectionListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RSelectionListenerAdapter is undefined. Use RSelectionListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSelectionListenerAdapter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSelectionListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RSelectionListenerAdapter(RJSApi& handler, const RSelectionListenerAdapter* v) {
          return RJSHelper_qcad::cpp2js_RSelectionListenerAdapter(handler, const_cast<RSelectionListenerAdapter*>(v));
      }

      RSelectionListenerAdapter* RJSHelper_qcad::js2cpp_RSelectionListenerAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSelectionListenerAdapter: not a QObject";
              return nullptr;
          }
          //RSelectionListenerAdapter_Wrapper* wrapper = getWrapper<RSelectionListenerAdapter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RSelectionListenerAdapter_Wrapper* wrapper = qobject_cast<RSelectionListenerAdapter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSelectionListenerAdapter_Wrapper* wrapper = dynamic_cast<RSelectionListenerAdapter_Wrapper*>(obj);
          //RSelectionListenerAdapter_Wrapper* wrapper = (RSelectionListenerAdapter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSelectionListenerAdapter: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RSelectionListenerAdapter*)wrapper->getWrappedVoid();
          //return getWrapped_RSelectionListenerAdapter(wrapper);
          return RSelectionListenerAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSelectionListenerAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSelectionListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RSelectionListenerAdapter_Type);
          //return fun.call().toInt()==RJSType::RSelectionListenerAdapter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RSelectionListenerAdapter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RSingleApplication(RJSApi& handler, RSingleApplication* v) {
          RSingleApplication_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RSingleApplication_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RSingleApplication: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RSingleApplication_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RSingleApplication_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RSingleApplication('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSingleApplication");
          if (cl.isUndefined()) {
              qWarning() << "Class RSingleApplication is undefined. Use RSingleApplication_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RSingleApplication('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RSingleApplication(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RSingleApplication(RJSApi& handler, const RSingleApplication* v) {
          return RJSHelper_qcad::cpp2js_RSingleApplication(handler, const_cast<RSingleApplication*>(v));
      }

      RSingleApplication* RJSHelper_qcad::js2cpp_RSingleApplication_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RSingleApplication: not a QObject";
              return nullptr;
          }
          //RSingleApplication_Wrapper* wrapper = getWrapper<RSingleApplication_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RSingleApplication_Wrapper* wrapper = qobject_cast<RSingleApplication_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RSingleApplication_Wrapper* wrapper = dynamic_cast<RSingleApplication_Wrapper*>(obj);
          //RSingleApplication_Wrapper* wrapper = (RSingleApplication_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RSingleApplication: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RSingleApplication*)wrapper->getWrappedVoid();
          //return getWrapped_RSingleApplication(wrapper);
          return RSingleApplication_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RSingleApplication_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RSingleApplication: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RSingleApplication_Type);
          //return fun.call().toInt()==RJSType::RSingleApplication_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RSingleApplication::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RTextEdit(RJSApi& handler, RTextEdit* v) {
          RTextEdit_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RTextEdit_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RTextEdit: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RTextEdit_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RTextEdit_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RTextEdit('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTextEdit");
          if (cl.isUndefined()) {
              qWarning() << "Class RTextEdit is undefined. Use RTextEdit_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTextEdit('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTextEdit(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RTextEdit(RJSApi& handler, const RTextEdit* v) {
          return RJSHelper_qcad::cpp2js_RTextEdit(handler, const_cast<RTextEdit*>(v));
      }

      RTextEdit* RJSHelper_qcad::js2cpp_RTextEdit_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTextEdit: not a QObject";
              return nullptr;
          }
          //RTextEdit_Wrapper* wrapper = getWrapper<RTextEdit_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RTextEdit_Wrapper* wrapper = qobject_cast<RTextEdit_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RTextEdit_Wrapper* wrapper = dynamic_cast<RTextEdit_Wrapper*>(obj);
          //RTextEdit_Wrapper* wrapper = (RTextEdit_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTextEdit: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RTextEdit*)wrapper->getWrappedVoid();
          //return getWrapped_RTextEdit(wrapper);
          return RTextEdit_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RTextEdit_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTextEdit: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RTextEdit_Type);
          //return fun.call().toInt()==RJSType::RTextEdit_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RTextEdit::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RToolButton(RJSApi& handler, RToolButton* v) {
          RToolButton_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RToolButton_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RToolButton: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RToolButton_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RToolButton_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RToolButton('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RToolButton");
          if (cl.isUndefined()) {
              qWarning() << "Class RToolButton is undefined. Use RToolButton_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RToolButton('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RToolButton(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RToolButton(RJSApi& handler, const RToolButton* v) {
          return RJSHelper_qcad::cpp2js_RToolButton(handler, const_cast<RToolButton*>(v));
      }

      RToolButton* RJSHelper_qcad::js2cpp_RToolButton_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RToolButton: not a QObject";
              return nullptr;
          }
          //RToolButton_Wrapper* wrapper = getWrapper<RToolButton_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RToolButton_Wrapper* wrapper = qobject_cast<RToolButton_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RToolButton_Wrapper* wrapper = dynamic_cast<RToolButton_Wrapper*>(obj);
          //RToolButton_Wrapper* wrapper = (RToolButton_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RToolButton: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RToolButton*)wrapper->getWrappedVoid();
          //return getWrapped_RToolButton(wrapper);
          return RToolButton_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RToolButton_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RToolButton: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RToolButton_Type);
          //return fun.call().toInt()==RJSType::RToolButton_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RToolButton::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RToolMatrixItemDelegate(RJSApi& handler, RToolMatrixItemDelegate* v) {
          RToolMatrixItemDelegate_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RToolMatrixItemDelegate_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RToolMatrixItemDelegate: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RToolMatrixItemDelegate_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RToolMatrixItemDelegate_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RToolMatrixItemDelegate('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RToolMatrixItemDelegate");
          if (cl.isUndefined()) {
              qWarning() << "Class RToolMatrixItemDelegate is undefined. Use RToolMatrixItemDelegate_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RToolMatrixItemDelegate('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RToolMatrixItemDelegate(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RToolMatrixItemDelegate(RJSApi& handler, const RToolMatrixItemDelegate* v) {
          return RJSHelper_qcad::cpp2js_RToolMatrixItemDelegate(handler, const_cast<RToolMatrixItemDelegate*>(v));
      }

      RToolMatrixItemDelegate* RJSHelper_qcad::js2cpp_RToolMatrixItemDelegate_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RToolMatrixItemDelegate: not a QObject";
              return nullptr;
          }
          //RToolMatrixItemDelegate_Wrapper* wrapper = getWrapper<RToolMatrixItemDelegate_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RToolMatrixItemDelegate_Wrapper* wrapper = qobject_cast<RToolMatrixItemDelegate_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RToolMatrixItemDelegate_Wrapper* wrapper = dynamic_cast<RToolMatrixItemDelegate_Wrapper*>(obj);
          //RToolMatrixItemDelegate_Wrapper* wrapper = (RToolMatrixItemDelegate_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RToolMatrixItemDelegate: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RToolMatrixItemDelegate*)wrapper->getWrappedVoid();
          //return getWrapped_RToolMatrixItemDelegate(wrapper);
          return RToolMatrixItemDelegate_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RToolMatrixItemDelegate_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RToolMatrixItemDelegate: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RToolMatrixItemDelegate_Type);
          //return fun.call().toInt()==RJSType::RToolMatrixItemDelegate_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RToolMatrixItemDelegate::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RTransactionListenerAdapter(RJSApi& handler, RTransactionListenerAdapter* v) {
          RTransactionListenerAdapter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RTransactionListenerAdapter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RTransactionListenerAdapter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RTransactionListenerAdapter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RTransactionListenerAdapter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RTransactionListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTransactionListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RTransactionListenerAdapter is undefined. Use RTransactionListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTransactionListenerAdapter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTransactionListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RTransactionListenerAdapter(RJSApi& handler, const RTransactionListenerAdapter* v) {
          return RJSHelper_qcad::cpp2js_RTransactionListenerAdapter(handler, const_cast<RTransactionListenerAdapter*>(v));
      }

      RTransactionListenerAdapter* RJSHelper_qcad::js2cpp_RTransactionListenerAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTransactionListenerAdapter: not a QObject";
              return nullptr;
          }
          //RTransactionListenerAdapter_Wrapper* wrapper = getWrapper<RTransactionListenerAdapter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RTransactionListenerAdapter_Wrapper* wrapper = qobject_cast<RTransactionListenerAdapter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RTransactionListenerAdapter_Wrapper* wrapper = dynamic_cast<RTransactionListenerAdapter_Wrapper*>(obj);
          //RTransactionListenerAdapter_Wrapper* wrapper = (RTransactionListenerAdapter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTransactionListenerAdapter: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RTransactionListenerAdapter*)wrapper->getWrappedVoid();
          //return getWrapped_RTransactionListenerAdapter(wrapper);
          return RTransactionListenerAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RTransactionListenerAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTransactionListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RTransactionListenerAdapter_Type);
          //return fun.call().toInt()==RJSType::RTransactionListenerAdapter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RTransactionListenerAdapter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RTreeWidget(RJSApi& handler, RTreeWidget* v) {
          RTreeWidget_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RTreeWidget_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RTreeWidget: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RTreeWidget_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RTreeWidget_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RTreeWidget('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTreeWidget");
          if (cl.isUndefined()) {
              qWarning() << "Class RTreeWidget is undefined. Use RTreeWidget_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RTreeWidget('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RTreeWidget(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RTreeWidget(RJSApi& handler, const RTreeWidget* v) {
          return RJSHelper_qcad::cpp2js_RTreeWidget(handler, const_cast<RTreeWidget*>(v));
      }

      RTreeWidget* RJSHelper_qcad::js2cpp_RTreeWidget_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RTreeWidget: not a QObject";
              return nullptr;
          }
          //RTreeWidget_Wrapper* wrapper = getWrapper<RTreeWidget_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RTreeWidget_Wrapper* wrapper = qobject_cast<RTreeWidget_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RTreeWidget_Wrapper* wrapper = dynamic_cast<RTreeWidget_Wrapper*>(obj);
          //RTreeWidget_Wrapper* wrapper = (RTreeWidget_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RTreeWidget: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RTreeWidget*)wrapper->getWrappedVoid();
          //return getWrapped_RTreeWidget(wrapper);
          return RTreeWidget_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RTreeWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RTreeWidget: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RTreeWidget_Type);
          //return fun.call().toInt()==RJSType::RTreeWidget_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RTreeWidget::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RViewListenerAdapter(RJSApi& handler, RViewListenerAdapter* v) {
          RViewListenerAdapter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RViewListenerAdapter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RViewListenerAdapter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RViewListenerAdapter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RViewListenerAdapter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RViewListenerAdapter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RViewListenerAdapter");
          if (cl.isUndefined()) {
              qWarning() << "Class RViewListenerAdapter is undefined. Use RViewListenerAdapter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RViewListenerAdapter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RViewListenerAdapter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RViewListenerAdapter(RJSApi& handler, const RViewListenerAdapter* v) {
          return RJSHelper_qcad::cpp2js_RViewListenerAdapter(handler, const_cast<RViewListenerAdapter*>(v));
      }

      RViewListenerAdapter* RJSHelper_qcad::js2cpp_RViewListenerAdapter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RViewListenerAdapter: not a QObject";
              return nullptr;
          }
          //RViewListenerAdapter_Wrapper* wrapper = getWrapper<RViewListenerAdapter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RViewListenerAdapter_Wrapper* wrapper = qobject_cast<RViewListenerAdapter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RViewListenerAdapter_Wrapper* wrapper = dynamic_cast<RViewListenerAdapter_Wrapper*>(obj);
          //RViewListenerAdapter_Wrapper* wrapper = (RViewListenerAdapter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RViewListenerAdapter: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RViewListenerAdapter*)wrapper->getWrappedVoid();
          //return getWrapped_RViewListenerAdapter(wrapper);
          return RViewListenerAdapter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RViewListenerAdapter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RViewListenerAdapter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RViewListenerAdapter_Type);
          //return fun.call().toInt()==RJSType::RViewListenerAdapter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RViewListenerAdapter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper_qcad::cpp2js_RWidget(RJSApi& handler, RWidget* v) {
          
            // downcast to RCadToolBarPanel:
            {
                RCadToolBarPanel* o = qobject_cast<RCadToolBarPanel*>(v);
                if (o!=nullptr) {
                    return RJSHelper_qcad::cpp2js_RCadToolBarPanel(handler, o);
                }
            }
          RWidget_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<RWidget_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper_qcad::cpp2js_RWidget: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new RWidget_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new RWidget_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new RWidget('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RWidget");
          if (cl.isUndefined()) {
              qWarning() << "Class RWidget is undefined. Use RWidget_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new RWidget('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new RWidget(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper_qcad::cpp2js_RWidget(RJSApi& handler, const RWidget* v) {
          return RJSHelper_qcad::cpp2js_RWidget(handler, const_cast<RWidget*>(v));
      }

      RWidget* RJSHelper_qcad::js2cpp_RWidget_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_RWidget: not a QObject";
              return nullptr;
          }
          //RWidget_Wrapper* wrapper = getWrapper<RWidget_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //RWidget_Wrapper* wrapper = qobject_cast<RWidget_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //RWidget_Wrapper* wrapper = dynamic_cast<RWidget_Wrapper*>(obj);
          //RWidget_Wrapper* wrapper = (RWidget_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_RWidget: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (RWidget*)wrapper->getWrappedVoid();
          //return getWrapped_RWidget(wrapper);
          return RWidget_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper_qcad::is_RWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper_qcad::is_RWidget: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::RWidget_Type);
          //return fun.call().toInt()==RJSType::RWidget_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_RWidget::getIdStatic())).toBool();
      }

    