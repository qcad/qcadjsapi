
  // Automatically generated, do not edit
  
          #include "RJSHelper_qcad.h"
        
          #include "header_qcad_cpp.h"
        
        #include "raction_wrapper.h"
        
        #include "ractionadapter_wrapper.h"
        
          #include "raction_wrapper.h"
        
        #include "raddobjectoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "raddobjectsoperation_wrapper.h"
        
        #include "raddobjectsoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
        #include "rarc_wrapper.h"
        
          #include "rshape_wrapper.h"
        
        #include "rarcdata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rarc_wrapper.h"
        
        #include "rarcentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rattributedata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rtextbaseddata_wrapper.h"
        
        #include "rattributedefinitiondata_wrapper.h"
        
          #include "rtextbaseddata_wrapper.h"
        
        #include "rattributedefinitionentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rtextbasedentity_wrapper.h"
        
        #include "rattributeentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rtextbasedentity_wrapper.h"
        
        #include "rautoloadjs_wrapper.h"
        
        #include "rblock_wrapper.h"
        
          #include "robject_wrapper.h"
        
        #include "rblocklistener_wrapper.h"
        
        #include "rblocklisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rblocklistener_wrapper.h"
        
        #include "rblockreferencedata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
        #include "rblockreferenceentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rbox_wrapper.h"
        
        #include "rcadtoolbar_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qtoolbar_wrapper.h"
        
        #include "rcadtoolbarpanel_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rwidget_wrapper.h"
        
        #include "rchangepropertyoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
        #include "rcharacterwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "rcircle_wrapper.h"
        
          #include "rshape_wrapper.h"
        
        #include "rcircledata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rcircle_wrapper.h"
        
        #include "rcircleentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rclickreferencepointoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
        #include "rclipboardoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
        #include "rclosecurrentevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
        #include "rcolor_wrapper.h"
        
          #include "qcolor_wrapper.h"
        
        #include "rcolorcombo_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
        #include "rcombobox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
        #include "rcommandevent_wrapper.h"
        
        #include "rcommandline_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qlineedit_wrapper.h"
        
        #include "rcoordinateevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "rinputevent_wrapper.h"
        
        #include "rcoordinatelistener_wrapper.h"
        
        #include "rcoordinatelisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rcoordinatelistener_wrapper.h"
        
        #include "rcopyoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rclipboardoperation_wrapper.h"
        
        #include "rdebug_wrapper.h"
        
        #include "rdeleteallentitiesoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
        #include "rdeleteobjectoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rdeleteobjectsoperation_wrapper.h"
        
        #include "rdeleteobjectsoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
        #include "rdeleteselectionoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rclipboardoperation_wrapper.h"
        
        #include "rdimaligneddata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimlineardata_wrapper.h"
        
        #include "rdimalignedentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimlinearentity_wrapper.h"
        
        #include "rdimangular2ldata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimangulardata_wrapper.h"
        
        #include "rdimangular2lentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimangularentity_wrapper.h"
        
        #include "rdimangular3pdata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimangulardata_wrapper.h"
        
        #include "rdimangular3pentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimangularentity_wrapper.h"
        
        #include "rdimangulardata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
        #include "rdimangularentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
        #include "rdimarclengthdata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimangulardata_wrapper.h"
        
        #include "rdimarclengthentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimangularentity_wrapper.h"
        
        #include "rdimdiametricdata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
        #include "rdimdiametricentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
        #include "rdimlineardata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
        #include "rdimlinearentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
        #include "rdimordinatedata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
        #include "rdimordinateentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
        #include "rdimradialdata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
        #include "rdimradialentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
        #include "rdimrotateddata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rdimensiondata_wrapper.h"
        
          #include "rdimlineardata_wrapper.h"
        
        #include "rdimrotatedentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rdimensionentity_wrapper.h"
        
          #include "rdimlinearentity_wrapper.h"
        
        #include "rdimstyle_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rdimstyledata_wrapper.h"
        
        #include "rdimstyledata_wrapper.h"
        
        #include "rdimensiondata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
        #include "rdimensionentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rdirected_wrapper.h"
        
        #include "rdockwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qdockwidget_wrapper.h"
        
        #include "rdocument_wrapper.h"
        
        #include "rdocumentinterface_wrapper.h"
        
        #include "rdocumentvariables_wrapper.h"
        
          #include "robject_wrapper.h"
        
        #include "rdxfservices_wrapper.h"
        
        #include "rellipse_wrapper.h"
        
          #include "rshape_wrapper.h"
        
        #include "rellipsedata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rellipse_wrapper.h"
        
        #include "rellipseentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
        #include "rentitydata_wrapper.h"
        
        #include "rentityexportlistener_wrapper.h"
        
        #include "rentitypickevent_wrapper.h"
        
          #include "rinputevent_wrapper.h"
        
        #include "reventfilter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "reventhandler_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "rexplodable_wrapper.h"
        
        #include "rexportlistener_wrapper.h"
        
        #include "rexportlisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rexportlistener_wrapper.h"
        
        #include "rexporter_wrapper.h"
        
        #include "rfacedata_wrapper.h"
        
          #include "rsoliddata_wrapper.h"
        
        #include "rfaceentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rfilecache_wrapper.h"
        
        #include "rfileexporter_wrapper.h"
        
          #include "rexporter_wrapper.h"
        
        #include "rfileexporteradapter_wrapper.h"
        
          #include "rexporter_wrapper.h"
        
          #include "rfileexporter_wrapper.h"
        
        #include "rfileexporterfactory_wrapper.h"
        
        #include "rfileexporterfactoryadapter_wrapper.h"
        
          #include "rfileexporterfactory_wrapper.h"
        
        #include "rfileexporterregistry_wrapper.h"
        
        #include "rfileimporter_wrapper.h"
        
          #include "rimporter_wrapper.h"
        
        #include "rfileimporteradapter_wrapper.h"
        
          #include "rimporter_wrapper.h"
        
          #include "rfileimporter_wrapper.h"
        
        #include "rfileimporterfactory_wrapper.h"
        
        #include "rfileimporterfactoryadapter_wrapper.h"
        
          #include "rfileimporterfactory_wrapper.h"
        
        #include "rfileimporterregistry_wrapper.h"
        
        #include "rfilesystemmodel_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemmodel_wrapper.h"
        
          #include "qfilesystemmodel_wrapper.h"
        
        #include "rflowlayout_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
          #include "qlayout_wrapper.h"
        
        #include "rfocuslistener_wrapper.h"
        
        #include "rfocuslisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rfocuslistener_wrapper.h"
        
        #include "rfont_wrapper.h"
        
        #include "rfontchooserwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "rfontlist_wrapper.h"
        
        #include "rgraphicsscene_wrapper.h"
        
          #include "rexporter_wrapper.h"
        
        #include "rgraphicsscenedrawable_wrapper.h"
        
        #include "rgraphicssceneqt_wrapper.h"
        
          #include "rexporter_wrapper.h"
        
          #include "rgraphicsscene_wrapper.h"
        
        #include "rgraphicsview_wrapper.h"
        
        #include "rgraphicsviewimage_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rgraphicsview_wrapper.h"
        
        #include "rgraphicsviewqt_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "rgraphicsviewworker_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "rgrid_wrapper.h"
        
        #include "rguiaction_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rfocuslistener_wrapper.h"
        
          #include "rtransactionlistener_wrapper.h"
        
          #include "rselectionlistener_wrapper.h"
        
          #include "qaction_wrapper.h"
        
        #include "rhatchdata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
        #include "rhatchentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rimagedata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
        #include "rimageentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rimportlistener_wrapper.h"
        
        #include "rimportlisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rimportlistener_wrapper.h"
        
        #include "rimporter_wrapper.h"
        
        #include "rinputevent_wrapper.h"
        
        #include "rintertransactionlistener_wrapper.h"
        
        #include "rintertransactionlisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rintertransactionlistener_wrapper.h"
        
        #include "rkeylistener_wrapper.h"
        
        #include "rkeylisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rkeylistener_wrapper.h"
        
        #include "rlayer_wrapper.h"
        
          #include "robject_wrapper.h"
        
        #include "rlayerlistener_wrapper.h"
        
        #include "rlayerlisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rlayerlistener_wrapper.h"
        
        #include "rlayerstate_wrapper.h"
        
          #include "robject_wrapper.h"
        
        #include "rlayout_wrapper.h"
        
          #include "robject_wrapper.h"
        
        #include "rleaderdata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpolyline_wrapper.h"
        
        #include "rleaderentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rline_wrapper.h"
        
          #include "rshape_wrapper.h"
        
        #include "rlinedata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rline_wrapper.h"
        
        #include "rlineentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rlinetype_wrapper.h"
        
          #include "robject_wrapper.h"
        
        #include "rlinetypecombo_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
        #include "rlinetypepattern_wrapper.h"
        
        #include "rlineweight_wrapper.h"
        
        #include "rlineweightcombo_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
        #include "rlistview_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qlistview_wrapper.h"
        
        #include "rlistwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qlistview_wrapper.h"
        
          #include "qlistwidget_wrapper.h"
        
        #include "rmainwindow_wrapper.h"
        
        #include "rmainwindowqt_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rmainwindow_wrapper.h"
        
          #include "qmainwindow_wrapper.h"
        
        #include "rmath_wrapper.h"
        
        #include "rmathcombobox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
        #include "rmathlineedit_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qlineedit_wrapper.h"
        
        #include "rmatrix_wrapper.h"
        
        #include "rmdiarea_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qmdiarea_wrapper.h"
        
        #include "rmdichildqt_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rmodifiedlistener_wrapper.h"
        
          #include "qmdisubwindow_wrapper.h"
        
        #include "rmemorystorage_wrapper.h"
        
          #include "rstorage_wrapper.h"
        
        #include "rmessagehandler_wrapper.h"
        
        #include "rmixedoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
        #include "rmodifiedlistener_wrapper.h"
        
        #include "rmodifyobjectoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "raddobjectoperation_wrapper.h"
        
        #include "rmodifyobjectsoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "raddobjectsoperation_wrapper.h"
        
        #include "rmousecoordinatelistener_wrapper.h"
        
        #include "rmouseevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qinputevent_wrapper.h"
        
          #include "qpointerevent_wrapper.h"
        
          #include "qsinglepointevent_wrapper.h"
        
          #include "qmouseevent_wrapper.h"
        
          #include "rinputevent_wrapper.h"
        
        #include "rmovereferencepointoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
        #include "rmoveselectionoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
        #include "rnewdocumentlistener_wrapper.h"
        
        #include "robject_wrapper.h"
        
        #include "roperation_wrapper.h"
        
        #include "roperationutils_wrapper.h"
        
        #include "rorthogrid_wrapper.h"
        
          #include "rgrid_wrapper.h"
        
        #include "rpainterpath_wrapper.h"
        
          #include "qpainterpath_wrapper.h"
        
        #include "rpainterpathsource_wrapper.h"
        
        #include "rpalettelistener_wrapper.h"
        
        #include "rpalettelisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpalettelistener_wrapper.h"
        
        #include "rpasteoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
          #include "rclipboardoperation_wrapper.h"
        
        #include "rpattern_wrapper.h"
        
        #include "rpatternline_wrapper.h"
        
        #include "rpatternlist_wrapper.h"
        
        #include "rpatternlistimperial_wrapper.h"
        
          #include "rpatternlist_wrapper.h"
        
        #include "rpatternlistmetric_wrapper.h"
        
          #include "rpatternlist_wrapper.h"
        
        #include "rpenlistener_wrapper.h"
        
        #include "rpenlisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpenlistener_wrapper.h"
        
        #include "rplugininfo_wrapper.h"
        
        #include "rplugininterface_wrapper.h"
        
        #include "rpluginloader_wrapper.h"
        
        #include "rpoint_wrapper.h"
        
          #include "rshape_wrapper.h"
        
        #include "rpointdata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpoint_wrapper.h"
        
        #include "rpointentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rpolyline_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rexplodable_wrapper.h"
        
        #include "rpolylinedata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpolyline_wrapper.h"
        
        #include "rpolylineentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rpreferenceslistener_wrapper.h"
        
        #include "rpreferenceslisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpreferenceslistener_wrapper.h"
        
        #include "rprogresshandler_wrapper.h"
        
        #include "rpropertyattributes_wrapper.h"
        
        #include "rpropertychange_wrapper.h"
        
        #include "rpropertyeditor_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpropertylistener_wrapper.h"
        
          #include "rlayerlistener_wrapper.h"
        
        #include "rpropertyevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
        #include "rpropertylistener_wrapper.h"
        
        #include "rpropertylisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rpropertylistener_wrapper.h"
        
        #include "rpropertytypeid_wrapper.h"
        
        #include "rray_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rxline_wrapper.h"
        
        #include "rraydata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rray_wrapper.h"
        
        #include "rrayentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rrefpoint_wrapper.h"
        
          #include "rvector_wrapper.h"
        
        #include "rrestrictanglelength_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
        #include "rrestricthorizontal_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
          #include "rrestrictorthogonal_wrapper.h"
        
        #include "rrestrictoff_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
        #include "rrestrictorthogonal_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
        #include "rrestrictvertical_wrapper.h"
        
          #include "rsnaprestriction_wrapper.h"
        
          #include "rrestrictorthogonal_wrapper.h"
        
        #include "rruler_wrapper.h"
        
        #include "rrulerqt_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "rruler_wrapper.h"
        
          #include "rcoordinatelistener_wrapper.h"
        
          #include "rpalettelistener_wrapper.h"
        
          #include "qframe_wrapper.h"
        
        #include "rs_wrapper.h"
        
        #include "rscaleselectionoperation_wrapper.h"
        
          #include "roperation_wrapper.h"
        
        #include "rselectionlistener_wrapper.h"
        
        #include "rselectionlisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rselectionlistener_wrapper.h"
        
        #include "rsettings_wrapper.h"
        
        #include "rshape_wrapper.h"
        
        #include "rsingleapplication_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qcoreapplication_wrapper.h"
        
          #include "qguiapplication_wrapper.h"
        
          #include "qapplication_wrapper.h"
        
        #include "rsnap_wrapper.h"
        
        #include "rsnapauto_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
        #include "rsnapcenter_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
        #include "rsnapdistance_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
        #include "rsnapend_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
        #include "rsnapentitybase_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
        #include "rsnapfree_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
        #include "rsnapgrid_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
        #include "rsnapintersection_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
        #include "rsnaplistener_wrapper.h"
        
        #include "rsnapmiddle_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
        #include "rsnaponentity_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
        #include "rsnapperpendicular_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
        #include "rsnapreference_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
        #include "rsnaprestriction_wrapper.h"
        
        #include "rsnaptangential_wrapper.h"
        
          #include "rsnap_wrapper.h"
        
          #include "rsnapentitybase_wrapper.h"
        
        #include "rsoliddata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpolyline_wrapper.h"
        
        #include "rsolidentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rspatialindex_wrapper.h"
        
        #include "rspatialindexnavel_wrapper.h"
        
          #include "rspatialindex_wrapper.h"
        
        #include "rspatialindexsimple_wrapper.h"
        
          #include "rspatialindex_wrapper.h"
        
        #include "rspatialindexvisitor_wrapper.h"
        
        #include "rspatialindexvisitoradapter_wrapper.h"
        
          #include "rspatialindexvisitor_wrapper.h"
        
        #include "rspline_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rexplodable_wrapper.h"
        
        #include "rsplinedata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rspline_wrapper.h"
        
        #include "rsplineentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rstemmer_wrapper.h"
        
        #include "rstorage_wrapper.h"
        
        #include "rtabletevent_wrapper.h"
        
        #include "rterminateevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
        #include "rtextbaseddata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpainterpathsource_wrapper.h"
        
        #include "rtextbasedentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rtextdata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rtextbaseddata_wrapper.h"
        
        #include "rtextedit_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qtextedit_wrapper.h"
        
          #include "qtextbrowser_wrapper.h"
        
        #include "rtextentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
          #include "rtextbasedentity_wrapper.h"
        
        #include "rtextlabel_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rpoint_wrapper.h"
        
        #include "rtextlayout_wrapper.h"
        
        #include "rtextrenderer_wrapper.h"
        
        #include "rtolerancedata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
        #include "rtoleranceentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rtoolbutton_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qtoolbutton_wrapper.h"
        
        #include "rtoolmatrixitemdelegate_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemdelegate_wrapper.h"
        
          #include "qitemdelegate_wrapper.h"
        
        #include "rtooloptioneventfilter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "rtracedata_wrapper.h"
        
          #include "rsoliddata_wrapper.h"
        
        #include "rtraceentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rtransaction_wrapper.h"
        
        #include "rtransactionlistener_wrapper.h"
        
        #include "rtransactionlisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rtransactionlistener_wrapper.h"
        
        #include "rtransactionstack_wrapper.h"
        
        #include "rtransform_wrapper.h"
        
          #include "qtransform_wrapper.h"
        
        #include "rtransformop_wrapper.h"
        
        #include "rtransformation_wrapper.h"
        
        #include "rtranslation_wrapper.h"
        
          #include "rtransformation_wrapper.h"
        
        #include "rtreewidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qtreeview_wrapper.h"
        
          #include "qtreewidget_wrapper.h"
        
        #include "rtriangle_wrapper.h"
        
          #include "rshape_wrapper.h"
        
          #include "rexplodable_wrapper.h"
        
        #include "rucs_wrapper.h"
        
          #include "robject_wrapper.h"
        
        #include "rucslistener_wrapper.h"
        
        #include "runit_wrapper.h"
        
        #include "rvector_wrapper.h"
        
        #include "rview_wrapper.h"
        
          #include "robject_wrapper.h"
        
        #include "rviewfocuslistener_wrapper.h"
        
        #include "rviewfocuslisteneradapter_wrapper.h"
        
          #include "rviewfocuslistener_wrapper.h"
        
        #include "rviewlistener_wrapper.h"
        
        #include "rviewlisteneradapter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "rviewlistener_wrapper.h"
        
        #include "rviewportdata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpoint_wrapper.h"
        
        #include "rviewportentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rwheelevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qinputevent_wrapper.h"
        
          #include "qpointerevent_wrapper.h"
        
          #include "qsinglepointevent_wrapper.h"
        
          #include "qwheelevent_wrapper.h"
        
          #include "rinputevent_wrapper.h"
        
        #include "rwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "rwipeoutdata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rpolylinedata_wrapper.h"
        
        #include "rwipeoutentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
        #include "rxline_wrapper.h"
        
          #include "rshape_wrapper.h"
        
        #include "rxlinedata_wrapper.h"
        
          #include "rentitydata_wrapper.h"
        
          #include "rxline_wrapper.h"
        
        #include "rxlineentity_wrapper.h"
        
          #include "robject_wrapper.h"
        
          #include "rentity_wrapper.h"
        
  // ------------------------------------
  // QSharedPointer types (non-copyable):
  // ------------------------------------
  
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RObject(RJSApi& handler, const QSharedPointer<RObject>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RObject('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          
            {
              QSharedPointer<RBlock> s = v.dynamicCast<RBlock>();
              if (!s.isNull()) {
                return cpp2js_QSharedPointer_RBlock(handler, s);
              }
            }
          
            {
              QSharedPointer<RDimStyle> s = v.dynamicCast<RDimStyle>();
              if (!s.isNull()) {
                return cpp2js_QSharedPointer_RDimStyle(handler, s);
              }
            }
          
            {
              QSharedPointer<RDocumentVariables> s = v.dynamicCast<RDocumentVariables>();
              if (!s.isNull()) {
                return cpp2js_QSharedPointer_RDocumentVariables(handler, s);
              }
            }
          
            {
              QSharedPointer<REntity> s = v.dynamicCast<REntity>();
              if (!s.isNull()) {
                return cpp2js_QSharedPointer_REntity(handler, s);
              }
            }
          
            {
              QSharedPointer<RLayer> s = v.dynamicCast<RLayer>();
              if (!s.isNull()) {
                return cpp2js_QSharedPointer_RLayer(handler, s);
              }
            }
          
            {
              QSharedPointer<RLayerState> s = v.dynamicCast<RLayerState>();
              if (!s.isNull()) {
                return cpp2js_QSharedPointer_RLayerState(handler, s);
              }
            }
          
            {
              QSharedPointer<RLayout> s = v.dynamicCast<RLayout>();
              if (!s.isNull()) {
                return cpp2js_QSharedPointer_RLayout(handler, s);
              }
            }
          
            {
              QSharedPointer<RLinetype> s = v.dynamicCast<RLinetype>();
              if (!s.isNull()) {
                return cpp2js_QSharedPointer_RLinetype(handler, s);
              }
            }
          
            {
              QSharedPointer<RUcs> s = v.dynamicCast<RUcs>();
              if (!s.isNull()) {
                return cpp2js_QSharedPointer_RUcs(handler, s);
              }
            }
          
            {
              QSharedPointer<RView> s = v.dynamicCast<RView>();
              if (!s.isNull()) {
                return cpp2js_QSharedPointer_RView(handler, s);
              }
            }
          

          QJSEngine* engine = handler.getEngine();
          RObject_Wrapper* ret = new RObject_Wrapper(handler, v);

          // JS: new RObject('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RObject");
          if (cl.isUndefined()) {
              qWarning() << "Class RObject is undefined. Use RObject_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RObject> RJSHelper_qcad::js2cpp_QSharedPointer_RObject(RJSApi& handler, const QJSValue& v) {

          
            {
              RJSWrapper* wrapper = getWrapperRJSWrapper(v);
              int t = wrapper->getWrappedType();

              // attempt to downcast to specific type:
              
                if (RJSType_RBlock::isOfType(t)) {
                  return RJSHelper_qcad::js2cpp_QSharedPointer_RBlock(handler, v);
                }
              
                if (RJSType_RDimStyle::isOfType(t)) {
                  return RJSHelper_qcad::js2cpp_QSharedPointer_RDimStyle(handler, v);
                }
              
                if (RJSType_RDocumentVariables::isOfType(t)) {
                  return RJSHelper_qcad::js2cpp_QSharedPointer_RDocumentVariables(handler, v);
                }
              
                if (RJSType_REntity::isOfType(t)) {
                  return RJSHelper_qcad::js2cpp_QSharedPointer_REntity(handler, v);
                }
              
                if (RJSType_RLayer::isOfType(t)) {
                  return RJSHelper_qcad::js2cpp_QSharedPointer_RLayer(handler, v);
                }
              
                if (RJSType_RLayerState::isOfType(t)) {
                  return RJSHelper_qcad::js2cpp_QSharedPointer_RLayerState(handler, v);
                }
              
                if (RJSType_RLayout::isOfType(t)) {
                  return RJSHelper_qcad::js2cpp_QSharedPointer_RLayout(handler, v);
                }
              
                if (RJSType_RLinetype::isOfType(t)) {
                  return RJSHelper_qcad::js2cpp_QSharedPointer_RLinetype(handler, v);
                }
              
                if (RJSType_RUcs::isOfType(t)) {
                  return RJSHelper_qcad::js2cpp_QSharedPointer_RUcs(handler, v);
                }
              
                if (RJSType_RView::isOfType(t)) {
                  return RJSHelper_qcad::js2cpp_QSharedPointer_RView(handler, v);
                }
              
            }
          RObject_Wrapper* wrapper = getWrapper<RObject_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RObject: no wrapper";
              handler.trace();
              return QSharedPointer<RObject>();
          }
          //return QSharedPointer<RObject>(getWrapped_RObject(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RObject>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RObject>(wrapper->getWrappedClone());
              //return QSharedPointer<RObject>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RObject: object cannot be cloned";
              //return QSharedPointer<RObject>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RObject>((RObject*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RObject>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RObject>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RObject(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RObject_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RArcEntity(RJSApi& handler, const QSharedPointer<RArcEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RArcEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RArcEntity_Wrapper* ret = new RArcEntity_Wrapper(handler, v);

          // JS: new RArcEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RArcEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RArcEntity is undefined. Use RArcEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RArcEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RArcEntity(RJSApi& handler, const QJSValue& v) {

          RArcEntity_Wrapper* wrapper = getWrapper<RArcEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RArcEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RArcEntity>();
          }
          //return QSharedPointer<RArcEntity>(getWrapped_RArcEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RArcEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RArcEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RArcEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RArcEntity: object cannot be cloned";
              //return QSharedPointer<RArcEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RArcEntity>((RArcEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RArcEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RArcEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RArcEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RArcEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RAttributeDefinitionEntity(RJSApi& handler, const QSharedPointer<RAttributeDefinitionEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RAttributeDefinitionEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RAttributeDefinitionEntity_Wrapper* ret = new RAttributeDefinitionEntity_Wrapper(handler, v);

          // JS: new RAttributeDefinitionEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RAttributeDefinitionEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RAttributeDefinitionEntity is undefined. Use RAttributeDefinitionEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RAttributeDefinitionEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RAttributeDefinitionEntity(RJSApi& handler, const QJSValue& v) {

          RAttributeDefinitionEntity_Wrapper* wrapper = getWrapper<RAttributeDefinitionEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RAttributeDefinitionEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RAttributeDefinitionEntity>();
          }
          //return QSharedPointer<RAttributeDefinitionEntity>(getWrapped_RAttributeDefinitionEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RAttributeDefinitionEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RAttributeDefinitionEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RAttributeDefinitionEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RAttributeDefinitionEntity: object cannot be cloned";
              //return QSharedPointer<RAttributeDefinitionEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RAttributeDefinitionEntity>((RAttributeDefinitionEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RAttributeDefinitionEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RAttributeDefinitionEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RAttributeDefinitionEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RAttributeDefinitionEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RAttributeEntity(RJSApi& handler, const QSharedPointer<RAttributeEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RAttributeEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RAttributeEntity_Wrapper* ret = new RAttributeEntity_Wrapper(handler, v);

          // JS: new RAttributeEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RAttributeEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RAttributeEntity is undefined. Use RAttributeEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RAttributeEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RAttributeEntity(RJSApi& handler, const QJSValue& v) {

          RAttributeEntity_Wrapper* wrapper = getWrapper<RAttributeEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RAttributeEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RAttributeEntity>();
          }
          //return QSharedPointer<RAttributeEntity>(getWrapped_RAttributeEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RAttributeEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RAttributeEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RAttributeEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RAttributeEntity: object cannot be cloned";
              //return QSharedPointer<RAttributeEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RAttributeEntity>((RAttributeEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RAttributeEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RAttributeEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RAttributeEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RAttributeEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RBlock(RJSApi& handler, const QSharedPointer<RBlock>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RBlock('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RBlock_Wrapper* ret = new RBlock_Wrapper(handler, v);

          // JS: new RBlock('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RBlock");
          if (cl.isUndefined()) {
              qWarning() << "Class RBlock is undefined. Use RBlock_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RBlock> RJSHelper_qcad::js2cpp_QSharedPointer_RBlock(RJSApi& handler, const QJSValue& v) {

          RBlock_Wrapper* wrapper = getWrapper<RBlock_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RBlock: no wrapper";
              handler.trace();
              return QSharedPointer<RBlock>();
          }
          //return QSharedPointer<RBlock>(getWrapped_RBlock(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RBlock>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RBlock>(wrapper->getWrappedClone());
              //return QSharedPointer<RBlock>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RBlock: object cannot be cloned";
              //return QSharedPointer<RBlock>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RBlock>((RBlock*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RBlock>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RBlock>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RBlock(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RBlock_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RBlockReferenceEntity(RJSApi& handler, const QSharedPointer<RBlockReferenceEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RBlockReferenceEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RBlockReferenceEntity_Wrapper* ret = new RBlockReferenceEntity_Wrapper(handler, v);

          // JS: new RBlockReferenceEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RBlockReferenceEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RBlockReferenceEntity is undefined. Use RBlockReferenceEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RBlockReferenceEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RBlockReferenceEntity(RJSApi& handler, const QJSValue& v) {

          RBlockReferenceEntity_Wrapper* wrapper = getWrapper<RBlockReferenceEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RBlockReferenceEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RBlockReferenceEntity>();
          }
          //return QSharedPointer<RBlockReferenceEntity>(getWrapped_RBlockReferenceEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RBlockReferenceEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RBlockReferenceEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RBlockReferenceEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RBlockReferenceEntity: object cannot be cloned";
              //return QSharedPointer<RBlockReferenceEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RBlockReferenceEntity>((RBlockReferenceEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RBlockReferenceEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RBlockReferenceEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RBlockReferenceEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RBlockReferenceEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RCircleEntity(RJSApi& handler, const QSharedPointer<RCircleEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RCircleEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RCircleEntity_Wrapper* ret = new RCircleEntity_Wrapper(handler, v);

          // JS: new RCircleEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RCircleEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RCircleEntity is undefined. Use RCircleEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RCircleEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RCircleEntity(RJSApi& handler, const QJSValue& v) {

          RCircleEntity_Wrapper* wrapper = getWrapper<RCircleEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RCircleEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RCircleEntity>();
          }
          //return QSharedPointer<RCircleEntity>(getWrapped_RCircleEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RCircleEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RCircleEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RCircleEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RCircleEntity: object cannot be cloned";
              //return QSharedPointer<RCircleEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RCircleEntity>((RCircleEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RCircleEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RCircleEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RCircleEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RCircleEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RDimAlignedEntity(RJSApi& handler, const QSharedPointer<RDimAlignedEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RDimAlignedEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RDimAlignedEntity_Wrapper* ret = new RDimAlignedEntity_Wrapper(handler, v);

          // JS: new RDimAlignedEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAlignedEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAlignedEntity is undefined. Use RDimAlignedEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RDimAlignedEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RDimAlignedEntity(RJSApi& handler, const QJSValue& v) {

          RDimAlignedEntity_Wrapper* wrapper = getWrapper<RDimAlignedEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RDimAlignedEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RDimAlignedEntity>();
          }
          //return QSharedPointer<RDimAlignedEntity>(getWrapped_RDimAlignedEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RDimAlignedEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RDimAlignedEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RDimAlignedEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RDimAlignedEntity: object cannot be cloned";
              //return QSharedPointer<RDimAlignedEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RDimAlignedEntity>((RDimAlignedEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RDimAlignedEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RDimAlignedEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RDimAlignedEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RDimAlignedEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RDimAngular2LEntity(RJSApi& handler, const QSharedPointer<RDimAngular2LEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RDimAngular2LEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RDimAngular2LEntity_Wrapper* ret = new RDimAngular2LEntity_Wrapper(handler, v);

          // JS: new RDimAngular2LEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAngular2LEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAngular2LEntity is undefined. Use RDimAngular2LEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RDimAngular2LEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RDimAngular2LEntity(RJSApi& handler, const QJSValue& v) {

          RDimAngular2LEntity_Wrapper* wrapper = getWrapper<RDimAngular2LEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RDimAngular2LEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RDimAngular2LEntity>();
          }
          //return QSharedPointer<RDimAngular2LEntity>(getWrapped_RDimAngular2LEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RDimAngular2LEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RDimAngular2LEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RDimAngular2LEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RDimAngular2LEntity: object cannot be cloned";
              //return QSharedPointer<RDimAngular2LEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RDimAngular2LEntity>((RDimAngular2LEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RDimAngular2LEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RDimAngular2LEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RDimAngular2LEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RDimAngular2LEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RDimAngular3PEntity(RJSApi& handler, const QSharedPointer<RDimAngular3PEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RDimAngular3PEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RDimAngular3PEntity_Wrapper* ret = new RDimAngular3PEntity_Wrapper(handler, v);

          // JS: new RDimAngular3PEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAngular3PEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAngular3PEntity is undefined. Use RDimAngular3PEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RDimAngular3PEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RDimAngular3PEntity(RJSApi& handler, const QJSValue& v) {

          RDimAngular3PEntity_Wrapper* wrapper = getWrapper<RDimAngular3PEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RDimAngular3PEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RDimAngular3PEntity>();
          }
          //return QSharedPointer<RDimAngular3PEntity>(getWrapped_RDimAngular3PEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RDimAngular3PEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RDimAngular3PEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RDimAngular3PEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RDimAngular3PEntity: object cannot be cloned";
              //return QSharedPointer<RDimAngular3PEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RDimAngular3PEntity>((RDimAngular3PEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RDimAngular3PEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RDimAngular3PEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RDimAngular3PEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RDimAngular3PEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RDimAngularData(RJSApi& handler, const QSharedPointer<RDimAngularData>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RDimAngularData('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RDimAngularData_Wrapper* ret = new RDimAngularData_Wrapper(handler, v);

          // JS: new RDimAngularData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAngularData");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAngularData is undefined. Use RDimAngularData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RDimAngularData> RJSHelper_qcad::js2cpp_QSharedPointer_RDimAngularData(RJSApi& handler, const QJSValue& v) {

          RDimAngularData_Wrapper* wrapper = getWrapper<RDimAngularData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RDimAngularData: no wrapper";
              handler.trace();
              return QSharedPointer<RDimAngularData>();
          }
          //return QSharedPointer<RDimAngularData>(getWrapped_RDimAngularData(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RDimAngularData>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RDimAngularData>(wrapper->getWrappedClone());
              //return QSharedPointer<RDimAngularData>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RDimAngularData: object cannot be cloned";
              //return QSharedPointer<RDimAngularData>();

              
                  // cannot be cloned:
                  return QSharedPointer<RDimAngularData>(wrapper->getWrapped());
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RDimAngularData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RDimAngularData_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RDimAngularEntity(RJSApi& handler, const QSharedPointer<RDimAngularEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RDimAngularEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          
            {
              QSharedPointer<RDimAngular2LEntity> s = v.dynamicCast<RDimAngular2LEntity>();
              if (!s.isNull()) {
                return cpp2js_QSharedPointer_RDimAngular2LEntity(handler, s);
              }
            }
          
            {
              QSharedPointer<RDimAngular3PEntity> s = v.dynamicCast<RDimAngular3PEntity>();
              if (!s.isNull()) {
                return cpp2js_QSharedPointer_RDimAngular3PEntity(handler, s);
              }
            }
          
            {
              QSharedPointer<RDimArcLengthEntity> s = v.dynamicCast<RDimArcLengthEntity>();
              if (!s.isNull()) {
                return cpp2js_QSharedPointer_RDimArcLengthEntity(handler, s);
              }
            }
          

          QJSEngine* engine = handler.getEngine();
          RDimAngularEntity_Wrapper* ret = new RDimAngularEntity_Wrapper(handler, v);

          // JS: new RDimAngularEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimAngularEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimAngularEntity is undefined. Use RDimAngularEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RDimAngularEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RDimAngularEntity(RJSApi& handler, const QJSValue& v) {

          
            {
              RJSWrapper* wrapper = getWrapperRJSWrapper(v);
              int t = wrapper->getWrappedType();

              // attempt to downcast to specific type:
              
                if (RJSType_RDimAngular2LEntity::isOfType(t)) {
                  return RJSHelper_qcad::js2cpp_QSharedPointer_RDimAngular2LEntity(handler, v);
                }
              
                if (RJSType_RDimAngular3PEntity::isOfType(t)) {
                  return RJSHelper_qcad::js2cpp_QSharedPointer_RDimAngular3PEntity(handler, v);
                }
              
                if (RJSType_RDimArcLengthEntity::isOfType(t)) {
                  return RJSHelper_qcad::js2cpp_QSharedPointer_RDimArcLengthEntity(handler, v);
                }
              
            }
          RDimAngularEntity_Wrapper* wrapper = getWrapper<RDimAngularEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RDimAngularEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RDimAngularEntity>();
          }
          //return QSharedPointer<RDimAngularEntity>(getWrapped_RDimAngularEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RDimAngularEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RDimAngularEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RDimAngularEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RDimAngularEntity: object cannot be cloned";
              //return QSharedPointer<RDimAngularEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RDimAngularEntity>((RDimAngularEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RDimAngularEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RDimAngularEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RDimAngularEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RDimAngularEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RDimArcLengthEntity(RJSApi& handler, const QSharedPointer<RDimArcLengthEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RDimArcLengthEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RDimArcLengthEntity_Wrapper* ret = new RDimArcLengthEntity_Wrapper(handler, v);

          // JS: new RDimArcLengthEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimArcLengthEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimArcLengthEntity is undefined. Use RDimArcLengthEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RDimArcLengthEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RDimArcLengthEntity(RJSApi& handler, const QJSValue& v) {

          RDimArcLengthEntity_Wrapper* wrapper = getWrapper<RDimArcLengthEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RDimArcLengthEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RDimArcLengthEntity>();
          }
          //return QSharedPointer<RDimArcLengthEntity>(getWrapped_RDimArcLengthEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RDimArcLengthEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RDimArcLengthEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RDimArcLengthEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RDimArcLengthEntity: object cannot be cloned";
              //return QSharedPointer<RDimArcLengthEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RDimArcLengthEntity>((RDimArcLengthEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RDimArcLengthEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RDimArcLengthEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RDimArcLengthEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RDimArcLengthEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RDimDiametricEntity(RJSApi& handler, const QSharedPointer<RDimDiametricEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RDimDiametricEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RDimDiametricEntity_Wrapper* ret = new RDimDiametricEntity_Wrapper(handler, v);

          // JS: new RDimDiametricEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimDiametricEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimDiametricEntity is undefined. Use RDimDiametricEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RDimDiametricEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RDimDiametricEntity(RJSApi& handler, const QJSValue& v) {

          RDimDiametricEntity_Wrapper* wrapper = getWrapper<RDimDiametricEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RDimDiametricEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RDimDiametricEntity>();
          }
          //return QSharedPointer<RDimDiametricEntity>(getWrapped_RDimDiametricEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RDimDiametricEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RDimDiametricEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RDimDiametricEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RDimDiametricEntity: object cannot be cloned";
              //return QSharedPointer<RDimDiametricEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RDimDiametricEntity>((RDimDiametricEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RDimDiametricEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RDimDiametricEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RDimDiametricEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RDimDiametricEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RDimLinearEntity(RJSApi& handler, const QSharedPointer<RDimLinearEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RDimLinearEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          
            {
              QSharedPointer<RDimAlignedEntity> s = v.dynamicCast<RDimAlignedEntity>();
              if (!s.isNull()) {
                return cpp2js_QSharedPointer_RDimAlignedEntity(handler, s);
              }
            }
          
            {
              QSharedPointer<RDimRotatedEntity> s = v.dynamicCast<RDimRotatedEntity>();
              if (!s.isNull()) {
                return cpp2js_QSharedPointer_RDimRotatedEntity(handler, s);
              }
            }
          

          QJSEngine* engine = handler.getEngine();
          RDimLinearEntity_Wrapper* ret = new RDimLinearEntity_Wrapper(handler, v);

          // JS: new RDimLinearEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimLinearEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimLinearEntity is undefined. Use RDimLinearEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RDimLinearEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RDimLinearEntity(RJSApi& handler, const QJSValue& v) {

          
            {
              RJSWrapper* wrapper = getWrapperRJSWrapper(v);
              int t = wrapper->getWrappedType();

              // attempt to downcast to specific type:
              
                if (RJSType_RDimAlignedEntity::isOfType(t)) {
                  return RJSHelper_qcad::js2cpp_QSharedPointer_RDimAlignedEntity(handler, v);
                }
              
                if (RJSType_RDimRotatedEntity::isOfType(t)) {
                  return RJSHelper_qcad::js2cpp_QSharedPointer_RDimRotatedEntity(handler, v);
                }
              
            }
          RDimLinearEntity_Wrapper* wrapper = getWrapper<RDimLinearEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RDimLinearEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RDimLinearEntity>();
          }
          //return QSharedPointer<RDimLinearEntity>(getWrapped_RDimLinearEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RDimLinearEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RDimLinearEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RDimLinearEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RDimLinearEntity: object cannot be cloned";
              //return QSharedPointer<RDimLinearEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RDimLinearEntity>((RDimLinearEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RDimLinearEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RDimLinearEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RDimLinearEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RDimLinearEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RDimOrdinateEntity(RJSApi& handler, const QSharedPointer<RDimOrdinateEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RDimOrdinateEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RDimOrdinateEntity_Wrapper* ret = new RDimOrdinateEntity_Wrapper(handler, v);

          // JS: new RDimOrdinateEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimOrdinateEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimOrdinateEntity is undefined. Use RDimOrdinateEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RDimOrdinateEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RDimOrdinateEntity(RJSApi& handler, const QJSValue& v) {

          RDimOrdinateEntity_Wrapper* wrapper = getWrapper<RDimOrdinateEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RDimOrdinateEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RDimOrdinateEntity>();
          }
          //return QSharedPointer<RDimOrdinateEntity>(getWrapped_RDimOrdinateEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RDimOrdinateEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RDimOrdinateEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RDimOrdinateEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RDimOrdinateEntity: object cannot be cloned";
              //return QSharedPointer<RDimOrdinateEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RDimOrdinateEntity>((RDimOrdinateEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RDimOrdinateEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RDimOrdinateEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RDimOrdinateEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RDimOrdinateEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RDimRadialEntity(RJSApi& handler, const QSharedPointer<RDimRadialEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RDimRadialEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RDimRadialEntity_Wrapper* ret = new RDimRadialEntity_Wrapper(handler, v);

          // JS: new RDimRadialEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimRadialEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimRadialEntity is undefined. Use RDimRadialEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RDimRadialEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RDimRadialEntity(RJSApi& handler, const QJSValue& v) {

          RDimRadialEntity_Wrapper* wrapper = getWrapper<RDimRadialEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RDimRadialEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RDimRadialEntity>();
          }
          //return QSharedPointer<RDimRadialEntity>(getWrapped_RDimRadialEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RDimRadialEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RDimRadialEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RDimRadialEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RDimRadialEntity: object cannot be cloned";
              //return QSharedPointer<RDimRadialEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RDimRadialEntity>((RDimRadialEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RDimRadialEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RDimRadialEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RDimRadialEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RDimRadialEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RDimRotatedEntity(RJSApi& handler, const QSharedPointer<RDimRotatedEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RDimRotatedEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RDimRotatedEntity_Wrapper* ret = new RDimRotatedEntity_Wrapper(handler, v);

          // JS: new RDimRotatedEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimRotatedEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimRotatedEntity is undefined. Use RDimRotatedEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RDimRotatedEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RDimRotatedEntity(RJSApi& handler, const QJSValue& v) {

          RDimRotatedEntity_Wrapper* wrapper = getWrapper<RDimRotatedEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RDimRotatedEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RDimRotatedEntity>();
          }
          //return QSharedPointer<RDimRotatedEntity>(getWrapped_RDimRotatedEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RDimRotatedEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RDimRotatedEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RDimRotatedEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RDimRotatedEntity: object cannot be cloned";
              //return QSharedPointer<RDimRotatedEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RDimRotatedEntity>((RDimRotatedEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RDimRotatedEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RDimRotatedEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RDimRotatedEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RDimRotatedEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RDimStyle(RJSApi& handler, const QSharedPointer<RDimStyle>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RDimStyle('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RDimStyle_Wrapper* ret = new RDimStyle_Wrapper(handler, v);

          // JS: new RDimStyle('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimStyle");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimStyle is undefined. Use RDimStyle_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RDimStyle> RJSHelper_qcad::js2cpp_QSharedPointer_RDimStyle(RJSApi& handler, const QJSValue& v) {

          RDimStyle_Wrapper* wrapper = getWrapper<RDimStyle_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RDimStyle: no wrapper";
              handler.trace();
              return QSharedPointer<RDimStyle>();
          }
          //return QSharedPointer<RDimStyle>(getWrapped_RDimStyle(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RDimStyle>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RDimStyle>(wrapper->getWrappedClone());
              //return QSharedPointer<RDimStyle>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RDimStyle: object cannot be cloned";
              //return QSharedPointer<RDimStyle>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RDimStyle>((RDimStyle*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RDimStyle>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RDimStyle>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RDimStyle(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RDimStyle_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RDimensionEntity(RJSApi& handler, const QSharedPointer<RDimensionEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RDimensionEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          
            {
              QSharedPointer<RDimAlignedEntity> s = v.dynamicCast<RDimAlignedEntity>();
              if (!s.isNull()) {
                return cpp2js_QSharedPointer_RDimAlignedEntity(handler, s);
              }
            }
          
            {
              QSharedPointer<RDimAngular2LEntity> s = v.dynamicCast<RDimAngular2LEntity>();
              if (!s.isNull()) {
                return cpp2js_QSharedPointer_RDimAngular2LEntity(handler, s);
              }
            }
          
            {
              QSharedPointer<RDimAngular3PEntity> s = v.dynamicCast<RDimAngular3PEntity>();
              if (!s.isNull()) {
                return cpp2js_QSharedPointer_RDimAngular3PEntity(handler, s);
              }
            }
          
            {
              QSharedPointer<RDimAngularEntity> s = v.dynamicCast<RDimAngularEntity>();
              if (!s.isNull()) {
                return cpp2js_QSharedPointer_RDimAngularEntity(handler, s);
              }
            }
          
            {
              QSharedPointer<RDimArcLengthEntity> s = v.dynamicCast<RDimArcLengthEntity>();
              if (!s.isNull()) {
                return cpp2js_QSharedPointer_RDimArcLengthEntity(handler, s);
              }
            }
          
            {
              QSharedPointer<RDimDiametricEntity> s = v.dynamicCast<RDimDiametricEntity>();
              if (!s.isNull()) {
                return cpp2js_QSharedPointer_RDimDiametricEntity(handler, s);
              }
            }
          
            {
              QSharedPointer<RDimLinearEntity> s = v.dynamicCast<RDimLinearEntity>();
              if (!s.isNull()) {
                return cpp2js_QSharedPointer_RDimLinearEntity(handler, s);
              }
            }
          
            {
              QSharedPointer<RDimOrdinateEntity> s = v.dynamicCast<RDimOrdinateEntity>();
              if (!s.isNull()) {
                return cpp2js_QSharedPointer_RDimOrdinateEntity(handler, s);
              }
            }
          
            {
              QSharedPointer<RDimRadialEntity> s = v.dynamicCast<RDimRadialEntity>();
              if (!s.isNull()) {
                return cpp2js_QSharedPointer_RDimRadialEntity(handler, s);
              }
            }
          
            {
              QSharedPointer<RDimRotatedEntity> s = v.dynamicCast<RDimRotatedEntity>();
              if (!s.isNull()) {
                return cpp2js_QSharedPointer_RDimRotatedEntity(handler, s);
              }
            }
          

          QJSEngine* engine = handler.getEngine();
          RDimensionEntity_Wrapper* ret = new RDimensionEntity_Wrapper(handler, v);

          // JS: new RDimensionEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDimensionEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RDimensionEntity is undefined. Use RDimensionEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RDimensionEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RDimensionEntity(RJSApi& handler, const QJSValue& v) {

          
            {
              RJSWrapper* wrapper = getWrapperRJSWrapper(v);
              int t = wrapper->getWrappedType();

              // attempt to downcast to specific type:
              
                if (RJSType_RDimAlignedEntity::isOfType(t)) {
                  return RJSHelper_qcad::js2cpp_QSharedPointer_RDimAlignedEntity(handler, v);
                }
              
                if (RJSType_RDimAngular2LEntity::isOfType(t)) {
                  return RJSHelper_qcad::js2cpp_QSharedPointer_RDimAngular2LEntity(handler, v);
                }
              
                if (RJSType_RDimAngular3PEntity::isOfType(t)) {
                  return RJSHelper_qcad::js2cpp_QSharedPointer_RDimAngular3PEntity(handler, v);
                }
              
                if (RJSType_RDimAngularEntity::isOfType(t)) {
                  return RJSHelper_qcad::js2cpp_QSharedPointer_RDimAngularEntity(handler, v);
                }
              
                if (RJSType_RDimArcLengthEntity::isOfType(t)) {
                  return RJSHelper_qcad::js2cpp_QSharedPointer_RDimArcLengthEntity(handler, v);
                }
              
                if (RJSType_RDimDiametricEntity::isOfType(t)) {
                  return RJSHelper_qcad::js2cpp_QSharedPointer_RDimDiametricEntity(handler, v);
                }
              
                if (RJSType_RDimLinearEntity::isOfType(t)) {
                  return RJSHelper_qcad::js2cpp_QSharedPointer_RDimLinearEntity(handler, v);
                }
              
                if (RJSType_RDimOrdinateEntity::isOfType(t)) {
                  return RJSHelper_qcad::js2cpp_QSharedPointer_RDimOrdinateEntity(handler, v);
                }
              
                if (RJSType_RDimRadialEntity::isOfType(t)) {
                  return RJSHelper_qcad::js2cpp_QSharedPointer_RDimRadialEntity(handler, v);
                }
              
                if (RJSType_RDimRotatedEntity::isOfType(t)) {
                  return RJSHelper_qcad::js2cpp_QSharedPointer_RDimRotatedEntity(handler, v);
                }
              
            }
          RDimensionEntity_Wrapper* wrapper = getWrapper<RDimensionEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RDimensionEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RDimensionEntity>();
          }
          //return QSharedPointer<RDimensionEntity>(getWrapped_RDimensionEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RDimensionEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RDimensionEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RDimensionEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RDimensionEntity: object cannot be cloned";
              //return QSharedPointer<RDimensionEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RDimensionEntity>((RDimensionEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RDimensionEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RDimensionEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RDimensionEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RDimensionEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RDocumentVariables(RJSApi& handler, const QSharedPointer<RDocumentVariables>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RDocumentVariables('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RDocumentVariables_Wrapper* ret = new RDocumentVariables_Wrapper(handler, v);

          // JS: new RDocumentVariables('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RDocumentVariables");
          if (cl.isUndefined()) {
              qWarning() << "Class RDocumentVariables is undefined. Use RDocumentVariables_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RDocumentVariables> RJSHelper_qcad::js2cpp_QSharedPointer_RDocumentVariables(RJSApi& handler, const QJSValue& v) {

          RDocumentVariables_Wrapper* wrapper = getWrapper<RDocumentVariables_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RDocumentVariables: no wrapper";
              handler.trace();
              return QSharedPointer<RDocumentVariables>();
          }
          //return QSharedPointer<RDocumentVariables>(getWrapped_RDocumentVariables(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RDocumentVariables>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RDocumentVariables>(wrapper->getWrappedClone());
              //return QSharedPointer<RDocumentVariables>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RDocumentVariables: object cannot be cloned";
              //return QSharedPointer<RDocumentVariables>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RDocumentVariables>((RDocumentVariables*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RDocumentVariables>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RDocumentVariables>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RDocumentVariables(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RDocumentVariables_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_REllipseEntity(RJSApi& handler, const QSharedPointer<REllipseEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new REllipseEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          REllipseEntity_Wrapper* ret = new REllipseEntity_Wrapper(handler, v);

          // JS: new REllipseEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("REllipseEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class REllipseEntity is undefined. Use REllipseEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<REllipseEntity> RJSHelper_qcad::js2cpp_QSharedPointer_REllipseEntity(RJSApi& handler, const QJSValue& v) {

          REllipseEntity_Wrapper* wrapper = getWrapper<REllipseEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_REllipseEntity: no wrapper";
              handler.trace();
              return QSharedPointer<REllipseEntity>();
          }
          //return QSharedPointer<REllipseEntity>(getWrapped_REllipseEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<REllipseEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<REllipseEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<REllipseEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_REllipseEntity: object cannot be cloned";
              //return QSharedPointer<REllipseEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<REllipseEntity>((REllipseEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<REllipseEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<REllipseEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_REllipseEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_REllipseEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RFaceEntity(RJSApi& handler, const QSharedPointer<RFaceEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RFaceEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RFaceEntity_Wrapper* ret = new RFaceEntity_Wrapper(handler, v);

          // JS: new RFaceEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RFaceEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RFaceEntity is undefined. Use RFaceEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RFaceEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RFaceEntity(RJSApi& handler, const QJSValue& v) {

          RFaceEntity_Wrapper* wrapper = getWrapper<RFaceEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RFaceEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RFaceEntity>();
          }
          //return QSharedPointer<RFaceEntity>(getWrapped_RFaceEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RFaceEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RFaceEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RFaceEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RFaceEntity: object cannot be cloned";
              //return QSharedPointer<RFaceEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RFaceEntity>((RFaceEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RFaceEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RFaceEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RFaceEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RFaceEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RHatchEntity(RJSApi& handler, const QSharedPointer<RHatchEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RHatchEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RHatchEntity_Wrapper* ret = new RHatchEntity_Wrapper(handler, v);

          // JS: new RHatchEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RHatchEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RHatchEntity is undefined. Use RHatchEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RHatchEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RHatchEntity(RJSApi& handler, const QJSValue& v) {

          RHatchEntity_Wrapper* wrapper = getWrapper<RHatchEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RHatchEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RHatchEntity>();
          }
          //return QSharedPointer<RHatchEntity>(getWrapped_RHatchEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RHatchEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RHatchEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RHatchEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RHatchEntity: object cannot be cloned";
              //return QSharedPointer<RHatchEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RHatchEntity>((RHatchEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RHatchEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RHatchEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RHatchEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RHatchEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RImageEntity(RJSApi& handler, const QSharedPointer<RImageEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RImageEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RImageEntity_Wrapper* ret = new RImageEntity_Wrapper(handler, v);

          // JS: new RImageEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RImageEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RImageEntity is undefined. Use RImageEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RImageEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RImageEntity(RJSApi& handler, const QJSValue& v) {

          RImageEntity_Wrapper* wrapper = getWrapper<RImageEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RImageEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RImageEntity>();
          }
          //return QSharedPointer<RImageEntity>(getWrapped_RImageEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RImageEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RImageEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RImageEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RImageEntity: object cannot be cloned";
              //return QSharedPointer<RImageEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RImageEntity>((RImageEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RImageEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RImageEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RImageEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RImageEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RLayer(RJSApi& handler, const QSharedPointer<RLayer>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RLayer('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RLayer_Wrapper* ret = new RLayer_Wrapper(handler, v);

          // JS: new RLayer('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLayer");
          if (cl.isUndefined()) {
              qWarning() << "Class RLayer is undefined. Use RLayer_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RLayer> RJSHelper_qcad::js2cpp_QSharedPointer_RLayer(RJSApi& handler, const QJSValue& v) {

          RLayer_Wrapper* wrapper = getWrapper<RLayer_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RLayer: no wrapper";
              handler.trace();
              return QSharedPointer<RLayer>();
          }
          //return QSharedPointer<RLayer>(getWrapped_RLayer(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RLayer>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RLayer>(wrapper->getWrappedClone());
              //return QSharedPointer<RLayer>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RLayer: object cannot be cloned";
              //return QSharedPointer<RLayer>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RLayer>((RLayer*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RLayer>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RLayer>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RLayer(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RLayer_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RLayerState(RJSApi& handler, const QSharedPointer<RLayerState>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RLayerState('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RLayerState_Wrapper* ret = new RLayerState_Wrapper(handler, v);

          // JS: new RLayerState('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLayerState");
          if (cl.isUndefined()) {
              qWarning() << "Class RLayerState is undefined. Use RLayerState_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RLayerState> RJSHelper_qcad::js2cpp_QSharedPointer_RLayerState(RJSApi& handler, const QJSValue& v) {

          RLayerState_Wrapper* wrapper = getWrapper<RLayerState_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RLayerState: no wrapper";
              handler.trace();
              return QSharedPointer<RLayerState>();
          }
          //return QSharedPointer<RLayerState>(getWrapped_RLayerState(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RLayerState>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RLayerState>(wrapper->getWrappedClone());
              //return QSharedPointer<RLayerState>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RLayerState: object cannot be cloned";
              //return QSharedPointer<RLayerState>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RLayerState>((RLayerState*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RLayerState>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RLayerState>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RLayerState(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RLayerState_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RLayout(RJSApi& handler, const QSharedPointer<RLayout>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RLayout('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RLayout_Wrapper* ret = new RLayout_Wrapper(handler, v);

          // JS: new RLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class RLayout is undefined. Use RLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RLayout> RJSHelper_qcad::js2cpp_QSharedPointer_RLayout(RJSApi& handler, const QJSValue& v) {

          RLayout_Wrapper* wrapper = getWrapper<RLayout_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RLayout: no wrapper";
              handler.trace();
              return QSharedPointer<RLayout>();
          }
          //return QSharedPointer<RLayout>(getWrapped_RLayout(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RLayout>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RLayout>(wrapper->getWrappedClone());
              //return QSharedPointer<RLayout>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RLayout: object cannot be cloned";
              //return QSharedPointer<RLayout>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RLayout>((RLayout*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RLayout>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RLayout>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RLayout(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RLayout_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RLeaderEntity(RJSApi& handler, const QSharedPointer<RLeaderEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RLeaderEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RLeaderEntity_Wrapper* ret = new RLeaderEntity_Wrapper(handler, v);

          // JS: new RLeaderEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLeaderEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RLeaderEntity is undefined. Use RLeaderEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RLeaderEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RLeaderEntity(RJSApi& handler, const QJSValue& v) {

          RLeaderEntity_Wrapper* wrapper = getWrapper<RLeaderEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RLeaderEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RLeaderEntity>();
          }
          //return QSharedPointer<RLeaderEntity>(getWrapped_RLeaderEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RLeaderEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RLeaderEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RLeaderEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RLeaderEntity: object cannot be cloned";
              //return QSharedPointer<RLeaderEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RLeaderEntity>((RLeaderEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RLeaderEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RLeaderEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RLeaderEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RLeaderEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RLineEntity(RJSApi& handler, const QSharedPointer<RLineEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RLineEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RLineEntity_Wrapper* ret = new RLineEntity_Wrapper(handler, v);

          // JS: new RLineEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLineEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RLineEntity is undefined. Use RLineEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RLineEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RLineEntity(RJSApi& handler, const QJSValue& v) {

          RLineEntity_Wrapper* wrapper = getWrapper<RLineEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RLineEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RLineEntity>();
          }
          //return QSharedPointer<RLineEntity>(getWrapped_RLineEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RLineEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RLineEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RLineEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RLineEntity: object cannot be cloned";
              //return QSharedPointer<RLineEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RLineEntity>((RLineEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RLineEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RLineEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RLineEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RLineEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RLinetype(RJSApi& handler, const QSharedPointer<RLinetype>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RLinetype('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RLinetype_Wrapper* ret = new RLinetype_Wrapper(handler, v);

          // JS: new RLinetype('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RLinetype");
          if (cl.isUndefined()) {
              qWarning() << "Class RLinetype is undefined. Use RLinetype_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RLinetype> RJSHelper_qcad::js2cpp_QSharedPointer_RLinetype(RJSApi& handler, const QJSValue& v) {

          RLinetype_Wrapper* wrapper = getWrapper<RLinetype_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RLinetype: no wrapper";
              handler.trace();
              return QSharedPointer<RLinetype>();
          }
          //return QSharedPointer<RLinetype>(getWrapped_RLinetype(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RLinetype>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RLinetype>(wrapper->getWrappedClone());
              //return QSharedPointer<RLinetype>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RLinetype: object cannot be cloned";
              //return QSharedPointer<RLinetype>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RLinetype>((RLinetype*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RLinetype>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RLinetype>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RLinetype(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RLinetype_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RPointEntity(RJSApi& handler, const QSharedPointer<RPointEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RPointEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RPointEntity_Wrapper* ret = new RPointEntity_Wrapper(handler, v);

          // JS: new RPointEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPointEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RPointEntity is undefined. Use RPointEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RPointEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RPointEntity(RJSApi& handler, const QJSValue& v) {

          RPointEntity_Wrapper* wrapper = getWrapper<RPointEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RPointEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RPointEntity>();
          }
          //return QSharedPointer<RPointEntity>(getWrapped_RPointEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RPointEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RPointEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RPointEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RPointEntity: object cannot be cloned";
              //return QSharedPointer<RPointEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RPointEntity>((RPointEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RPointEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RPointEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RPointEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RPointEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RPolyline(RJSApi& handler, const QSharedPointer<RPolyline>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RPolyline('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RPolyline_Wrapper* ret = new RPolyline_Wrapper(handler, v);

          // JS: new RPolyline('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPolyline");
          if (cl.isUndefined()) {
              qWarning() << "Class RPolyline is undefined. Use RPolyline_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RPolyline> RJSHelper_qcad::js2cpp_QSharedPointer_RPolyline(RJSApi& handler, const QJSValue& v) {

          RPolyline_Wrapper* wrapper = getWrapper<RPolyline_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RPolyline: no wrapper";
              handler.trace();
              return QSharedPointer<RPolyline>();
          }
          //return QSharedPointer<RPolyline>(getWrapped_RPolyline(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RPolyline>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RPolyline>(wrapper->getWrappedClone());
              //return QSharedPointer<RPolyline>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RPolyline: object cannot be cloned";
              //return QSharedPointer<RPolyline>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RPolyline>((RPolyline*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RPolyline>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RPolyline>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RPolyline(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RPolyline_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RPolylineEntity(RJSApi& handler, const QSharedPointer<RPolylineEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RPolylineEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RPolylineEntity_Wrapper* ret = new RPolylineEntity_Wrapper(handler, v);

          // JS: new RPolylineEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RPolylineEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RPolylineEntity is undefined. Use RPolylineEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RPolylineEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RPolylineEntity(RJSApi& handler, const QJSValue& v) {

          RPolylineEntity_Wrapper* wrapper = getWrapper<RPolylineEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RPolylineEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RPolylineEntity>();
          }
          //return QSharedPointer<RPolylineEntity>(getWrapped_RPolylineEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RPolylineEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RPolylineEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RPolylineEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RPolylineEntity: object cannot be cloned";
              //return QSharedPointer<RPolylineEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RPolylineEntity>((RPolylineEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RPolylineEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RPolylineEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RPolylineEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RPolylineEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RRayEntity(RJSApi& handler, const QSharedPointer<RRayEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RRayEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RRayEntity_Wrapper* ret = new RRayEntity_Wrapper(handler, v);

          // JS: new RRayEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RRayEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RRayEntity is undefined. Use RRayEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RRayEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RRayEntity(RJSApi& handler, const QJSValue& v) {

          RRayEntity_Wrapper* wrapper = getWrapper<RRayEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RRayEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RRayEntity>();
          }
          //return QSharedPointer<RRayEntity>(getWrapped_RRayEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RRayEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RRayEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RRayEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RRayEntity: object cannot be cloned";
              //return QSharedPointer<RRayEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RRayEntity>((RRayEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RRayEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RRayEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RRayEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RRayEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RSolidEntity(RJSApi& handler, const QSharedPointer<RSolidEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RSolidEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RSolidEntity_Wrapper* ret = new RSolidEntity_Wrapper(handler, v);

          // JS: new RSolidEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSolidEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RSolidEntity is undefined. Use RSolidEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RSolidEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RSolidEntity(RJSApi& handler, const QJSValue& v) {

          RSolidEntity_Wrapper* wrapper = getWrapper<RSolidEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RSolidEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RSolidEntity>();
          }
          //return QSharedPointer<RSolidEntity>(getWrapped_RSolidEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RSolidEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RSolidEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RSolidEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RSolidEntity: object cannot be cloned";
              //return QSharedPointer<RSolidEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RSolidEntity>((RSolidEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RSolidEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RSolidEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RSolidEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RSolidEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RSplineEntity(RJSApi& handler, const QSharedPointer<RSplineEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RSplineEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RSplineEntity_Wrapper* ret = new RSplineEntity_Wrapper(handler, v);

          // JS: new RSplineEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RSplineEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RSplineEntity is undefined. Use RSplineEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RSplineEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RSplineEntity(RJSApi& handler, const QJSValue& v) {

          RSplineEntity_Wrapper* wrapper = getWrapper<RSplineEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RSplineEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RSplineEntity>();
          }
          //return QSharedPointer<RSplineEntity>(getWrapped_RSplineEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RSplineEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RSplineEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RSplineEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RSplineEntity: object cannot be cloned";
              //return QSharedPointer<RSplineEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RSplineEntity>((RSplineEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RSplineEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RSplineEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RSplineEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RSplineEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RTextEntity(RJSApi& handler, const QSharedPointer<RTextEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RTextEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RTextEntity_Wrapper* ret = new RTextEntity_Wrapper(handler, v);

          // JS: new RTextEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTextEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RTextEntity is undefined. Use RTextEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RTextEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RTextEntity(RJSApi& handler, const QJSValue& v) {

          RTextEntity_Wrapper* wrapper = getWrapper<RTextEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RTextEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RTextEntity>();
          }
          //return QSharedPointer<RTextEntity>(getWrapped_RTextEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RTextEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RTextEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RTextEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RTextEntity: object cannot be cloned";
              //return QSharedPointer<RTextEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RTextEntity>((RTextEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RTextEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RTextEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RTextEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RTextEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RTextBasedEntity(RJSApi& handler, const QSharedPointer<RTextBasedEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RTextBasedEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          
            {
              QSharedPointer<RAttributeDefinitionEntity> s = v.dynamicCast<RAttributeDefinitionEntity>();
              if (!s.isNull()) {
                return cpp2js_QSharedPointer_RAttributeDefinitionEntity(handler, s);
              }
            }
          
            {
              QSharedPointer<RAttributeEntity> s = v.dynamicCast<RAttributeEntity>();
              if (!s.isNull()) {
                return cpp2js_QSharedPointer_RAttributeEntity(handler, s);
              }
            }
          
            {
              QSharedPointer<RTextEntity> s = v.dynamicCast<RTextEntity>();
              if (!s.isNull()) {
                return cpp2js_QSharedPointer_RTextEntity(handler, s);
              }
            }
          

          QJSEngine* engine = handler.getEngine();
          RTextBasedEntity_Wrapper* ret = new RTextBasedEntity_Wrapper(handler, v);

          // JS: new RTextBasedEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTextBasedEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RTextBasedEntity is undefined. Use RTextBasedEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RTextBasedEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RTextBasedEntity(RJSApi& handler, const QJSValue& v) {

          
            {
              RJSWrapper* wrapper = getWrapperRJSWrapper(v);
              int t = wrapper->getWrappedType();

              // attempt to downcast to specific type:
              
                if (RJSType_RAttributeDefinitionEntity::isOfType(t)) {
                  return RJSHelper_qcad::js2cpp_QSharedPointer_RAttributeDefinitionEntity(handler, v);
                }
              
                if (RJSType_RAttributeEntity::isOfType(t)) {
                  return RJSHelper_qcad::js2cpp_QSharedPointer_RAttributeEntity(handler, v);
                }
              
                if (RJSType_RTextEntity::isOfType(t)) {
                  return RJSHelper_qcad::js2cpp_QSharedPointer_RTextEntity(handler, v);
                }
              
            }
          RTextBasedEntity_Wrapper* wrapper = getWrapper<RTextBasedEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RTextBasedEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RTextBasedEntity>();
          }
          //return QSharedPointer<RTextBasedEntity>(getWrapped_RTextBasedEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RTextBasedEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RTextBasedEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RTextBasedEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RTextBasedEntity: object cannot be cloned";
              //return QSharedPointer<RTextBasedEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RTextBasedEntity>((RTextBasedEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RTextBasedEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RTextBasedEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RTextBasedEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RTextBasedEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RToleranceEntity(RJSApi& handler, const QSharedPointer<RToleranceEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RToleranceEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RToleranceEntity_Wrapper* ret = new RToleranceEntity_Wrapper(handler, v);

          // JS: new RToleranceEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RToleranceEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RToleranceEntity is undefined. Use RToleranceEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RToleranceEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RToleranceEntity(RJSApi& handler, const QJSValue& v) {

          RToleranceEntity_Wrapper* wrapper = getWrapper<RToleranceEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RToleranceEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RToleranceEntity>();
          }
          //return QSharedPointer<RToleranceEntity>(getWrapped_RToleranceEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RToleranceEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RToleranceEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RToleranceEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RToleranceEntity: object cannot be cloned";
              //return QSharedPointer<RToleranceEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RToleranceEntity>((RToleranceEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RToleranceEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RToleranceEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RToleranceEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RToleranceEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RTraceEntity(RJSApi& handler, const QSharedPointer<RTraceEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RTraceEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RTraceEntity_Wrapper* ret = new RTraceEntity_Wrapper(handler, v);

          // JS: new RTraceEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RTraceEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RTraceEntity is undefined. Use RTraceEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RTraceEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RTraceEntity(RJSApi& handler, const QJSValue& v) {

          RTraceEntity_Wrapper* wrapper = getWrapper<RTraceEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RTraceEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RTraceEntity>();
          }
          //return QSharedPointer<RTraceEntity>(getWrapped_RTraceEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RTraceEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RTraceEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RTraceEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RTraceEntity: object cannot be cloned";
              //return QSharedPointer<RTraceEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RTraceEntity>((RTraceEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RTraceEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RTraceEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RTraceEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RTraceEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RUcs(RJSApi& handler, const QSharedPointer<RUcs>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RUcs('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RUcs_Wrapper* ret = new RUcs_Wrapper(handler, v);

          // JS: new RUcs('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RUcs");
          if (cl.isUndefined()) {
              qWarning() << "Class RUcs is undefined. Use RUcs_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RUcs> RJSHelper_qcad::js2cpp_QSharedPointer_RUcs(RJSApi& handler, const QJSValue& v) {

          RUcs_Wrapper* wrapper = getWrapper<RUcs_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RUcs: no wrapper";
              handler.trace();
              return QSharedPointer<RUcs>();
          }
          //return QSharedPointer<RUcs>(getWrapped_RUcs(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RUcs>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RUcs>(wrapper->getWrappedClone());
              //return QSharedPointer<RUcs>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RUcs: object cannot be cloned";
              //return QSharedPointer<RUcs>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RUcs>((RUcs*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RUcs>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RUcs>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RUcs(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RUcs_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RView(RJSApi& handler, const QSharedPointer<RView>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RView('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RView_Wrapper* ret = new RView_Wrapper(handler, v);

          // JS: new RView('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RView");
          if (cl.isUndefined()) {
              qWarning() << "Class RView is undefined. Use RView_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RView> RJSHelper_qcad::js2cpp_QSharedPointer_RView(RJSApi& handler, const QJSValue& v) {

          RView_Wrapper* wrapper = getWrapper<RView_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RView: no wrapper";
              handler.trace();
              return QSharedPointer<RView>();
          }
          //return QSharedPointer<RView>(getWrapped_RView(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RView>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RView>(wrapper->getWrappedClone());
              //return QSharedPointer<RView>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RView: object cannot be cloned";
              //return QSharedPointer<RView>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RView>((RView*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RView>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RView>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RView(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RView_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RViewportEntity(RJSApi& handler, const QSharedPointer<RViewportEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RViewportEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RViewportEntity_Wrapper* ret = new RViewportEntity_Wrapper(handler, v);

          // JS: new RViewportEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RViewportEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RViewportEntity is undefined. Use RViewportEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RViewportEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RViewportEntity(RJSApi& handler, const QJSValue& v) {

          RViewportEntity_Wrapper* wrapper = getWrapper<RViewportEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RViewportEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RViewportEntity>();
          }
          //return QSharedPointer<RViewportEntity>(getWrapped_RViewportEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RViewportEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RViewportEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RViewportEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RViewportEntity: object cannot be cloned";
              //return QSharedPointer<RViewportEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RViewportEntity>((RViewportEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RViewportEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RViewportEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RViewportEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RViewportEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RWipeoutEntity(RJSApi& handler, const QSharedPointer<RWipeoutEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RWipeoutEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RWipeoutEntity_Wrapper* ret = new RWipeoutEntity_Wrapper(handler, v);

          // JS: new RWipeoutEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RWipeoutEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RWipeoutEntity is undefined. Use RWipeoutEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RWipeoutEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RWipeoutEntity(RJSApi& handler, const QJSValue& v) {

          RWipeoutEntity_Wrapper* wrapper = getWrapper<RWipeoutEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RWipeoutEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RWipeoutEntity>();
          }
          //return QSharedPointer<RWipeoutEntity>(getWrapped_RWipeoutEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RWipeoutEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RWipeoutEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RWipeoutEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RWipeoutEntity: object cannot be cloned";
              //return QSharedPointer<RWipeoutEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RWipeoutEntity>((RWipeoutEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RWipeoutEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RWipeoutEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RWipeoutEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RWipeoutEntity_Type;
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper_qcad::cpp2js_QSharedPointer_RXLineEntity(RJSApi& handler, const QSharedPointer<RXLineEntity>& v) {

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new RXLineEntity('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          QJSEngine* engine = handler.getEngine();
          RXLineEntity_Wrapper* ret = new RXLineEntity_Wrapper(handler, v);

          // JS: new RXLineEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("RXLineEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class RXLineEntity is undefined. Use RXLineEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<RXLineEntity> RJSHelper_qcad::js2cpp_QSharedPointer_RXLineEntity(RJSApi& handler, const QJSValue& v) {

          RXLineEntity_Wrapper* wrapper = getWrapper<RXLineEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_RXLineEntity: no wrapper";
              handler.trace();
              return QSharedPointer<RXLineEntity>();
          }
          //return QSharedPointer<RXLineEntity>(getWrapped_RXLineEntity(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<RXLineEntity>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<RXLineEntity>(wrapper->getWrappedClone());
              //return QSharedPointer<RXLineEntity>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_RXLineEntity: object cannot be cloned";
              //return QSharedPointer<RXLineEntity>();

              
                  // create clone on the fly:
                  //return QSharedPointer<RXLineEntity>((RXLineEntity*)wrapper->getWrapped()->clone());
                  //return QSharedPointer<RXLineEntity>(wrapper->getWrapped()->clone());
                  return wrapper->getWrapped()->clone().dynamicCast<RXLineEntity>();
                
          }
      }

      bool RJSHelper_qcad::is_QSharedPointer_RXLineEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_RXLineEntity_Type;
          return !v.isUndefined();
      }
    